require_gobject("GObject", "2.0")
require_gobject("GLib", "2.0")

@[Link("gio-2.0", pkg_config: "gio-2.0")]
lib LibGio
  ###########################################
  # #    Interfaces
  ###########################################

  struct Action # interface
    g_iface : LibGObject::TypeInterface
    get_name : Pointer(LibGio::Action) -> Pointer(UInt8)
    get_parameter_type : Pointer(LibGio::Action) -> Pointer(LibGLib::VariantType)
    get_state_type : Pointer(LibGio::Action) -> Pointer(LibGLib::VariantType)
    get_state_hint : Pointer(LibGio::Action) -> Pointer(LibGLib::Variant)
    get_enabled : Pointer(LibGio::Action) -> LibC::Int
    get_state : Pointer(LibGio::Action) -> Pointer(LibGLib::Variant)
    change_state : Pointer(LibGio::Action), Pointer(LibGLib::Variant) -> Void
    activate : Pointer(LibGio::Action), Pointer(LibGLib::Variant) -> Void
    # Virtual function activate
    # Virtual function change_state
    # Virtual function get_enabled
    # Virtual function get_name
    # Virtual function get_parameter_type
    # Virtual function get_state
    # Virtual function get_state_hint
    # Virtual function get_state_type
    # Property enabled : LibC::Int
    # Property name : Pointer(UInt8)
    # Property parameter-type : LibGLib::VariantType
    # Property state : LibGLib::Variant
    # Property state-type : LibGLib::VariantType
  end

  fun _g_action_get_type = g_action_get_type : UInt64
  fun action_name_is_valid = g_action_name_is_valid(action_name : Pointer(UInt8)) : LibC::Int
  fun action_parse_detailed_name = g_action_parse_detailed_name(detailed_name : Pointer(UInt8), action_name : Pointer(UInt8)*, target_value : Pointer(LibGLib::Variant)*, error : LibGLib::Error**) : LibC::Int
  fun action_print_detailed_name = g_action_print_detailed_name(action_name : Pointer(UInt8), target_value : Pointer(LibGLib::Variant)) : Pointer(UInt8)
  fun action_activate = g_action_activate(this : Action*, parameter : Pointer(LibGLib::Variant)) : Void
  fun action_change_state = g_action_change_state(this : Action*, value : Pointer(LibGLib::Variant)) : Void
  fun action_get_enabled = g_action_get_enabled(this : Action*) : LibC::Int
  fun action_get_name = g_action_get_name(this : Action*) : Pointer(UInt8)
  fun action_get_parameter_type = g_action_get_parameter_type(this : Action*) : Pointer(LibGLib::VariantType)
  fun action_get_state = g_action_get_state(this : Action*) : Pointer(LibGLib::Variant)
  fun action_get_state_hint = g_action_get_state_hint(this : Action*) : Pointer(LibGLib::Variant)
  fun action_get_state_type = g_action_get_state_type(this : Action*) : Pointer(LibGLib::VariantType)

  struct ActionGroup # interface
    g_iface : LibGObject::TypeInterface
    has_action : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> LibC::Int
    list_actions : Pointer(LibGio::ActionGroup) -> Pointer(Pointer(UInt8))
    get_action_enabled : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> LibC::Int
    get_action_parameter_type : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::VariantType)
    get_action_state_type : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::VariantType)
    get_action_state_hint : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::Variant)
    get_action_state : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::Variant)
    change_action_state : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    activate_action : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    action_added : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Void
    action_removed : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Void
    action_enabled_changed : Pointer(LibGio::ActionGroup), Pointer(UInt8), LibC::Int -> Void
    action_state_changed : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    query_action : Pointer(LibGio::ActionGroup), Pointer(UInt8), LibC::Int, Pointer(LibGLib::VariantType), Pointer(LibGLib::VariantType), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> LibC::Int
    # Signal action-added
    # Signal action-enabled-changed
    # Signal action-removed
    # Signal action-state-changed
    # Virtual function action_added
    # Virtual function action_enabled_changed
    # Virtual function action_removed
    # Virtual function action_state_changed
    # Virtual function activate_action
    # Virtual function change_action_state
    # Virtual function get_action_enabled
    # Virtual function get_action_parameter_type
    # Virtual function get_action_state
    # Virtual function get_action_state_hint
    # Virtual function get_action_state_type
    # Virtual function has_action
    # Virtual function list_actions
    # Virtual function query_action
  end

  fun _g_action_group_get_type = g_action_group_get_type : UInt64
  fun action_group_action_added = g_action_group_action_added(this : ActionGroup*, action_name : Pointer(UInt8)) : Void
  fun action_group_action_enabled_changed = g_action_group_action_enabled_changed(this : ActionGroup*, action_name : Pointer(UInt8), enabled : LibC::Int) : Void
  fun action_group_action_removed = g_action_group_action_removed(this : ActionGroup*, action_name : Pointer(UInt8)) : Void
  fun action_group_action_state_changed = g_action_group_action_state_changed(this : ActionGroup*, action_name : Pointer(UInt8), state : Pointer(LibGLib::Variant)) : Void
  fun action_group_activate_action = g_action_group_activate_action(this : ActionGroup*, action_name : Pointer(UInt8), parameter : Pointer(LibGLib::Variant)) : Void
  fun action_group_change_action_state = g_action_group_change_action_state(this : ActionGroup*, action_name : Pointer(UInt8), value : Pointer(LibGLib::Variant)) : Void
  fun action_group_get_action_enabled = g_action_group_get_action_enabled(this : ActionGroup*, action_name : Pointer(UInt8)) : LibC::Int
  fun action_group_get_action_parameter_type = g_action_group_get_action_parameter_type(this : ActionGroup*, action_name : Pointer(UInt8)) : Pointer(LibGLib::VariantType)
  fun action_group_get_action_state = g_action_group_get_action_state(this : ActionGroup*, action_name : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun action_group_get_action_state_hint = g_action_group_get_action_state_hint(this : ActionGroup*, action_name : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun action_group_get_action_state_type = g_action_group_get_action_state_type(this : ActionGroup*, action_name : Pointer(UInt8)) : Pointer(LibGLib::VariantType)
  fun action_group_has_action = g_action_group_has_action(this : ActionGroup*, action_name : Pointer(UInt8)) : LibC::Int
  fun action_group_list_actions = g_action_group_list_actions(this : ActionGroup*) : Pointer(Pointer(UInt8))
  fun action_group_query_action = g_action_group_query_action(this : ActionGroup*, action_name : Pointer(UInt8), enabled : LibC::Int*, parameter_type : Pointer(LibGLib::VariantType)*, state_type : Pointer(LibGLib::VariantType)*, state_hint : Pointer(LibGLib::Variant)*, state : Pointer(LibGLib::Variant)*) : LibC::Int

  struct ActionMap # interface
    g_iface : LibGObject::TypeInterface
    lookup_action : Pointer(LibGio::ActionMap), Pointer(UInt8) -> Pointer(LibGio::Action)
    add_action : Pointer(LibGio::ActionMap), Pointer(LibGio::Action) -> Void
    remove_action : Pointer(LibGio::ActionMap), Pointer(UInt8) -> Void
    # Virtual function add_action
    # Virtual function lookup_action
    # Virtual function remove_action
  end

  fun _g_action_map_get_type = g_action_map_get_type : UInt64
  fun action_map_add_action = g_action_map_add_action(this : ActionMap*, action : Pointer(LibGio::Action)) : Void
  fun action_map_add_action_entries = g_action_map_add_action_entries(this : ActionMap*, entries : Pointer(LibGio::ActionEntry), n_entries : Int32, user_data : Pointer(Void)) : Void
  fun action_map_lookup_action = g_action_map_lookup_action(this : ActionMap*, action_name : Pointer(UInt8)) : Pointer(LibGio::Action)
  fun action_map_remove_action = g_action_map_remove_action(this : ActionMap*, action_name : Pointer(UInt8)) : Void

  struct AppInfo # interface
    g_iface : LibGObject::TypeInterface
    dup : Pointer(LibGio::AppInfo) -> Pointer(LibGio::AppInfo)
    equal : Pointer(LibGio::AppInfo), Pointer(LibGio::AppInfo) -> LibC::Int
    get_id : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_name : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_description : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_executable : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::AppInfo) -> Pointer(LibGio::Icon)
    launch : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), LibGLib::Error* -> LibC::Int
    supports_uris : Pointer(LibGio::AppInfo) -> LibC::Int
    supports_files : Pointer(LibGio::AppInfo) -> LibC::Int
    launch_uris : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), LibGLib::Error* -> LibC::Int
    should_show : Pointer(LibGio::AppInfo) -> LibC::Int
    set_as_default_for_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    set_as_default_for_extension : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    add_supports_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    can_remove_supports_type : Pointer(LibGio::AppInfo) -> LibC::Int
    remove_supports_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    can_delete : Pointer(LibGio::AppInfo) -> LibC::Int
    do_delete : Pointer(LibGio::AppInfo) -> LibC::Int
    get_commandline : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_display_name : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    set_as_last_used_for_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    get_supported_types : Pointer(LibGio::AppInfo) -> Pointer(Pointer(UInt8))
    launch_uris_async : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    launch_uris_finish : Pointer(LibGio::AppInfo), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    # Virtual function add_supports_type
    # Virtual function can_delete
    # Virtual function can_remove_supports_type
    # Virtual function do_delete
    # Virtual function dup
    # Virtual function equal
    # Virtual function get_commandline
    # Virtual function get_description
    # Virtual function get_display_name
    # Virtual function get_executable
    # Virtual function get_icon
    # Virtual function get_id
    # Virtual function get_name
    # Virtual function get_supported_types
    # Virtual function launch
    # Virtual function launch_uris
    # Virtual function launch_uris_async
    # Virtual function launch_uris_finish
    # Virtual function remove_supports_type
    # Virtual function set_as_default_for_extension
    # Virtual function set_as_default_for_type
    # Virtual function set_as_last_used_for_type
    # Virtual function should_show
    # Virtual function supports_files
    # Virtual function supports_uris
  end

  fun _g_app_info_get_type = g_app_info_get_type : UInt64
  fun app_info_create_from_commandline = g_app_info_create_from_commandline(commandline : Pointer(UInt8), application_name : Pointer(UInt8), flags : LibGio::AppInfoCreateFlags, error : LibGLib::Error**) : Pointer(LibGio::AppInfo)
  fun app_info_get_all = g_app_info_get_all : Pointer(Void*)
  fun app_info_get_all_for_type = g_app_info_get_all_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_get_default_for_type = g_app_info_get_default_for_type(content_type : Pointer(UInt8), must_support_uris : LibC::Int) : Pointer(LibGio::AppInfo)
  fun app_info_get_default_for_uri_scheme = g_app_info_get_default_for_uri_scheme(uri_scheme : Pointer(UInt8)) : Pointer(LibGio::AppInfo)
  fun app_info_get_fallback_for_type = g_app_info_get_fallback_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_get_recommended_for_type = g_app_info_get_recommended_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_launch_default_for_uri = g_app_info_launch_default_for_uri(uri : Pointer(UInt8), context : Pointer(LibGio::AppLaunchContext), error : LibGLib::Error**) : LibC::Int
  fun app_info_launch_default_for_uri_async = g_app_info_launch_default_for_uri_async(uri : Pointer(UInt8), context : Pointer(LibGio::AppLaunchContext), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun app_info_launch_default_for_uri_finish = g_app_info_launch_default_for_uri_finish(result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun app_info_reset_type_associations = g_app_info_reset_type_associations(content_type : Pointer(UInt8)) : Void
  fun app_info_add_supports_type = g_app_info_add_supports_type(this : AppInfo*, content_type : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun app_info_can_delete = g_app_info_can_delete(this : AppInfo*) : LibC::Int
  fun app_info_can_remove_supports_type = g_app_info_can_remove_supports_type(this : AppInfo*) : LibC::Int
  fun app_info_delete = g_app_info_delete(this : AppInfo*) : LibC::Int
  fun app_info_dup = g_app_info_dup(this : AppInfo*) : Pointer(LibGio::AppInfo)
  fun app_info_equal = g_app_info_equal(this : AppInfo*, appinfo2 : Pointer(LibGio::AppInfo)) : LibC::Int
  fun app_info_get_commandline = g_app_info_get_commandline(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_description = g_app_info_get_description(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_display_name = g_app_info_get_display_name(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_executable = g_app_info_get_executable(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_icon = g_app_info_get_icon(this : AppInfo*) : Pointer(LibGio::Icon)
  fun app_info_get_id = g_app_info_get_id(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_name = g_app_info_get_name(this : AppInfo*) : Pointer(UInt8)
  fun app_info_get_supported_types = g_app_info_get_supported_types(this : AppInfo*) : Pointer(Pointer(UInt8))
  fun app_info_launch = g_app_info_launch(this : AppInfo*, files : Pointer(Void*), context : Pointer(LibGio::AppLaunchContext), error : LibGLib::Error**) : LibC::Int
  fun app_info_launch_uris = g_app_info_launch_uris(this : AppInfo*, uris : Pointer(Void*), context : Pointer(LibGio::AppLaunchContext), error : LibGLib::Error**) : LibC::Int
  fun app_info_launch_uris_async = g_app_info_launch_uris_async(this : AppInfo*, uris : Pointer(Void*), context : Pointer(LibGio::AppLaunchContext), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun app_info_launch_uris_finish = g_app_info_launch_uris_finish(this : AppInfo*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun app_info_remove_supports_type = g_app_info_remove_supports_type(this : AppInfo*, content_type : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun app_info_set_as_default_for_extension = g_app_info_set_as_default_for_extension(this : AppInfo*, extension : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun app_info_set_as_default_for_type = g_app_info_set_as_default_for_type(this : AppInfo*, content_type : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun app_info_set_as_last_used_for_type = g_app_info_set_as_last_used_for_type(this : AppInfo*, content_type : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun app_info_should_show = g_app_info_should_show(this : AppInfo*) : LibC::Int
  fun app_info_supports_files = g_app_info_supports_files(this : AppInfo*) : LibC::Int
  fun app_info_supports_uris = g_app_info_supports_uris(this : AppInfo*) : LibC::Int

  struct AsyncInitable # interface
    g_iface : LibGObject::TypeInterface
    init_async : Pointer(LibGio::AsyncInitable), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    init_finish : Pointer(LibGio::AsyncInitable), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    # Virtual function init_async
    # Virtual function init_finish
  end

  fun _g_async_initable_get_type = g_async_initable_get_type : UInt64
  fun async_initable_newv_async = g_async_initable_newv_async(object_type : UInt64, n_parameters : UInt32, parameters : Pointer(LibGObject::Parameter), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun async_initable_init_async = g_async_initable_init_async(this : AsyncInitable*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun async_initable_init_finish = g_async_initable_init_finish(this : AsyncInitable*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun async_initable_new_finish = g_async_initable_new_finish(this : AsyncInitable*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGObject::Object)

  struct AsyncResult # interface
    g_iface : LibGObject::TypeInterface
    get_user_data : Pointer(LibGio::AsyncResult) -> Pointer(Void)
    get_source_object : Pointer(LibGio::AsyncResult) -> Pointer(LibGObject::Object)
    is_tagged : Pointer(LibGio::AsyncResult), Pointer(Void) -> LibC::Int
    # Virtual function get_source_object
    # Virtual function get_user_data
    # Virtual function is_tagged
  end

  fun _g_async_result_get_type = g_async_result_get_type : UInt64
  fun async_result_get_source_object = g_async_result_get_source_object(this : AsyncResult*) : Pointer(LibGObject::Object)
  fun async_result_get_user_data = g_async_result_get_user_data(this : AsyncResult*) : Pointer(Void)
  fun async_result_is_tagged = g_async_result_is_tagged(this : AsyncResult*, source_tag : Pointer(Void)) : LibC::Int
  fun async_result_legacy_propagate_error = g_async_result_legacy_propagate_error(this : AsyncResult*, error : LibGLib::Error**) : LibC::Int

  struct Converter # interface
    g_iface : LibGObject::TypeInterface
    convert : Pointer(LibGio::Converter), Pointer(UInt8), UInt64, Pointer(UInt8), UInt64, LibGio::ConverterFlags, UInt64, UInt64, LibGLib::Error* -> LibGio::ConverterResult
    reset : Pointer(LibGio::Converter) -> Void
    # Virtual function convert
    # Virtual function reset
  end

  fun _g_converter_get_type = g_converter_get_type : UInt64
  fun converter_convert = g_converter_convert(this : Converter*, inbuf : Pointer(UInt8), inbuf_size : UInt64, outbuf : Pointer(UInt8), outbuf_size : UInt64, flags : LibGio::ConverterFlags, bytes_read : UInt64*, bytes_written : UInt64*, error : LibGLib::Error**) : LibGio::ConverterResult
  fun converter_reset = g_converter_reset(this : Converter*) : Void

  struct DBusInterface # interface
    parent_iface : LibGObject::TypeInterface
    get_info : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusInterfaceInfo)
    get_object : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusObject)
    set_object : Pointer(LibGio::DBusInterface), Pointer(LibGio::DBusObject) -> Void
    dup_object : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusObject)
    # Virtual function dup_object
    # Virtual function get_info
    # Virtual function set_object
  end

  fun _g_dbus_interface_get_type = g_dbus_interface_get_type : UInt64
  fun d_bus_interface_get_object = g_dbus_interface_dup_object(this : DBusInterface*) : Pointer(LibGio::DBusObject)
  fun d_bus_interface_get_info = g_dbus_interface_get_info(this : DBusInterface*) : Pointer(LibGio::DBusInterfaceInfo)
  fun d_bus_interface_set_object = g_dbus_interface_set_object(this : DBusInterface*, object : Pointer(LibGio::DBusObject)) : Void

  struct DBusObject # interface
    parent_iface : LibGObject::TypeInterface
    get_object_path : Pointer(LibGio::DBusObject) -> Pointer(UInt8)
    get_interfaces : Pointer(LibGio::DBusObject) -> Pointer(Void*)
    get_interface : Pointer(LibGio::DBusObject), Pointer(UInt8) -> Pointer(LibGio::DBusInterface)
    interface_added : Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    interface_removed : Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    # Signal interface-added
    # Signal interface-removed
    # Virtual function get_interface
    # Virtual function get_interfaces
    # Virtual function get_object_path
    # Virtual function interface_added
    # Virtual function interface_removed
  end

  fun _g_dbus_object_get_type = g_dbus_object_get_type : UInt64
  fun d_bus_object_get_interface = g_dbus_object_get_interface(this : DBusObject*, interface_name : Pointer(UInt8)) : Pointer(LibGio::DBusInterface)
  fun d_bus_object_get_interfaces = g_dbus_object_get_interfaces(this : DBusObject*) : Pointer(Void*)
  fun d_bus_object_get_object_path = g_dbus_object_get_object_path(this : DBusObject*) : Pointer(UInt8)

  struct DBusObjectManager # interface
    parent_iface : LibGObject::TypeInterface
    get_object_path : Pointer(LibGio::DBusObjectManager) -> Pointer(UInt8)
    get_objects : Pointer(LibGio::DBusObjectManager) -> Pointer(Void*)
    get_object : Pointer(LibGio::DBusObjectManager), Pointer(UInt8) -> Pointer(LibGio::DBusObject)
    get_interface : Pointer(LibGio::DBusObjectManager), Pointer(UInt8), Pointer(UInt8) -> Pointer(LibGio::DBusInterface)
    object_added : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject) -> Void
    object_removed : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject) -> Void
    interface_added : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    interface_removed : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    # Signal interface-added
    # Signal interface-removed
    # Signal object-added
    # Signal object-removed
    # Virtual function get_interface
    # Virtual function get_object
    # Virtual function get_object_path
    # Virtual function get_objects
    # Virtual function interface_added
    # Virtual function interface_removed
    # Virtual function object_added
    # Virtual function object_removed
  end

  fun _g_dbus_object_manager_get_type = g_dbus_object_manager_get_type : UInt64
  fun d_bus_object_manager_get_interface = g_dbus_object_manager_get_interface(this : DBusObjectManager*, object_path : Pointer(UInt8), interface_name : Pointer(UInt8)) : Pointer(LibGio::DBusInterface)
  fun d_bus_object_manager_get_object = g_dbus_object_manager_get_object(this : DBusObjectManager*, object_path : Pointer(UInt8)) : Pointer(LibGio::DBusObject)
  fun d_bus_object_manager_get_object_path = g_dbus_object_manager_get_object_path(this : DBusObjectManager*) : Pointer(UInt8)
  fun d_bus_object_manager_get_objects = g_dbus_object_manager_get_objects(this : DBusObjectManager*) : Pointer(Void*)

  struct DatagramBased # interface
    g_iface : LibGObject::TypeInterface
    receive_messages : Pointer(LibGio::DatagramBased), Pointer(LibGio::InputMessage), UInt32, Int32, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int32
    send_messages : Pointer(LibGio::DatagramBased), Pointer(LibGio::OutputMessage), UInt32, Int32, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int32
    create_source : Pointer(LibGio::DatagramBased), LibGLib::IOCondition, Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    condition_check : Pointer(LibGio::DatagramBased), LibGLib::IOCondition -> LibGLib::IOCondition
    condition_wait : Pointer(LibGio::DatagramBased), LibGLib::IOCondition, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    # Virtual function condition_check
    # Virtual function condition_wait
    # Virtual function create_source
    # Virtual function receive_messages
    # Virtual function send_messages
  end

  fun _g_datagram_based_get_type = g_datagram_based_get_type : UInt64
  fun datagram_based_condition_check = g_datagram_based_condition_check(this : DatagramBased*, condition : LibGLib::IOCondition) : LibGLib::IOCondition
  fun datagram_based_condition_wait = g_datagram_based_condition_wait(this : DatagramBased*, condition : LibGLib::IOCondition, timeout : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun datagram_based_create_source = g_datagram_based_create_source(this : DatagramBased*, condition : LibGLib::IOCondition, cancellable : Pointer(LibGio::Cancellable)) : Pointer(LibGLib::Source)
  fun datagram_based_receive_messages = g_datagram_based_receive_messages(this : DatagramBased*, messages : Pointer(LibGio::InputMessage), num_messages : UInt32, flags : Int32, timeout : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun datagram_based_send_messages = g_datagram_based_send_messages(this : DatagramBased*, messages : Pointer(LibGio::OutputMessage), num_messages : UInt32, flags : Int32, timeout : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32

  struct DesktopAppInfoLookup # interface
    g_iface : LibGObject::TypeInterface
    get_default_for_uri_scheme : Pointer(LibGio::DesktopAppInfoLookup), Pointer(UInt8) -> Pointer(LibGio::AppInfo)
    # Virtual function get_default_for_uri_scheme
  end

  fun _g_desktop_app_info_lookup_get_type = g_desktop_app_info_lookup_get_type : UInt64
  fun desktop_app_info_lookup_get_default_for_uri_scheme = g_desktop_app_info_lookup_get_default_for_uri_scheme(this : DesktopAppInfoLookup*, uri_scheme : Pointer(UInt8)) : Pointer(LibGio::AppInfo)

  struct Drive # interface
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Drive) -> Void
    disconnected : Pointer(LibGio::Drive) -> Void
    eject_button : Pointer(LibGio::Drive) -> Void
    get_name : Pointer(LibGio::Drive) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Drive) -> Pointer(LibGio::Icon)
    has_volumes : Pointer(LibGio::Drive) -> LibC::Int
    get_volumes : Pointer(LibGio::Drive) -> Pointer(Void*)
    is_media_removable : Pointer(LibGio::Drive) -> LibC::Int
    has_media : Pointer(LibGio::Drive) -> LibC::Int
    is_media_check_automatic : Pointer(LibGio::Drive) -> LibC::Int
    can_eject : Pointer(LibGio::Drive) -> LibC::Int
    can_poll_for_media : Pointer(LibGio::Drive) -> LibC::Int
    eject : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    poll_for_media : Pointer(LibGio::Drive), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    poll_for_media_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_identifier : Pointer(LibGio::Drive), Pointer(UInt8) -> Pointer(UInt8)
    enumerate_identifiers : Pointer(LibGio::Drive) -> Pointer(Pointer(UInt8))
    get_start_stop_type : Pointer(LibGio::Drive) -> LibGio::DriveStartStopType
    can_start : Pointer(LibGio::Drive) -> LibC::Int
    can_start_degraded : Pointer(LibGio::Drive) -> LibC::Int
    start : Pointer(LibGio::Drive), LibGio::DriveStartFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    start_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    can_stop : Pointer(LibGio::Drive) -> LibC::Int
    stop : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    stop_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    stop_button : Pointer(LibGio::Drive) -> Void
    eject_with_operation : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_sort_key : Pointer(LibGio::Drive) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Drive) -> Pointer(LibGio::Icon)
    is_removable : Pointer(LibGio::Drive) -> LibC::Int
    # Signal changed
    # Signal disconnected
    # Signal eject-button
    # Signal stop-button
    # Virtual function can_eject
    # Virtual function can_poll_for_media
    # Virtual function can_start
    # Virtual function can_start_degraded
    # Virtual function can_stop
    # Virtual function changed
    # Virtual function disconnected
    # Virtual function eject
    # Virtual function eject_button
    # Virtual function eject_finish
    # Virtual function eject_with_operation
    # Virtual function eject_with_operation_finish
    # Virtual function enumerate_identifiers
    # Virtual function get_icon
    # Virtual function get_identifier
    # Virtual function get_name
    # Virtual function get_sort_key
    # Virtual function get_start_stop_type
    # Virtual function get_symbolic_icon
    # Virtual function get_volumes
    # Virtual function has_media
    # Virtual function has_volumes
    # Virtual function is_media_check_automatic
    # Virtual function is_media_removable
    # Virtual function is_removable
    # Virtual function poll_for_media
    # Virtual function poll_for_media_finish
    # Virtual function start
    # Virtual function start_finish
    # Virtual function stop
    # Virtual function stop_button
    # Virtual function stop_finish
  end

  fun _g_drive_get_type = g_drive_get_type : UInt64
  fun drive_can_eject = g_drive_can_eject(this : Drive*) : LibC::Int
  fun drive_can_poll_for_media = g_drive_can_poll_for_media(this : Drive*) : LibC::Int
  fun drive_can_start = g_drive_can_start(this : Drive*) : LibC::Int
  fun drive_can_start_degraded = g_drive_can_start_degraded(this : Drive*) : LibC::Int
  fun drive_can_stop = g_drive_can_stop(this : Drive*) : LibC::Int
  fun drive_eject = g_drive_eject(this : Drive*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun drive_eject_finish = g_drive_eject_finish(this : Drive*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun drive_eject_with_operation = g_drive_eject_with_operation(this : Drive*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun drive_eject_with_operation_finish = g_drive_eject_with_operation_finish(this : Drive*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun drive_enumerate_identifiers = g_drive_enumerate_identifiers(this : Drive*) : Pointer(Pointer(UInt8))
  fun drive_get_icon = g_drive_get_icon(this : Drive*) : Pointer(LibGio::Icon)
  fun drive_get_identifier = g_drive_get_identifier(this : Drive*, kind : Pointer(UInt8)) : Pointer(UInt8)
  fun drive_get_name = g_drive_get_name(this : Drive*) : Pointer(UInt8)
  fun drive_get_sort_key = g_drive_get_sort_key(this : Drive*) : Pointer(UInt8)
  fun drive_get_start_stop_type = g_drive_get_start_stop_type(this : Drive*) : LibGio::DriveStartStopType
  fun drive_get_symbolic_icon = g_drive_get_symbolic_icon(this : Drive*) : Pointer(LibGio::Icon)
  fun drive_get_volumes = g_drive_get_volumes(this : Drive*) : Pointer(Void*)
  fun drive_has_media = g_drive_has_media(this : Drive*) : LibC::Int
  fun drive_has_volumes = g_drive_has_volumes(this : Drive*) : LibC::Int
  fun drive_is_media_check_automatic = g_drive_is_media_check_automatic(this : Drive*) : LibC::Int
  fun drive_is_media_removable = g_drive_is_media_removable(this : Drive*) : LibC::Int
  fun drive_is_removable = g_drive_is_removable(this : Drive*) : LibC::Int
  fun drive_poll_for_media = g_drive_poll_for_media(this : Drive*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun drive_poll_for_media_finish = g_drive_poll_for_media_finish(this : Drive*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun drive_start = g_drive_start(this : Drive*, flags : LibGio::DriveStartFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun drive_start_finish = g_drive_start_finish(this : Drive*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun drive_stop = g_drive_stop(this : Drive*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun drive_stop_finish = g_drive_stop_finish(this : Drive*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int

  struct DtlsClientConnection # interface
    g_iface : LibGObject::TypeInterface
    # Requires DatagramBased
    # Requires DtlsConnection
    # Property accepted-cas : Pointer(Void*)
    # Property server-identity : LibGio::SocketConnectable
    # Property validation-flags : LibGio::TlsCertificateFlags
  end

  fun _g_dtls_client_connection_get_type = g_dtls_client_connection_get_type : UInt64
  fun dtls_client_connection_new = g_dtls_client_connection_new(base_socket : Pointer(LibGio::DatagramBased), server_identity : Pointer(LibGio::SocketConnectable), error : LibGLib::Error**) : Pointer(LibGio::DtlsClientConnection)
  fun dtls_client_connection_get_accepted_cas = g_dtls_client_connection_get_accepted_cas(this : DtlsClientConnection*) : Pointer(Void*)
  fun dtls_client_connection_get_server_identity = g_dtls_client_connection_get_server_identity(this : DtlsClientConnection*) : Pointer(LibGio::SocketConnectable)
  fun dtls_client_connection_get_validation_flags = g_dtls_client_connection_get_validation_flags(this : DtlsClientConnection*) : LibGio::TlsCertificateFlags
  fun dtls_client_connection_set_server_identity = g_dtls_client_connection_set_server_identity(this : DtlsClientConnection*, identity : Pointer(LibGio::SocketConnectable)) : Void
  fun dtls_client_connection_set_validation_flags = g_dtls_client_connection_set_validation_flags(this : DtlsClientConnection*, flags : LibGio::TlsCertificateFlags) : Void

  struct DtlsConnection # interface
    g_iface : LibGObject::TypeInterface
    accept_certificate : Pointer(LibGio::DtlsConnection), Pointer(LibGio::TlsCertificate), LibGio::TlsCertificateFlags -> LibC::Int
    handshake : Pointer(LibGio::DtlsConnection), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    handshake_async : Pointer(LibGio::DtlsConnection), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    handshake_finish : Pointer(LibGio::DtlsConnection), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    shutdown : Pointer(LibGio::DtlsConnection), LibC::Int, LibC::Int, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    shutdown_async : Pointer(LibGio::DtlsConnection), LibC::Int, LibC::Int, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    shutdown_finish : Pointer(LibGio::DtlsConnection), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    set_advertised_protocols : Pointer(LibGio::DtlsConnection), Pointer(Pointer(UInt8)) -> Void
    get_negotiated_protocol : Pointer(LibGio::DtlsConnection) -> Pointer(UInt8)
    # Requires DatagramBased
    # Signal accept-certificate
    # Virtual function accept_certificate
    # Virtual function get_negotiated_protocol
    # Virtual function handshake
    # Virtual function handshake_async
    # Virtual function handshake_finish
    # Virtual function set_advertised_protocols
    # Virtual function shutdown
    # Virtual function shutdown_async
    # Virtual function shutdown_finish
    # Property advertised-protocols : Pointer(Pointer(UInt8))
    # Property base-socket : LibGio::DatagramBased
    # Property certificate : LibGio::TlsCertificate
    # Property database : LibGio::TlsDatabase
    # Property interaction : LibGio::TlsInteraction
    # Property negotiated-protocol : Pointer(UInt8)
    # Property peer-certificate : LibGio::TlsCertificate
    # Property peer-certificate-errors : LibGio::TlsCertificateFlags
    # Property rehandshake-mode : LibGio::TlsRehandshakeMode
    # Property require-close-notify : LibC::Int
  end

  fun _g_dtls_connection_get_type = g_dtls_connection_get_type : UInt64
  fun dtls_connection_close = g_dtls_connection_close(this : DtlsConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun dtls_connection_close_async = g_dtls_connection_close_async(this : DtlsConnection*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun dtls_connection_close_finish = g_dtls_connection_close_finish(this : DtlsConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun dtls_connection_emit_accept_certificate = g_dtls_connection_emit_accept_certificate(this : DtlsConnection*, peer_cert : Pointer(LibGio::TlsCertificate), errors : LibGio::TlsCertificateFlags) : LibC::Int
  fun dtls_connection_get_certificate = g_dtls_connection_get_certificate(this : DtlsConnection*) : Pointer(LibGio::TlsCertificate)
  fun dtls_connection_get_database = g_dtls_connection_get_database(this : DtlsConnection*) : Pointer(LibGio::TlsDatabase)
  fun dtls_connection_get_interaction = g_dtls_connection_get_interaction(this : DtlsConnection*) : Pointer(LibGio::TlsInteraction)
  fun dtls_connection_get_negotiated_protocol = g_dtls_connection_get_negotiated_protocol(this : DtlsConnection*) : Pointer(UInt8)
  fun dtls_connection_get_peer_certificate = g_dtls_connection_get_peer_certificate(this : DtlsConnection*) : Pointer(LibGio::TlsCertificate)
  fun dtls_connection_get_peer_certificate_errors = g_dtls_connection_get_peer_certificate_errors(this : DtlsConnection*) : LibGio::TlsCertificateFlags
  fun dtls_connection_get_rehandshake_mode = g_dtls_connection_get_rehandshake_mode(this : DtlsConnection*) : LibGio::TlsRehandshakeMode
  fun dtls_connection_get_require_close_notify = g_dtls_connection_get_require_close_notify(this : DtlsConnection*) : LibC::Int
  fun dtls_connection_handshake = g_dtls_connection_handshake(this : DtlsConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun dtls_connection_handshake_async = g_dtls_connection_handshake_async(this : DtlsConnection*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun dtls_connection_handshake_finish = g_dtls_connection_handshake_finish(this : DtlsConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun dtls_connection_set_advertised_protocols = g_dtls_connection_set_advertised_protocols(this : DtlsConnection*, protocols : Pointer(Pointer(UInt8))) : Void
  fun dtls_connection_set_certificate = g_dtls_connection_set_certificate(this : DtlsConnection*, certificate : Pointer(LibGio::TlsCertificate)) : Void
  fun dtls_connection_set_database = g_dtls_connection_set_database(this : DtlsConnection*, database : Pointer(LibGio::TlsDatabase)) : Void
  fun dtls_connection_set_interaction = g_dtls_connection_set_interaction(this : DtlsConnection*, interaction : Pointer(LibGio::TlsInteraction)) : Void
  fun dtls_connection_set_rehandshake_mode = g_dtls_connection_set_rehandshake_mode(this : DtlsConnection*, mode : LibGio::TlsRehandshakeMode) : Void
  fun dtls_connection_set_require_close_notify = g_dtls_connection_set_require_close_notify(this : DtlsConnection*, require_close_notify : LibC::Int) : Void
  fun dtls_connection_shutdown = g_dtls_connection_shutdown(this : DtlsConnection*, shutdown_read : LibC::Int, shutdown_write : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun dtls_connection_shutdown_async = g_dtls_connection_shutdown_async(this : DtlsConnection*, shutdown_read : LibC::Int, shutdown_write : LibC::Int, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun dtls_connection_shutdown_finish = g_dtls_connection_shutdown_finish(this : DtlsConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int

  struct DtlsServerConnection # interface
    g_iface : LibGObject::TypeInterface
    # Requires DatagramBased
    # Requires DtlsConnection
    # Property authentication-mode : LibGio::TlsAuthenticationMode
  end

  fun _g_dtls_server_connection_get_type = g_dtls_server_connection_get_type : UInt64
  fun dtls_server_connection_new = g_dtls_server_connection_new(base_socket : Pointer(LibGio::DatagramBased), certificate : Pointer(LibGio::TlsCertificate), error : LibGLib::Error**) : Pointer(LibGio::DtlsServerConnection)

  struct File # interface
    g_iface : LibGObject::TypeInterface
    dup : Pointer(LibGio::File) -> Pointer(LibGio::File)
    hash : Pointer(LibGio::File) -> UInt32
    equal : Pointer(LibGio::File), Pointer(LibGio::File) -> LibC::Int
    is_native : Pointer(LibGio::File) -> LibC::Int
    has_uri_scheme : Pointer(LibGio::File), Pointer(UInt8) -> LibC::Int
    get_uri_scheme : Pointer(LibGio::File) -> Pointer(UInt8)
    get_basename : Pointer(LibGio::File) -> Pointer(UInt8)
    get_path : Pointer(LibGio::File) -> Pointer(UInt8)
    get_uri : Pointer(LibGio::File) -> Pointer(UInt8)
    get_parse_name : Pointer(LibGio::File) -> Pointer(UInt8)
    get_parent : Pointer(LibGio::File) -> Pointer(LibGio::File)
    prefix_matches : Pointer(LibGio::File), Pointer(LibGio::File) -> LibC::Int
    get_relative_path : Pointer(LibGio::File), Pointer(LibGio::File) -> Pointer(UInt8)
    resolve_relative_path : Pointer(LibGio::File), Pointer(UInt8) -> Pointer(LibGio::File)
    get_child_for_display_name : Pointer(LibGio::File), Pointer(UInt8), LibGLib::Error* -> Pointer(LibGio::File)
    enumerate_children : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileEnumerator)
    enumerate_children_async : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    enumerate_children_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileEnumerator)
    query_info : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_info_async : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_info_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_filesystem_info : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_filesystem_info_async : Pointer(LibGio::File), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_filesystem_info_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    find_enclosing_mount : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::Mount)
    find_enclosing_mount_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    find_enclosing_mount_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::Mount)
    set_display_name : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::File)
    set_display_name_async : Pointer(LibGio::File), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    set_display_name_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::File)
    query_settable_attributes : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileAttributeInfoList)
    _query_settable_attributes_async : Pointer(Void)
    _query_settable_attributes_finish : Pointer(Void)
    query_writable_namespaces : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileAttributeInfoList)
    _query_writable_namespaces_async : Pointer(Void)
    _query_writable_namespaces_finish : Pointer(Void)
    set_attribute : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileAttributeType, Pointer(Void), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    set_attributes_from_info : Pointer(LibGio::File), Pointer(LibGio::FileInfo), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    set_attributes_async : Pointer(LibGio::File), Pointer(LibGio::FileInfo), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    set_attributes_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), Pointer(LibGio::FileInfo), LibGLib::Error* -> LibC::Int
    read_fn : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInputStream)
    read_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    read_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInputStream)
    append_to : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    append_to_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    append_to_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    create : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    create_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    create_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    replace : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    replace_async : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    replace_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    delete_file : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    delete_file_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    delete_file_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    trash : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    trash_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    trash_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    make_directory : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    make_directory_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    make_directory_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    make_symbolic_link : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    _make_symbolic_link_async : Pointer(Void)
    _make_symbolic_link_finish : Pointer(Void)
    copy : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGLib::Error* -> LibC::Int
    copy_async : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Int32, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    copy_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    move : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGLib::Error* -> LibC::Int
    _move_async : Pointer(Void)
    _move_finish : Pointer(Void)
    mount_mountable : Pointer(LibGio::File), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::File)
    unmount_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    mount_enclosing_volume : Pointer(LibGio::File), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_enclosing_volume_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    monitor_dir : Pointer(LibGio::File), LibGio::FileMonitorFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileMonitor)
    monitor_file : Pointer(LibGio::File), LibGio::FileMonitorFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileMonitor)
    open_readwrite : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    open_readwrite_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    open_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    create_readwrite : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    create_readwrite_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    create_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    replace_readwrite : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    replace_readwrite_async : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    replace_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    start_mountable : Pointer(LibGio::File), LibGio::DriveStartFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    start_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    stop_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    stop_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    supports_thread_contexts : LibC::Int
    unmount_mountable_with_operation : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_mountable_with_operation_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_mountable_with_operation : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_mountable_with_operation_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    poll_mountable : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    poll_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    measure_disk_usage : Pointer(Void)
    measure_disk_usage_async : Pointer(Void)
    measure_disk_usage_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), UInt64, UInt64, UInt64, LibGLib::Error* -> LibC::Int
    # Virtual function append_to
    # Virtual function append_to_async
    # Virtual function append_to_finish
    # Virtual function copy
    # Virtual function copy_async
    # Virtual function copy_finish
    # Virtual function create
    # Virtual function create_async
    # Virtual function create_finish
    # Virtual function create_readwrite
    # Virtual function create_readwrite_async
    # Virtual function create_readwrite_finish
    # Virtual function delete_file
    # Virtual function delete_file_async
    # Virtual function delete_file_finish
    # Virtual function dup
    # Virtual function eject_mountable
    # Virtual function eject_mountable_finish
    # Virtual function eject_mountable_with_operation
    # Virtual function eject_mountable_with_operation_finish
    # Virtual function enumerate_children
    # Virtual function enumerate_children_async
    # Virtual function enumerate_children_finish
    # Virtual function equal
    # Virtual function find_enclosing_mount
    # Virtual function find_enclosing_mount_async
    # Virtual function find_enclosing_mount_finish
    # Virtual function get_basename
    # Virtual function get_child_for_display_name
    # Virtual function get_parent
    # Virtual function get_parse_name
    # Virtual function get_path
    # Virtual function get_relative_path
    # Virtual function get_uri
    # Virtual function get_uri_scheme
    # Virtual function has_uri_scheme
    # Virtual function hash
    # Virtual function is_native
    # Virtual function make_directory
    # Virtual function make_directory_async
    # Virtual function make_directory_finish
    # Virtual function make_symbolic_link
    # Virtual function measure_disk_usage_finish
    # Virtual function monitor_dir
    # Virtual function monitor_file
    # Virtual function mount_enclosing_volume
    # Virtual function mount_enclosing_volume_finish
    # Virtual function mount_mountable
    # Virtual function mount_mountable_finish
    # Virtual function move
    # Virtual function open_readwrite
    # Virtual function open_readwrite_async
    # Virtual function open_readwrite_finish
    # Virtual function poll_mountable
    # Virtual function poll_mountable_finish
    # Virtual function prefix_matches
    # Virtual function query_filesystem_info
    # Virtual function query_filesystem_info_async
    # Virtual function query_filesystem_info_finish
    # Virtual function query_info
    # Virtual function query_info_async
    # Virtual function query_info_finish
    # Virtual function query_settable_attributes
    # Virtual function query_writable_namespaces
    # Virtual function read_async
    # Virtual function read_finish
    # Virtual function read_fn
    # Virtual function replace
    # Virtual function replace_async
    # Virtual function replace_finish
    # Virtual function replace_readwrite
    # Virtual function replace_readwrite_async
    # Virtual function replace_readwrite_finish
    # Virtual function resolve_relative_path
    # Virtual function set_attribute
    # Virtual function set_attributes_async
    # Virtual function set_attributes_finish
    # Virtual function set_attributes_from_info
    # Virtual function set_display_name
    # Virtual function set_display_name_async
    # Virtual function set_display_name_finish
    # Virtual function start_mountable
    # Virtual function start_mountable_finish
    # Virtual function stop_mountable
    # Virtual function stop_mountable_finish
    # Virtual function trash
    # Virtual function trash_async
    # Virtual function trash_finish
    # Virtual function unmount_mountable
    # Virtual function unmount_mountable_finish
    # Virtual function unmount_mountable_with_operation
    # Virtual function unmount_mountable_with_operation_finish
  end

  fun _g_file_get_type = g_file_get_type : UInt64
  fun file_new_for_commandline_arg = g_file_new_for_commandline_arg(arg : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_commandline_arg_and_cwd = g_file_new_for_commandline_arg_and_cwd(arg : Pointer(UInt8), cwd : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_path = g_file_new_for_path(path : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_uri = g_file_new_for_uri(uri : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_tmp = g_file_new_tmp(tmpl : Pointer(UInt8), iostream : Pointer(LibGio::FileIOStream)*, error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_parse_name = g_file_parse_name(parse_name : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_append_to = g_file_append_to(this : File*, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_append_to_async = g_file_append_to_async(this : File*, flags : LibGio::FileCreateFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_append_to_finish = g_file_append_to_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_copy = g_file_copy(this : File*, destination : Pointer(LibGio::File), flags : LibGio::FileCopyFlags, cancellable : Pointer(LibGio::Cancellable), progress_callback : LibGio::FileProgressCallback, progress_callback_data : Pointer(Void), error : LibGLib::Error**) : LibC::Int
  fun file_copy_async = g_file_copy_async(this : File*, destination : Pointer(LibGio::File), flags : LibGio::FileCopyFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), progress_callback : LibGio::FileProgressCallback, progress_callback_data : Pointer(Void), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_copy_attributes = g_file_copy_attributes(this : File*, destination : Pointer(LibGio::File), flags : LibGio::FileCopyFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_copy_finish = g_file_copy_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_create = g_file_create(this : File*, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_create_async = g_file_create_async(this : File*, flags : LibGio::FileCreateFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_create_finish = g_file_create_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_create_readwrite = g_file_create_readwrite(this : File*, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_create_readwrite_async = g_file_create_readwrite_async(this : File*, flags : LibGio::FileCreateFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_create_readwrite_finish = g_file_create_readwrite_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_delete = g_file_delete(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_delete_async = g_file_delete_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_delete_finish = g_file_delete_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_dup = g_file_dup(this : File*) : Pointer(LibGio::File)
  fun file_eject_mountable = g_file_eject_mountable(this : File*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_eject_mountable_finish = g_file_eject_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_eject_mountable_with_operation = g_file_eject_mountable_with_operation(this : File*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_eject_mountable_with_operation_finish = g_file_eject_mountable_with_operation_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_enumerate_children = g_file_enumerate_children(this : File*, attributes : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileEnumerator)
  fun file_enumerate_children_async = g_file_enumerate_children_async(this : File*, attributes : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_enumerate_children_finish = g_file_enumerate_children_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileEnumerator)
  fun file_equal = g_file_equal(this : File*, file2 : Pointer(LibGio::File)) : LibC::Int
  fun file_find_enclosing_mount = g_file_find_enclosing_mount(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::Mount)
  fun file_find_enclosing_mount_async = g_file_find_enclosing_mount_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_find_enclosing_mount_finish = g_file_find_enclosing_mount_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::Mount)
  fun file_get_basename = g_file_get_basename(this : File*) : Pointer(UInt8)
  fun file_get_child = g_file_get_child(this : File*, name : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_get_child_for_display_name = g_file_get_child_for_display_name(this : File*, display_name : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_get_parent = g_file_get_parent(this : File*) : Pointer(LibGio::File)
  fun file_get_parse_name = g_file_get_parse_name(this : File*) : Pointer(UInt8)
  fun file_get_path = g_file_get_path(this : File*) : Pointer(UInt8)
  fun file_get_relative_path = g_file_get_relative_path(this : File*, descendant : Pointer(LibGio::File)) : Pointer(UInt8)
  fun file_get_uri = g_file_get_uri(this : File*) : Pointer(UInt8)
  fun file_get_uri_scheme = g_file_get_uri_scheme(this : File*) : Pointer(UInt8)
  fun file_has_parent = g_file_has_parent(this : File*, parent : Pointer(LibGio::File)) : LibC::Int
  fun file_has_prefix = g_file_has_prefix(this : File*, prefix : Pointer(LibGio::File)) : LibC::Int
  fun file_has_uri_scheme = g_file_has_uri_scheme(this : File*, uri_scheme : Pointer(UInt8)) : LibC::Int
  fun file_hash = g_file_hash(this : File*) : UInt32
  fun file_is_native = g_file_is_native(this : File*) : LibC::Int
  fun file_load_bytes = g_file_load_bytes(this : File*, cancellable : Pointer(LibGio::Cancellable), etag_out : Pointer(UInt8)*, error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun file_load_bytes_async = g_file_load_bytes_async(this : File*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_load_bytes_finish = g_file_load_bytes_finish(this : File*, result : Pointer(LibGio::AsyncResult), etag_out : Pointer(UInt8)*, error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun file_load_contents = g_file_load_contents(this : File*, cancellable : Pointer(LibGio::Cancellable), contents : Pointer(UInt8)*, length : UInt64*, etag_out : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun file_load_contents_async = g_file_load_contents_async(this : File*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_load_contents_finish = g_file_load_contents_finish(this : File*, res : Pointer(LibGio::AsyncResult), contents : Pointer(UInt8)*, length : UInt64*, etag_out : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun file_load_partial_contents_finish = g_file_load_partial_contents_finish(this : File*, res : Pointer(LibGio::AsyncResult), contents : Pointer(UInt8)*, length : UInt64*, etag_out : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun file_make_directory = g_file_make_directory(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_make_directory_async = g_file_make_directory_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_make_directory_finish = g_file_make_directory_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_make_directory_with_parents = g_file_make_directory_with_parents(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_make_symbolic_link = g_file_make_symbolic_link(this : File*, symlink_value : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_measure_disk_usage_finish = g_file_measure_disk_usage_finish(this : File*, result : Pointer(LibGio::AsyncResult), disk_usage : UInt64*, num_dirs : UInt64*, num_files : UInt64*, error : LibGLib::Error**) : LibC::Int
  fun file_monitor = g_file_monitor(this : File*, flags : LibGio::FileMonitorFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileMonitor)
  fun file_monitor_directory = g_file_monitor_directory(this : File*, flags : LibGio::FileMonitorFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileMonitor)
  fun file_monitor_file = g_file_monitor_file(this : File*, flags : LibGio::FileMonitorFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileMonitor)
  fun file_mount_enclosing_volume = g_file_mount_enclosing_volume(this : File*, flags : LibGio::MountMountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_mount_enclosing_volume_finish = g_file_mount_enclosing_volume_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_mount_mountable = g_file_mount_mountable(this : File*, flags : LibGio::MountMountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_mount_mountable_finish = g_file_mount_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_move = g_file_move(this : File*, destination : Pointer(LibGio::File), flags : LibGio::FileCopyFlags, cancellable : Pointer(LibGio::Cancellable), progress_callback : LibGio::FileProgressCallback, progress_callback_data : Pointer(Void), error : LibGLib::Error**) : LibC::Int
  fun file_open_readwrite = g_file_open_readwrite(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_open_readwrite_async = g_file_open_readwrite_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_open_readwrite_finish = g_file_open_readwrite_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_peek_path = g_file_peek_path(this : File*) : Pointer(UInt8)
  fun file_poll_mountable = g_file_poll_mountable(this : File*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_poll_mountable_finish = g_file_poll_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_query_default_handler = g_file_query_default_handler(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::AppInfo)
  fun file_query_default_handler_async = g_file_query_default_handler_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_query_default_handler_finish = g_file_query_default_handler_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::AppInfo)
  fun file_query_exists = g_file_query_exists(this : File*, cancellable : Pointer(LibGio::Cancellable)) : LibC::Int
  fun file_query_file_type = g_file_query_file_type(this : File*, flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable)) : LibGio::FileType
  fun file_query_filesystem_info = g_file_query_filesystem_info(this : File*, attributes : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_query_filesystem_info_async = g_file_query_filesystem_info_async(this : File*, attributes : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_query_filesystem_info_finish = g_file_query_filesystem_info_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_query_info = g_file_query_info(this : File*, attributes : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_query_info_async = g_file_query_info_async(this : File*, attributes : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_query_info_finish = g_file_query_info_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_query_settable_attributes = g_file_query_settable_attributes(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileAttributeInfoList)
  fun file_query_writable_namespaces = g_file_query_writable_namespaces(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileAttributeInfoList)
  fun file_read = g_file_read(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInputStream)
  fun file_read_async = g_file_read_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_read_finish = g_file_read_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInputStream)
  fun file_replace = g_file_replace(this : File*, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_replace_async = g_file_replace_async(this : File*, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_replace_contents = g_file_replace_contents(this : File*, contents : Pointer(UInt8), length : UInt64, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, new_etag : Pointer(UInt8)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_replace_contents_async = g_file_replace_contents_async(this : File*, contents : Pointer(UInt8), length : UInt64, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_replace_contents_bytes_async = g_file_replace_contents_bytes_async(this : File*, contents : Pointer(LibGLib::Bytes), etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_replace_contents_finish = g_file_replace_contents_finish(this : File*, res : Pointer(LibGio::AsyncResult), new_etag : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun file_replace_finish = g_file_replace_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileOutputStream)
  fun file_replace_readwrite = g_file_replace_readwrite(this : File*, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_replace_readwrite_async = g_file_replace_readwrite_async(this : File*, etag : Pointer(UInt8), make_backup : LibC::Int, flags : LibGio::FileCreateFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_replace_readwrite_finish = g_file_replace_readwrite_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileIOStream)
  fun file_resolve_relative_path = g_file_resolve_relative_path(this : File*, relative_path : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_set_attribute = g_file_set_attribute(this : File*, attribute : Pointer(UInt8), type : LibGio::FileAttributeType, value_p : Pointer(Void), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_byte_string = g_file_set_attribute_byte_string(this : File*, attribute : Pointer(UInt8), value : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_int32 = g_file_set_attribute_int32(this : File*, attribute : Pointer(UInt8), value : Int32, flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_int64 = g_file_set_attribute_int64(this : File*, attribute : Pointer(UInt8), value : Int64, flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_string = g_file_set_attribute_string(this : File*, attribute : Pointer(UInt8), value : Pointer(UInt8), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_uint32 = g_file_set_attribute_uint32(this : File*, attribute : Pointer(UInt8), value : UInt32, flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attribute_uint64 = g_file_set_attribute_uint64(this : File*, attribute : Pointer(UInt8), value : UInt64, flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_attributes_async = g_file_set_attributes_async(this : File*, info : Pointer(LibGio::FileInfo), flags : LibGio::FileQueryInfoFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_set_attributes_finish = g_file_set_attributes_finish(this : File*, result : Pointer(LibGio::AsyncResult), info : Pointer(LibGio::FileInfo)*, error : LibGLib::Error**) : LibC::Int
  fun file_set_attributes_from_info = g_file_set_attributes_from_info(this : File*, info : Pointer(LibGio::FileInfo), flags : LibGio::FileQueryInfoFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_set_display_name = g_file_set_display_name(this : File*, display_name : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_set_display_name_async = g_file_set_display_name_async(this : File*, display_name : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_set_display_name_finish = g_file_set_display_name_finish(this : File*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_start_mountable = g_file_start_mountable(this : File*, flags : LibGio::DriveStartFlags, start_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_start_mountable_finish = g_file_start_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_stop_mountable = g_file_stop_mountable(this : File*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_stop_mountable_finish = g_file_stop_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_supports_thread_contexts = g_file_supports_thread_contexts(this : File*) : LibC::Int
  fun file_trash = g_file_trash(this : File*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_trash_async = g_file_trash_async(this : File*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_trash_finish = g_file_trash_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_unmount_mountable = g_file_unmount_mountable(this : File*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_unmount_mountable_finish = g_file_unmount_mountable_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_unmount_mountable_with_operation = g_file_unmount_mountable_with_operation(this : File*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_unmount_mountable_with_operation_finish = g_file_unmount_mountable_with_operation_finish(this : File*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int

  struct FileDescriptorBased # interface
    g_iface : LibGObject::TypeInterface
    get_fd : Pointer(LibGio::FileDescriptorBased) -> Int32
    # Virtual function get_fd
  end

  fun _g_file_descriptor_based_get_type = g_file_descriptor_based_get_type : UInt64
  fun file_descriptor_based_get_fd = g_file_descriptor_based_get_fd(this : FileDescriptorBased*) : Int32

  struct Icon # interface
    g_iface : LibGObject::TypeInterface
    hash : Pointer(LibGio::Icon) -> UInt32
    equal : Pointer(LibGio::Icon), Pointer(LibGio::Icon) -> LibC::Int
    to_tokens : Pointer(Void)
    from_tokens : Pointer(Void)
    serialize : Pointer(LibGio::Icon) -> Pointer(LibGLib::Variant)
    # Virtual function equal
    # Virtual function hash
    # Virtual function serialize
  end

  fun _g_icon_get_type = g_icon_get_type : UInt64
  fun icon_deserialize = g_icon_deserialize(value : Pointer(LibGLib::Variant)) : Pointer(LibGio::Icon)
  fun icon_hash = g_icon_hash(icon : Pointer(Void)) : UInt32
  fun icon_new_for_string = g_icon_new_for_string(str : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::Icon)
  fun icon_equal = g_icon_equal(this : Icon*, icon2 : Pointer(LibGio::Icon)) : LibC::Int
  fun icon_serialize = g_icon_serialize(this : Icon*) : Pointer(LibGLib::Variant)
  fun icon_to_string = g_icon_to_string(this : Icon*) : Pointer(UInt8)

  struct Initable # interface
    g_iface : LibGObject::TypeInterface
    init : Pointer(LibGio::Initable), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    # Virtual function init
  end

  fun _g_initable_get_type = g_initable_get_type : UInt64
  fun initable_newv = g_initable_newv(object_type : UInt64, n_parameters : UInt32, parameters : Pointer(LibGObject::Parameter), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGObject::Object)
  fun initable_init = g_initable_init(this : Initable*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int

  struct ListModel # interface
    g_iface : LibGObject::TypeInterface
    get_item_type : Pointer(LibGio::ListModel) -> UInt64
    get_n_items : Pointer(LibGio::ListModel) -> UInt32
    get_item : Pointer(LibGio::ListModel), UInt32 -> Pointer(LibGObject::Object)
    # Signal items-changed
    # Virtual function get_item
    # Virtual function get_item_type
    # Virtual function get_n_items
  end

  fun _g_list_model_get_type = g_list_model_get_type : UInt64
  fun list_model_get_item_type = g_list_model_get_item_type(this : ListModel*) : UInt64
  fun list_model_get_n_items = g_list_model_get_n_items(this : ListModel*) : UInt32
  fun list_model_get_item = g_list_model_get_object(this : ListModel*, position : UInt32) : Pointer(LibGObject::Object)
  fun list_model_items_changed = g_list_model_items_changed(this : ListModel*, position : UInt32, removed : UInt32, added : UInt32) : Void

  struct LoadableIcon # interface
    g_iface : LibGObject::TypeInterface
    load : Pointer(LibGio::LoadableIcon), Int32, Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::InputStream)
    load_async : Pointer(LibGio::LoadableIcon), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    load_finish : Pointer(LibGio::LoadableIcon), Pointer(LibGio::AsyncResult), Pointer(UInt8), LibGLib::Error* -> Pointer(LibGio::InputStream)
    # Requires Icon
    # Virtual function load
    # Virtual function load_async
    # Virtual function load_finish
  end

  fun _g_loadable_icon_get_type = g_loadable_icon_get_type : UInt64
  fun loadable_icon_load = g_loadable_icon_load(this : LoadableIcon*, size : Int32, type : Pointer(UInt8)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::InputStream)
  fun loadable_icon_load_async = g_loadable_icon_load_async(this : LoadableIcon*, size : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun loadable_icon_load_finish = g_loadable_icon_load_finish(this : LoadableIcon*, res : Pointer(LibGio::AsyncResult), type : Pointer(UInt8)*, error : LibGLib::Error**) : Pointer(LibGio::InputStream)

  struct MemoryMonitor # interface
    g_iface : LibGObject::TypeInterface
    low_memory_warning : Pointer(LibGio::MemoryMonitor), LibGio::MemoryMonitorWarningLevel -> Void
    # Requires Initable
    # Signal low-memory-warning
    # Virtual function low_memory_warning
  end

  fun _g_memory_monitor_get_type = g_memory_monitor_get_type : UInt64
  fun memory_monitor_dup_default = g_memory_monitor_dup_default : Pointer(LibGio::MemoryMonitor)

  struct Mount # interface
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Mount) -> Void
    unmounted : Pointer(LibGio::Mount) -> Void
    get_root : Pointer(LibGio::Mount) -> Pointer(LibGio::File)
    get_name : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Mount) -> Pointer(LibGio::Icon)
    get_uuid : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_volume : Pointer(LibGio::Mount) -> Pointer(LibGio::Volume)
    get_drive : Pointer(LibGio::Mount) -> Pointer(LibGio::Drive)
    can_unmount : Pointer(LibGio::Mount) -> LibC::Int
    can_eject : Pointer(LibGio::Mount) -> LibC::Int
    unmount : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    remount : Pointer(LibGio::Mount), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    remount_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    guess_content_type : Pointer(LibGio::Mount), LibC::Int, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    guess_content_type_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Pointer(UInt8))
    guess_content_type_sync : Pointer(LibGio::Mount), LibC::Int, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Pointer(UInt8))
    pre_unmount : Pointer(LibGio::Mount) -> Void
    unmount_with_operation : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_with_operation_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_with_operation : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_default_location : Pointer(LibGio::Mount) -> Pointer(LibGio::File)
    get_sort_key : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Mount) -> Pointer(LibGio::Icon)
    # Signal changed
    # Signal pre-unmount
    # Signal unmounted
    # Virtual function can_eject
    # Virtual function can_unmount
    # Virtual function changed
    # Virtual function eject
    # Virtual function eject_finish
    # Virtual function eject_with_operation
    # Virtual function eject_with_operation_finish
    # Virtual function get_default_location
    # Virtual function get_drive
    # Virtual function get_icon
    # Virtual function get_name
    # Virtual function get_root
    # Virtual function get_sort_key
    # Virtual function get_symbolic_icon
    # Virtual function get_uuid
    # Virtual function get_volume
    # Virtual function guess_content_type
    # Virtual function guess_content_type_finish
    # Virtual function guess_content_type_sync
    # Virtual function pre_unmount
    # Virtual function remount
    # Virtual function remount_finish
    # Virtual function unmount
    # Virtual function unmount_finish
    # Virtual function unmount_with_operation
    # Virtual function unmount_with_operation_finish
    # Virtual function unmounted
  end

  fun _g_mount_get_type = g_mount_get_type : UInt64
  fun mount_can_eject = g_mount_can_eject(this : Mount*) : LibC::Int
  fun mount_can_unmount = g_mount_can_unmount(this : Mount*) : LibC::Int
  fun mount_eject = g_mount_eject(this : Mount*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_eject_finish = g_mount_eject_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun mount_eject_with_operation = g_mount_eject_with_operation(this : Mount*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_eject_with_operation_finish = g_mount_eject_with_operation_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun mount_get_default_location = g_mount_get_default_location(this : Mount*) : Pointer(LibGio::File)
  fun mount_get_drive = g_mount_get_drive(this : Mount*) : Pointer(LibGio::Drive)
  fun mount_get_icon = g_mount_get_icon(this : Mount*) : Pointer(LibGio::Icon)
  fun mount_get_name = g_mount_get_name(this : Mount*) : Pointer(UInt8)
  fun mount_get_root = g_mount_get_root(this : Mount*) : Pointer(LibGio::File)
  fun mount_get_sort_key = g_mount_get_sort_key(this : Mount*) : Pointer(UInt8)
  fun mount_get_symbolic_icon = g_mount_get_symbolic_icon(this : Mount*) : Pointer(LibGio::Icon)
  fun mount_get_uuid = g_mount_get_uuid(this : Mount*) : Pointer(UInt8)
  fun mount_get_volume = g_mount_get_volume(this : Mount*) : Pointer(LibGio::Volume)
  fun mount_guess_content_type = g_mount_guess_content_type(this : Mount*, force_rescan : LibC::Int, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_guess_content_type_finish = g_mount_guess_content_type_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Pointer(UInt8))
  fun mount_guess_content_type_sync = g_mount_guess_content_type_sync(this : Mount*, force_rescan : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Pointer(UInt8))
  fun mount_is_shadowed = g_mount_is_shadowed(this : Mount*) : LibC::Int
  fun mount_remount = g_mount_remount(this : Mount*, flags : LibGio::MountMountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_remount_finish = g_mount_remount_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun mount_shadow = g_mount_shadow(this : Mount*) : Void
  fun mount_unmount = g_mount_unmount(this : Mount*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_unmount_finish = g_mount_unmount_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun mount_unmount_with_operation = g_mount_unmount_with_operation(this : Mount*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun mount_unmount_with_operation_finish = g_mount_unmount_with_operation_finish(this : Mount*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun mount_unshadow = g_mount_unshadow(this : Mount*) : Void

  struct NetworkMonitor # interface
    g_iface : LibGObject::TypeInterface
    network_changed : Pointer(LibGio::NetworkMonitor), LibC::Int -> Void
    can_reach : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::SocketConnectable), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_reach_async : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::SocketConnectable), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    can_reach_finish : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    # Requires Initable
    # Signal network-changed
    # Virtual function can_reach
    # Virtual function can_reach_async
    # Virtual function can_reach_finish
    # Virtual function network_changed
    # Property connectivity : LibGio::NetworkConnectivity
    # Property network-available : LibC::Int
    # Property network-metered : LibC::Int
  end

  fun _g_network_monitor_get_type = g_network_monitor_get_type : UInt64
  fun network_monitor_get_default = g_network_monitor_get_default : Pointer(LibGio::NetworkMonitor)
  fun network_monitor_can_reach = g_network_monitor_can_reach(this : NetworkMonitor*, connectable : Pointer(LibGio::SocketConnectable), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun network_monitor_can_reach_async = g_network_monitor_can_reach_async(this : NetworkMonitor*, connectable : Pointer(LibGio::SocketConnectable), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun network_monitor_can_reach_finish = g_network_monitor_can_reach_finish(this : NetworkMonitor*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun network_monitor_get_connectivity = g_network_monitor_get_connectivity(this : NetworkMonitor*) : LibGio::NetworkConnectivity
  fun network_monitor_get_network_available = g_network_monitor_get_network_available(this : NetworkMonitor*) : LibC::Int
  fun network_monitor_get_network_metered = g_network_monitor_get_network_metered(this : NetworkMonitor*) : LibC::Int

  struct PollableInputStream # interface
    g_iface : LibGObject::TypeInterface
    can_poll : Pointer(LibGio::PollableInputStream) -> LibC::Int
    is_readable : Pointer(LibGio::PollableInputStream) -> LibC::Int
    create_source : Pointer(LibGio::PollableInputStream), Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    read_nonblocking : Pointer(LibGio::PollableInputStream), Pointer(UInt8), UInt64, LibGLib::Error* -> Int64
    # Requires InputStream
    # Virtual function can_poll
    # Virtual function create_source
    # Virtual function is_readable
    # Virtual function read_nonblocking
  end

  fun _g_pollable_input_stream_get_type = g_pollable_input_stream_get_type : UInt64
  fun pollable_input_stream_can_poll = g_pollable_input_stream_can_poll(this : PollableInputStream*) : LibC::Int
  fun pollable_input_stream_create_source = g_pollable_input_stream_create_source(this : PollableInputStream*, cancellable : Pointer(LibGio::Cancellable)) : Pointer(LibGLib::Source)
  fun pollable_input_stream_is_readable = g_pollable_input_stream_is_readable(this : PollableInputStream*) : LibC::Int
  fun pollable_input_stream_read_nonblocking = g_pollable_input_stream_read_nonblocking(this : PollableInputStream*, buffer : Pointer(UInt8), count : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64

  struct PollableOutputStream # interface
    g_iface : LibGObject::TypeInterface
    can_poll : Pointer(LibGio::PollableOutputStream) -> LibC::Int
    is_writable : Pointer(LibGio::PollableOutputStream) -> LibC::Int
    create_source : Pointer(LibGio::PollableOutputStream), Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    write_nonblocking : Pointer(LibGio::PollableOutputStream), Pointer(UInt8), UInt64, LibGLib::Error* -> Int64
    writev_nonblocking : Pointer(LibGio::PollableOutputStream), Pointer(LibGio::OutputVector), UInt64, UInt64, LibGLib::Error* -> LibGio::PollableReturn
    # Requires OutputStream
    # Virtual function can_poll
    # Virtual function create_source
    # Virtual function is_writable
    # Virtual function write_nonblocking
    # Virtual function writev_nonblocking
  end

  fun _g_pollable_output_stream_get_type = g_pollable_output_stream_get_type : UInt64
  fun pollable_output_stream_can_poll = g_pollable_output_stream_can_poll(this : PollableOutputStream*) : LibC::Int
  fun pollable_output_stream_create_source = g_pollable_output_stream_create_source(this : PollableOutputStream*, cancellable : Pointer(LibGio::Cancellable)) : Pointer(LibGLib::Source)
  fun pollable_output_stream_is_writable = g_pollable_output_stream_is_writable(this : PollableOutputStream*) : LibC::Int
  fun pollable_output_stream_write_nonblocking = g_pollable_output_stream_write_nonblocking(this : PollableOutputStream*, buffer : Pointer(UInt8), count : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun pollable_output_stream_writev_nonblocking = g_pollable_output_stream_writev_nonblocking(this : PollableOutputStream*, vectors : Pointer(LibGio::OutputVector), n_vectors : UInt64, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::PollableReturn

  struct Proxy # interface
    g_iface : LibGObject::TypeInterface
    connect : Pointer(LibGio::Proxy), Pointer(LibGio::IOStream), Pointer(LibGio::ProxyAddress), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::IOStream)
    connect_async : Pointer(LibGio::Proxy), Pointer(LibGio::IOStream), Pointer(LibGio::ProxyAddress), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    connect_finish : Pointer(LibGio::Proxy), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::IOStream)
    supports_hostname : Pointer(LibGio::Proxy) -> LibC::Int
    # Virtual function connect
    # Virtual function connect_async
    # Virtual function connect_finish
    # Virtual function supports_hostname
  end

  fun _g_proxy_get_type = g_proxy_get_type : UInt64
  fun proxy_get_default_for_protocol = g_proxy_get_default_for_protocol(protocol : Pointer(UInt8)) : Pointer(LibGio::Proxy)
  fun proxy_connect = g_proxy_connect(this : Proxy*, connection : Pointer(LibGio::IOStream), proxy_address : Pointer(LibGio::ProxyAddress), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::IOStream)
  fun proxy_connect_async = g_proxy_connect_async(this : Proxy*, connection : Pointer(LibGio::IOStream), proxy_address : Pointer(LibGio::ProxyAddress), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun proxy_connect_finish = g_proxy_connect_finish(this : Proxy*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::IOStream)
  fun proxy_supports_hostname = g_proxy_supports_hostname(this : Proxy*) : LibC::Int

  struct ProxyResolver # interface
    g_iface : LibGObject::TypeInterface
    is_supported : Pointer(LibGio::ProxyResolver) -> LibC::Int
    lookup : Pointer(LibGio::ProxyResolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Pointer(UInt8))
    lookup_async : Pointer(LibGio::ProxyResolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_finish : Pointer(LibGio::ProxyResolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Pointer(UInt8))
    # Virtual function is_supported
    # Virtual function lookup
    # Virtual function lookup_async
    # Virtual function lookup_finish
  end

  fun _g_proxy_resolver_get_type = g_proxy_resolver_get_type : UInt64
  fun proxy_resolver_get_default = g_proxy_resolver_get_default : Pointer(LibGio::ProxyResolver)
  fun proxy_resolver_is_supported = g_proxy_resolver_is_supported(this : ProxyResolver*) : LibC::Int
  fun proxy_resolver_lookup = g_proxy_resolver_lookup(this : ProxyResolver*, uri : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Pointer(UInt8))
  fun proxy_resolver_lookup_async = g_proxy_resolver_lookup_async(this : ProxyResolver*, uri : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun proxy_resolver_lookup_finish = g_proxy_resolver_lookup_finish(this : ProxyResolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Pointer(UInt8))

  struct RemoteActionGroup # interface
    g_iface : LibGObject::TypeInterface
    activate_action_full : Pointer(LibGio::RemoteActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> Void
    change_action_state_full : Pointer(LibGio::RemoteActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> Void
    # Requires ActionGroup
    # Virtual function activate_action_full
    # Virtual function change_action_state_full
  end

  fun _g_remote_action_group_get_type = g_remote_action_group_get_type : UInt64
  fun remote_action_group_activate_action_full = g_remote_action_group_activate_action_full(this : RemoteActionGroup*, action_name : Pointer(UInt8), parameter : Pointer(LibGLib::Variant), platform_data : Pointer(LibGLib::Variant)) : Void
  fun remote_action_group_change_action_state_full = g_remote_action_group_change_action_state_full(this : RemoteActionGroup*, action_name : Pointer(UInt8), value : Pointer(LibGLib::Variant), platform_data : Pointer(LibGLib::Variant)) : Void

  struct Seekable # interface
    g_iface : LibGObject::TypeInterface
    tell : Pointer(LibGio::Seekable) -> Int64
    can_seek : Pointer(LibGio::Seekable) -> LibC::Int
    seek : Pointer(LibGio::Seekable), Int64, LibGLib::SeekType, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_truncate : Pointer(LibGio::Seekable) -> LibC::Int
    truncate_fn : Pointer(LibGio::Seekable), Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    # Virtual function can_seek
    # Virtual function can_truncate
    # Virtual function seek
    # Virtual function tell
    # Virtual function truncate_fn
  end

  fun _g_seekable_get_type = g_seekable_get_type : UInt64
  fun seekable_can_seek = g_seekable_can_seek(this : Seekable*) : LibC::Int
  fun seekable_can_truncate = g_seekable_can_truncate(this : Seekable*) : LibC::Int
  fun seekable_seek = g_seekable_seek(this : Seekable*, offset : Int64, type : LibGLib::SeekType, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun seekable_tell = g_seekable_tell(this : Seekable*) : Int64
  fun seekable_truncate = g_seekable_truncate(this : Seekable*, offset : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int

  struct SocketConnectable # interface
    g_iface : LibGObject::TypeInterface
    enumerate : Pointer(LibGio::SocketConnectable) -> Pointer(LibGio::SocketAddressEnumerator)
    proxy_enumerate : Pointer(LibGio::SocketConnectable) -> Pointer(LibGio::SocketAddressEnumerator)
    to_string : Pointer(LibGio::SocketConnectable) -> Pointer(UInt8)
    # Virtual function enumerate
    # Virtual function proxy_enumerate
    # Virtual function to_string
  end

  fun _g_socket_connectable_get_type = g_socket_connectable_get_type : UInt64
  fun socket_connectable_enumerate = g_socket_connectable_enumerate(this : SocketConnectable*) : Pointer(LibGio::SocketAddressEnumerator)
  fun socket_connectable_proxy_enumerate = g_socket_connectable_proxy_enumerate(this : SocketConnectable*) : Pointer(LibGio::SocketAddressEnumerator)
  fun socket_connectable_to_string = g_socket_connectable_to_string(this : SocketConnectable*) : Pointer(UInt8)

  struct TlsBackend # interface
    g_iface : LibGObject::TypeInterface
    supports_tls : Pointer(LibGio::TlsBackend) -> LibC::Int
    get_certificate_type : -> UInt64
    get_client_connection_type : -> UInt64
    get_server_connection_type : -> UInt64
    get_file_database_type : -> UInt64
    get_default_database : Pointer(LibGio::TlsBackend) -> Pointer(LibGio::TlsDatabase)
    supports_dtls : Pointer(LibGio::TlsBackend) -> LibC::Int
    get_dtls_client_connection_type : -> UInt64
    get_dtls_server_connection_type : -> UInt64
    # Virtual function get_default_database
    # Virtual function supports_dtls
    # Virtual function supports_tls
  end

  fun _g_tls_backend_get_type = g_tls_backend_get_type : UInt64
  fun tls_backend_get_default = g_tls_backend_get_default : Pointer(LibGio::TlsBackend)
  fun tls_backend_get_certificate_type = g_tls_backend_get_certificate_type(this : TlsBackend*) : UInt64
  fun tls_backend_get_client_connection_type = g_tls_backend_get_client_connection_type(this : TlsBackend*) : UInt64
  fun tls_backend_get_default_database = g_tls_backend_get_default_database(this : TlsBackend*) : Pointer(LibGio::TlsDatabase)
  fun tls_backend_get_dtls_client_connection_type = g_tls_backend_get_dtls_client_connection_type(this : TlsBackend*) : UInt64
  fun tls_backend_get_dtls_server_connection_type = g_tls_backend_get_dtls_server_connection_type(this : TlsBackend*) : UInt64
  fun tls_backend_get_file_database_type = g_tls_backend_get_file_database_type(this : TlsBackend*) : UInt64
  fun tls_backend_get_server_connection_type = g_tls_backend_get_server_connection_type(this : TlsBackend*) : UInt64
  fun tls_backend_set_default_database = g_tls_backend_set_default_database(this : TlsBackend*, database : Pointer(LibGio::TlsDatabase)) : Void
  fun tls_backend_supports_dtls = g_tls_backend_supports_dtls(this : TlsBackend*) : LibC::Int
  fun tls_backend_supports_tls = g_tls_backend_supports_tls(this : TlsBackend*) : LibC::Int

  struct TlsClientConnection # interface
    g_iface : LibGObject::TypeInterface
    copy_session_state : Pointer(LibGio::TlsClientConnection), Pointer(LibGio::TlsClientConnection) -> Void
    # Requires TlsConnection
    # Virtual function copy_session_state
    # Property accepted-cas : Pointer(Void*)
    # Property server-identity : LibGio::SocketConnectable
    # Property use-ssl3 : LibC::Int
    # Property validation-flags : LibGio::TlsCertificateFlags
  end

  fun _g_tls_client_connection_get_type = g_tls_client_connection_get_type : UInt64
  fun tls_client_connection_new = g_tls_client_connection_new(base_io_stream : Pointer(LibGio::IOStream), server_identity : Pointer(LibGio::SocketConnectable), error : LibGLib::Error**) : Pointer(LibGio::TlsClientConnection)
  fun tls_client_connection_copy_session_state = g_tls_client_connection_copy_session_state(this : TlsClientConnection*, source : Pointer(LibGio::TlsClientConnection)) : Void
  fun tls_client_connection_get_accepted_cas = g_tls_client_connection_get_accepted_cas(this : TlsClientConnection*) : Pointer(Void*)
  fun tls_client_connection_get_server_identity = g_tls_client_connection_get_server_identity(this : TlsClientConnection*) : Pointer(LibGio::SocketConnectable)
  fun tls_client_connection_get_use_ssl3 = g_tls_client_connection_get_use_ssl3(this : TlsClientConnection*) : LibC::Int
  fun tls_client_connection_get_validation_flags = g_tls_client_connection_get_validation_flags(this : TlsClientConnection*) : LibGio::TlsCertificateFlags
  fun tls_client_connection_set_server_identity = g_tls_client_connection_set_server_identity(this : TlsClientConnection*, identity : Pointer(LibGio::SocketConnectable)) : Void
  fun tls_client_connection_set_use_ssl3 = g_tls_client_connection_set_use_ssl3(this : TlsClientConnection*, use_ssl3 : LibC::Int) : Void
  fun tls_client_connection_set_validation_flags = g_tls_client_connection_set_validation_flags(this : TlsClientConnection*, flags : LibGio::TlsCertificateFlags) : Void

  struct TlsFileDatabase # interface
    g_iface : LibGObject::TypeInterface
    padding : Pointer(Void)[8]
    # Requires TlsDatabase
    # Property anchors : Pointer(UInt8)
  end

  fun _g_tls_file_database_get_type = g_tls_file_database_get_type : UInt64
  fun tls_file_database_new = g_tls_file_database_new(anchors : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::TlsFileDatabase)

  struct TlsServerConnection # interface
    g_iface : LibGObject::TypeInterface
    # Requires TlsConnection
    # Property authentication-mode : LibGio::TlsAuthenticationMode
  end

  fun _g_tls_server_connection_get_type = g_tls_server_connection_get_type : UInt64
  fun tls_server_connection_new = g_tls_server_connection_new(base_io_stream : Pointer(LibGio::IOStream), certificate : Pointer(LibGio::TlsCertificate), error : LibGLib::Error**) : Pointer(LibGio::TlsServerConnection)

  struct Volume # interface
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Volume) -> Void
    removed : Pointer(LibGio::Volume) -> Void
    get_name : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Volume) -> Pointer(LibGio::Icon)
    get_uuid : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_drive : Pointer(LibGio::Volume) -> Pointer(LibGio::Drive)
    get_mount : Pointer(LibGio::Volume) -> Pointer(LibGio::Mount)
    can_mount : Pointer(LibGio::Volume) -> LibC::Int
    can_eject : Pointer(LibGio::Volume) -> LibC::Int
    mount_fn : Pointer(LibGio::Volume), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject : Pointer(LibGio::Volume), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_identifier : Pointer(LibGio::Volume), Pointer(UInt8) -> Pointer(UInt8)
    enumerate_identifiers : Pointer(LibGio::Volume) -> Pointer(Pointer(UInt8))
    should_automount : Pointer(LibGio::Volume) -> LibC::Int
    get_activation_root : Pointer(LibGio::Volume) -> Pointer(LibGio::File)
    eject_with_operation : Pointer(LibGio::Volume), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_sort_key : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Volume) -> Pointer(LibGio::Icon)
    # Signal changed
    # Signal removed
    # Virtual function can_eject
    # Virtual function can_mount
    # Virtual function changed
    # Virtual function eject
    # Virtual function eject_finish
    # Virtual function eject_with_operation
    # Virtual function eject_with_operation_finish
    # Virtual function enumerate_identifiers
    # Virtual function get_activation_root
    # Virtual function get_drive
    # Virtual function get_icon
    # Virtual function get_identifier
    # Virtual function get_mount
    # Virtual function get_name
    # Virtual function get_sort_key
    # Virtual function get_symbolic_icon
    # Virtual function get_uuid
    # Virtual function mount_finish
    # Virtual function mount_fn
    # Virtual function removed
    # Virtual function should_automount
  end

  fun _g_volume_get_type = g_volume_get_type : UInt64
  fun volume_can_eject = g_volume_can_eject(this : Volume*) : LibC::Int
  fun volume_can_mount = g_volume_can_mount(this : Volume*) : LibC::Int
  fun volume_eject = g_volume_eject(this : Volume*, flags : LibGio::MountUnmountFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun volume_eject_finish = g_volume_eject_finish(this : Volume*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun volume_eject_with_operation = g_volume_eject_with_operation(this : Volume*, flags : LibGio::MountUnmountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun volume_eject_with_operation_finish = g_volume_eject_with_operation_finish(this : Volume*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun volume_enumerate_identifiers = g_volume_enumerate_identifiers(this : Volume*) : Pointer(Pointer(UInt8))
  fun volume_get_activation_root = g_volume_get_activation_root(this : Volume*) : Pointer(LibGio::File)
  fun volume_get_drive = g_volume_get_drive(this : Volume*) : Pointer(LibGio::Drive)
  fun volume_get_icon = g_volume_get_icon(this : Volume*) : Pointer(LibGio::Icon)
  fun volume_get_identifier = g_volume_get_identifier(this : Volume*, kind : Pointer(UInt8)) : Pointer(UInt8)
  fun volume_get_mount = g_volume_get_mount(this : Volume*) : Pointer(LibGio::Mount)
  fun volume_get_name = g_volume_get_name(this : Volume*) : Pointer(UInt8)
  fun volume_get_sort_key = g_volume_get_sort_key(this : Volume*) : Pointer(UInt8)
  fun volume_get_symbolic_icon = g_volume_get_symbolic_icon(this : Volume*) : Pointer(LibGio::Icon)
  fun volume_get_uuid = g_volume_get_uuid(this : Volume*) : Pointer(UInt8)
  fun volume_mount = g_volume_mount(this : Volume*, flags : LibGio::MountMountFlags, mount_operation : Pointer(LibGio::MountOperation), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun volume_mount_finish = g_volume_mount_finish(this : Volume*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun volume_should_automount = g_volume_should_automount(this : Volume*) : LibC::Int

  ###########################################
  # #    Structs
  ###########################################

  struct ActionEntry # struct
    name : Pointer(UInt8)
    activate : Pointer(LibGio::SimpleAction), Pointer(LibGLib::Variant), Pointer(Void) -> Void
    parameter_type : Pointer(UInt8)
    state : Pointer(UInt8)
    change_state : Pointer(LibGio::SimpleAction), Pointer(LibGLib::Variant), Pointer(Void) -> Void
    padding : UInt64[3]
  end

  struct ActionGroupInterface # struct
    g_iface : LibGObject::TypeInterface
    has_action : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> LibC::Int
    list_actions : Pointer(LibGio::ActionGroup) -> Pointer(Pointer(UInt8))
    get_action_enabled : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> LibC::Int
    get_action_parameter_type : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::VariantType)
    get_action_state_type : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::VariantType)
    get_action_state_hint : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::Variant)
    get_action_state : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Pointer(LibGLib::Variant)
    change_action_state : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    activate_action : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    action_added : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Void
    action_removed : Pointer(LibGio::ActionGroup), Pointer(UInt8) -> Void
    action_enabled_changed : Pointer(LibGio::ActionGroup), Pointer(UInt8), LibC::Int -> Void
    action_state_changed : Pointer(LibGio::ActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    query_action : Pointer(LibGio::ActionGroup), Pointer(UInt8), LibC::Int, Pointer(LibGLib::VariantType), Pointer(LibGLib::VariantType), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> LibC::Int
  end

  struct ActionInterface # struct
    g_iface : LibGObject::TypeInterface
    get_name : Pointer(LibGio::Action) -> Pointer(UInt8)
    get_parameter_type : Pointer(LibGio::Action) -> Pointer(LibGLib::VariantType)
    get_state_type : Pointer(LibGio::Action) -> Pointer(LibGLib::VariantType)
    get_state_hint : Pointer(LibGio::Action) -> Pointer(LibGLib::Variant)
    get_enabled : Pointer(LibGio::Action) -> LibC::Int
    get_state : Pointer(LibGio::Action) -> Pointer(LibGLib::Variant)
    change_state : Pointer(LibGio::Action), Pointer(LibGLib::Variant) -> Void
    activate : Pointer(LibGio::Action), Pointer(LibGLib::Variant) -> Void
  end

  struct ActionMapInterface # struct
    g_iface : LibGObject::TypeInterface
    lookup_action : Pointer(LibGio::ActionMap), Pointer(UInt8) -> Pointer(LibGio::Action)
    add_action : Pointer(LibGio::ActionMap), Pointer(LibGio::Action) -> Void
    remove_action : Pointer(LibGio::ActionMap), Pointer(UInt8) -> Void
  end

  struct AppInfoIface # struct
    g_iface : LibGObject::TypeInterface
    dup : Pointer(LibGio::AppInfo) -> Pointer(LibGio::AppInfo)
    equal : Pointer(LibGio::AppInfo), Pointer(LibGio::AppInfo) -> LibC::Int
    get_id : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_name : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_description : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_executable : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::AppInfo) -> Pointer(LibGio::Icon)
    launch : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), LibGLib::Error* -> LibC::Int
    supports_uris : Pointer(LibGio::AppInfo) -> LibC::Int
    supports_files : Pointer(LibGio::AppInfo) -> LibC::Int
    launch_uris : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), LibGLib::Error* -> LibC::Int
    should_show : Pointer(LibGio::AppInfo) -> LibC::Int
    set_as_default_for_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    set_as_default_for_extension : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    add_supports_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    can_remove_supports_type : Pointer(LibGio::AppInfo) -> LibC::Int
    remove_supports_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    can_delete : Pointer(LibGio::AppInfo) -> LibC::Int
    do_delete : Pointer(LibGio::AppInfo) -> LibC::Int
    get_commandline : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    get_display_name : Pointer(LibGio::AppInfo) -> Pointer(UInt8)
    set_as_last_used_for_type : Pointer(LibGio::AppInfo), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    get_supported_types : Pointer(LibGio::AppInfo) -> Pointer(Pointer(UInt8))
    launch_uris_async : Pointer(LibGio::AppInfo), Pointer(Void*), Pointer(LibGio::AppLaunchContext), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    launch_uris_finish : Pointer(LibGio::AppInfo), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
  end

  struct AppLaunchContextClass # struct
    parent_class : LibGObject::ObjectClass
    get_display : Pointer(LibGio::AppLaunchContext), Pointer(LibGio::AppInfo), Pointer(Void*) -> Pointer(UInt8)
    get_startup_notify_id : Pointer(LibGio::AppLaunchContext), Pointer(LibGio::AppInfo), Pointer(Void*) -> Pointer(UInt8)
    launch_failed : Pointer(LibGio::AppLaunchContext), Pointer(UInt8) -> Void
    launched : Pointer(LibGio::AppLaunchContext), Pointer(LibGio::AppInfo), Pointer(LibGLib::Variant) -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
  end

  struct AppLaunchContextPrivate # struct
    _data : UInt8[0]
  end

  struct ApplicationClass # struct
    parent_class : LibGObject::ObjectClass
    startup : Pointer(LibGio::Application) -> Void
    activate : Pointer(LibGio::Application) -> Void
    open : Pointer(LibGio::Application), Pointer(Pointer(LibGio::File)), Int32, Pointer(UInt8) -> Void
    command_line : Pointer(LibGio::Application), Pointer(LibGio::ApplicationCommandLine) -> Int32
    local_command_line : Pointer(LibGio::Application), Pointer(Pointer(UInt8)), Int32 -> LibC::Int
    before_emit : Pointer(LibGio::Application), Pointer(LibGLib::Variant) -> Void
    after_emit : Pointer(LibGio::Application), Pointer(LibGLib::Variant) -> Void
    add_platform_data : Pointer(LibGio::Application), Pointer(LibGLib::VariantBuilder) -> Void
    quit_mainloop : Pointer(LibGio::Application) -> Void
    run_mainloop : Pointer(LibGio::Application) -> Void
    shutdown : Pointer(LibGio::Application) -> Void
    dbus_register : Pointer(LibGio::Application), Pointer(LibGio::DBusConnection), Pointer(UInt8), LibGLib::Error* -> LibC::Int
    dbus_unregister : Pointer(LibGio::Application), Pointer(LibGio::DBusConnection), Pointer(UInt8) -> Void
    handle_local_options : Pointer(LibGio::Application), Pointer(LibGLib::VariantDict) -> Int32
    name_lost : Pointer(LibGio::Application) -> LibC::Int
    padding : Pointer(Void)[7]
  end

  struct ApplicationCommandLineClass # struct
    parent_class : LibGObject::ObjectClass
    print_literal : Pointer(LibGio::ApplicationCommandLine), Pointer(UInt8) -> Void
    printerr_literal : Pointer(LibGio::ApplicationCommandLine), Pointer(UInt8) -> Void
    get_stdin : Pointer(LibGio::ApplicationCommandLine) -> Pointer(LibGio::InputStream)
    padding : Pointer(Void)[11]
  end

  struct ApplicationCommandLinePrivate # struct
    _data : UInt8[0]
  end

  struct ApplicationPrivate # struct
    _data : UInt8[0]
  end

  struct AsyncInitableIface # struct
    g_iface : LibGObject::TypeInterface
    init_async : Pointer(LibGio::AsyncInitable), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    init_finish : Pointer(LibGio::AsyncInitable), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
  end

  struct AsyncResultIface # struct
    g_iface : LibGObject::TypeInterface
    get_user_data : Pointer(LibGio::AsyncResult) -> Pointer(Void)
    get_source_object : Pointer(LibGio::AsyncResult) -> Pointer(LibGObject::Object)
    is_tagged : Pointer(LibGio::AsyncResult), Pointer(Void) -> LibC::Int
  end

  struct BufferedInputStreamClass # struct
    parent_class : LibGio::FilterInputStreamClass
    fill : Pointer(LibGio::BufferedInputStream), Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int64
    fill_async : Pointer(LibGio::BufferedInputStream), Int64, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    fill_finish : Pointer(LibGio::BufferedInputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Int64
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct BufferedInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct BufferedOutputStreamClass # struct
    parent_class : LibGio::FilterOutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
  end

  struct BufferedOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct CancellableClass # struct
    parent_class : LibGObject::ObjectClass
    cancelled : Pointer(LibGio::Cancellable) -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct CancellablePrivate # struct
    _data : UInt8[0]
  end

  struct CharsetConverterClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct ConverterIface # struct
    g_iface : LibGObject::TypeInterface
    convert : Pointer(LibGio::Converter), Pointer(UInt8), UInt64, Pointer(UInt8), UInt64, LibGio::ConverterFlags, UInt64, UInt64, LibGLib::Error* -> LibGio::ConverterResult
    reset : Pointer(LibGio::Converter) -> Void
  end

  struct ConverterInputStreamClass # struct
    parent_class : LibGio::FilterInputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct ConverterInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct ConverterOutputStreamClass # struct
    parent_class : LibGio::FilterOutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct ConverterOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct CredentialsClass # struct
    _data : UInt8[0]
  end

  struct DBusAnnotationInfo # struct
    ref_count : Int32
    key : Pointer(UInt8)
    value : Pointer(UInt8)
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_annotation_info_get_type = g_dbus_annotation_info_get_type : UInt64
  fun d_bus_annotation_info_ref = g_dbus_annotation_info_ref(this : DBusAnnotationInfo*) : Pointer(LibGio::DBusAnnotationInfo)
  fun d_bus_annotation_info_unref = g_dbus_annotation_info_unref(this : DBusAnnotationInfo*) : Void
  fun d_bus_annotation_info_lookup = g_dbus_annotation_info_lookup(annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo)), name : Pointer(UInt8)) : Pointer(UInt8)

  struct DBusArgInfo # struct
    ref_count : Int32
    name : Pointer(UInt8)
    signature : Pointer(UInt8)
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_arg_info_get_type = g_dbus_arg_info_get_type : UInt64
  fun d_bus_arg_info_ref = g_dbus_arg_info_ref(this : DBusArgInfo*) : Pointer(LibGio::DBusArgInfo)
  fun d_bus_arg_info_unref = g_dbus_arg_info_unref(this : DBusArgInfo*) : Void

  struct DBusErrorEntry # struct
    error_code : Int32
    dbus_error_name : Pointer(UInt8)
  end

  struct DBusInterfaceIface # struct
    parent_iface : LibGObject::TypeInterface
    get_info : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusInterfaceInfo)
    get_object : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusObject)
    set_object : Pointer(LibGio::DBusInterface), Pointer(LibGio::DBusObject) -> Void
    dup_object : Pointer(LibGio::DBusInterface) -> Pointer(LibGio::DBusObject)
  end

  struct DBusInterfaceInfo # struct
    ref_count : Int32
    name : Pointer(UInt8)
    methods : Pointer(Pointer(LibGio::DBusMethodInfo))
    signals : Pointer(Pointer(LibGio::DBusSignalInfo))
    properties : Pointer(Pointer(LibGio::DBusPropertyInfo))
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_interface_info_get_type = g_dbus_interface_info_get_type : UInt64
  fun d_bus_interface_info_cache_build = g_dbus_interface_info_cache_build(this : DBusInterfaceInfo*) : Void
  fun d_bus_interface_info_cache_release = g_dbus_interface_info_cache_release(this : DBusInterfaceInfo*) : Void
  fun d_bus_interface_info_generate_xml = g_dbus_interface_info_generate_xml(this : DBusInterfaceInfo*, indent : UInt32, string_builder : Pointer(LibGLib::String)) : Void
  fun d_bus_interface_info_lookup_method = g_dbus_interface_info_lookup_method(this : DBusInterfaceInfo*, name : Pointer(UInt8)) : Pointer(LibGio::DBusMethodInfo)
  fun d_bus_interface_info_lookup_property = g_dbus_interface_info_lookup_property(this : DBusInterfaceInfo*, name : Pointer(UInt8)) : Pointer(LibGio::DBusPropertyInfo)
  fun d_bus_interface_info_lookup_signal = g_dbus_interface_info_lookup_signal(this : DBusInterfaceInfo*, name : Pointer(UInt8)) : Pointer(LibGio::DBusSignalInfo)
  fun d_bus_interface_info_ref = g_dbus_interface_info_ref(this : DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo)
  fun d_bus_interface_info_unref = g_dbus_interface_info_unref(this : DBusInterfaceInfo*) : Void

  struct DBusInterfaceSkeletonClass # struct
    parent_class : LibGObject::ObjectClass
    get_info : Pointer(LibGio::DBusInterfaceSkeleton) -> Pointer(LibGio::DBusInterfaceInfo)
    get_vtable : Pointer(Void)
    get_properties : Pointer(LibGio::DBusInterfaceSkeleton) -> Pointer(LibGLib::Variant)
    flush : Pointer(LibGio::DBusInterfaceSkeleton) -> Void
    vfunc_padding : Pointer(Void)[8]
    g_authorize_method : Pointer(LibGio::DBusInterfaceSkeleton), Pointer(LibGio::DBusMethodInvocation) -> LibC::Int
    signal_padding : Pointer(Void)[8]
  end

  struct DBusInterfaceSkeletonPrivate # struct
    _data : UInt8[0]
  end

  struct DBusInterfaceVTable # struct
    method_call : LibGio::DBusInterfaceMethodCallFunc
    get_property : LibGio::DBusInterfaceGetPropertyFunc
    set_property : LibGio::DBusInterfaceSetPropertyFunc
    padding : Pointer(Void)[8]
  end

  struct DBusMethodInfo # struct
    ref_count : Int32
    name : Pointer(UInt8)
    in_args : Pointer(Pointer(LibGio::DBusArgInfo))
    out_args : Pointer(Pointer(LibGio::DBusArgInfo))
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_method_info_get_type = g_dbus_method_info_get_type : UInt64
  fun d_bus_method_info_ref = g_dbus_method_info_ref(this : DBusMethodInfo*) : Pointer(LibGio::DBusMethodInfo)
  fun d_bus_method_info_unref = g_dbus_method_info_unref(this : DBusMethodInfo*) : Void

  struct DBusNodeInfo # struct
    ref_count : Int32
    path : Pointer(UInt8)
    interfaces : Pointer(Pointer(LibGio::DBusInterfaceInfo))
    nodes : Pointer(Pointer(LibGio::DBusNodeInfo))
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_node_info_get_type = g_dbus_node_info_get_type : UInt64
  fun d_bus_node_info_new_for_xml = g_dbus_node_info_new_for_xml(xml_data : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::DBusNodeInfo)
  fun d_bus_node_info_generate_xml = g_dbus_node_info_generate_xml(this : DBusNodeInfo*, indent : UInt32, string_builder : Pointer(LibGLib::String)) : Void
  fun d_bus_node_info_lookup_interface = g_dbus_node_info_lookup_interface(this : DBusNodeInfo*, name : Pointer(UInt8)) : Pointer(LibGio::DBusInterfaceInfo)
  fun d_bus_node_info_ref = g_dbus_node_info_ref(this : DBusNodeInfo*) : Pointer(LibGio::DBusNodeInfo)
  fun d_bus_node_info_unref = g_dbus_node_info_unref(this : DBusNodeInfo*) : Void

  struct DBusObjectIface # struct
    parent_iface : LibGObject::TypeInterface
    get_object_path : Pointer(LibGio::DBusObject) -> Pointer(UInt8)
    get_interfaces : Pointer(LibGio::DBusObject) -> Pointer(Void*)
    get_interface : Pointer(LibGio::DBusObject), Pointer(UInt8) -> Pointer(LibGio::DBusInterface)
    interface_added : Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    interface_removed : Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
  end

  struct DBusObjectManagerClientClass # struct
    parent_class : LibGObject::ObjectClass
    interface_proxy_signal : Pointer(LibGio::DBusObjectManagerClient), Pointer(LibGio::DBusObjectProxy), Pointer(LibGio::DBusProxy), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    interface_proxy_properties_changed : Pointer(LibGio::DBusObjectManagerClient), Pointer(LibGio::DBusObjectProxy), Pointer(LibGio::DBusProxy), Pointer(LibGLib::Variant), Pointer(UInt8) -> Void
    padding : Pointer(Void)[8]
  end

  struct DBusObjectManagerClientPrivate # struct
    _data : UInt8[0]
  end

  struct DBusObjectManagerIface # struct
    parent_iface : LibGObject::TypeInterface
    get_object_path : Pointer(LibGio::DBusObjectManager) -> Pointer(UInt8)
    get_objects : Pointer(LibGio::DBusObjectManager) -> Pointer(Void*)
    get_object : Pointer(LibGio::DBusObjectManager), Pointer(UInt8) -> Pointer(LibGio::DBusObject)
    get_interface : Pointer(LibGio::DBusObjectManager), Pointer(UInt8), Pointer(UInt8) -> Pointer(LibGio::DBusInterface)
    object_added : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject) -> Void
    object_removed : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject) -> Void
    interface_added : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
    interface_removed : Pointer(LibGio::DBusObjectManager), Pointer(LibGio::DBusObject), Pointer(LibGio::DBusInterface) -> Void
  end

  struct DBusObjectManagerServerClass # struct
    parent_class : LibGObject::ObjectClass
    padding : Pointer(Void)[8]
  end

  struct DBusObjectManagerServerPrivate # struct
    _data : UInt8[0]
  end

  struct DBusObjectProxyClass # struct
    parent_class : LibGObject::ObjectClass
    padding : Pointer(Void)[8]
  end

  struct DBusObjectProxyPrivate # struct
    _data : UInt8[0]
  end

  struct DBusObjectSkeletonClass # struct
    parent_class : LibGObject::ObjectClass
    authorize_method : Pointer(LibGio::DBusObjectSkeleton), Pointer(LibGio::DBusInterfaceSkeleton), Pointer(LibGio::DBusMethodInvocation) -> LibC::Int
    padding : Pointer(Void)[8]
  end

  struct DBusObjectSkeletonPrivate # struct
    _data : UInt8[0]
  end

  struct DBusPropertyInfo # struct
    ref_count : Int32
    name : Pointer(UInt8)
    signature : Pointer(UInt8)
    flags : LibGio::DBusPropertyInfoFlags
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_property_info_get_type = g_dbus_property_info_get_type : UInt64
  fun d_bus_property_info_ref = g_dbus_property_info_ref(this : DBusPropertyInfo*) : Pointer(LibGio::DBusPropertyInfo)
  fun d_bus_property_info_unref = g_dbus_property_info_unref(this : DBusPropertyInfo*) : Void

  struct DBusProxyClass # struct
    parent_class : LibGObject::ObjectClass
    g_properties_changed : Pointer(LibGio::DBusProxy), Pointer(LibGLib::Variant), Pointer(UInt8) -> Void
    g_signal : Pointer(LibGio::DBusProxy), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Variant) -> Void
    padding : Pointer(Void)[32]
  end

  struct DBusProxyPrivate # struct
    _data : UInt8[0]
  end

  struct DBusSignalInfo # struct
    ref_count : Int32
    name : Pointer(UInt8)
    args : Pointer(Pointer(LibGio::DBusArgInfo))
    annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo))
  end

  fun _g_dbus_signal_info_get_type = g_dbus_signal_info_get_type : UInt64
  fun d_bus_signal_info_ref = g_dbus_signal_info_ref(this : DBusSignalInfo*) : Pointer(LibGio::DBusSignalInfo)
  fun d_bus_signal_info_unref = g_dbus_signal_info_unref(this : DBusSignalInfo*) : Void

  struct DBusSubtreeVTable # struct
    enumerate : Pointer(Void)
    introspect : LibGio::DBusSubtreeIntrospectFunc
    dispatch : LibGio::DBusSubtreeDispatchFunc
    padding : Pointer(Void)[8]
  end

  struct DataInputStreamClass # struct
    parent_class : LibGio::BufferedInputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct DataInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct DataOutputStreamClass # struct
    parent_class : LibGio::FilterOutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct DataOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct DatagramBasedInterface # struct
    g_iface : LibGObject::TypeInterface
    receive_messages : Pointer(LibGio::DatagramBased), Pointer(LibGio::InputMessage), UInt32, Int32, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int32
    send_messages : Pointer(LibGio::DatagramBased), Pointer(LibGio::OutputMessage), UInt32, Int32, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int32
    create_source : Pointer(LibGio::DatagramBased), LibGLib::IOCondition, Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    condition_check : Pointer(LibGio::DatagramBased), LibGLib::IOCondition -> LibGLib::IOCondition
    condition_wait : Pointer(LibGio::DatagramBased), LibGLib::IOCondition, Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
  end

  struct DesktopAppInfoClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct DesktopAppInfoLookupIface # struct
    g_iface : LibGObject::TypeInterface
    get_default_for_uri_scheme : Pointer(LibGio::DesktopAppInfoLookup), Pointer(UInt8) -> Pointer(LibGio::AppInfo)
  end

  struct DriveIface # struct
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Drive) -> Void
    disconnected : Pointer(LibGio::Drive) -> Void
    eject_button : Pointer(LibGio::Drive) -> Void
    get_name : Pointer(LibGio::Drive) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Drive) -> Pointer(LibGio::Icon)
    has_volumes : Pointer(LibGio::Drive) -> LibC::Int
    get_volumes : Pointer(LibGio::Drive) -> Pointer(Void*)
    is_media_removable : Pointer(LibGio::Drive) -> LibC::Int
    has_media : Pointer(LibGio::Drive) -> LibC::Int
    is_media_check_automatic : Pointer(LibGio::Drive) -> LibC::Int
    can_eject : Pointer(LibGio::Drive) -> LibC::Int
    can_poll_for_media : Pointer(LibGio::Drive) -> LibC::Int
    eject : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    poll_for_media : Pointer(LibGio::Drive), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    poll_for_media_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_identifier : Pointer(LibGio::Drive), Pointer(UInt8) -> Pointer(UInt8)
    enumerate_identifiers : Pointer(LibGio::Drive) -> Pointer(Pointer(UInt8))
    get_start_stop_type : Pointer(LibGio::Drive) -> LibGio::DriveStartStopType
    can_start : Pointer(LibGio::Drive) -> LibC::Int
    can_start_degraded : Pointer(LibGio::Drive) -> LibC::Int
    start : Pointer(LibGio::Drive), LibGio::DriveStartFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    start_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    can_stop : Pointer(LibGio::Drive) -> LibC::Int
    stop : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    stop_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    stop_button : Pointer(LibGio::Drive) -> Void
    eject_with_operation : Pointer(LibGio::Drive), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Drive), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_sort_key : Pointer(LibGio::Drive) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Drive) -> Pointer(LibGio::Icon)
    is_removable : Pointer(LibGio::Drive) -> LibC::Int
  end

  struct DtlsClientConnectionInterface # struct
    g_iface : LibGObject::TypeInterface
  end

  struct DtlsConnectionInterface # struct
    g_iface : LibGObject::TypeInterface
    accept_certificate : Pointer(LibGio::DtlsConnection), Pointer(LibGio::TlsCertificate), LibGio::TlsCertificateFlags -> LibC::Int
    handshake : Pointer(LibGio::DtlsConnection), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    handshake_async : Pointer(LibGio::DtlsConnection), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    handshake_finish : Pointer(LibGio::DtlsConnection), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    shutdown : Pointer(LibGio::DtlsConnection), LibC::Int, LibC::Int, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    shutdown_async : Pointer(LibGio::DtlsConnection), LibC::Int, LibC::Int, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    shutdown_finish : Pointer(LibGio::DtlsConnection), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    set_advertised_protocols : Pointer(LibGio::DtlsConnection), Pointer(Pointer(UInt8)) -> Void
    get_negotiated_protocol : Pointer(LibGio::DtlsConnection) -> Pointer(UInt8)
  end

  struct DtlsServerConnectionInterface # struct
    g_iface : LibGObject::TypeInterface
  end

  struct EmblemClass # struct
    _data : UInt8[0]
  end

  struct EmblemedIconClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct EmblemedIconPrivate # struct
    _data : UInt8[0]
  end

  struct FileAttributeInfo # struct
    name : Pointer(UInt8)
    type : LibGio::FileAttributeType
    flags : LibGio::FileAttributeInfoFlags
  end

  struct FileAttributeInfoList # struct
    infos : Pointer(LibGio::FileAttributeInfo)
    n_infos : Int32
  end

  fun _g_file_attribute_info_list_get_type = g_file_attribute_info_list_get_type : UInt64
  fun file_attribute_info_list_new = g_file_attribute_info_list_new : Pointer(LibGio::FileAttributeInfoList)
  fun file_attribute_info_list_add = g_file_attribute_info_list_add(this : FileAttributeInfoList*, name : Pointer(UInt8), type : LibGio::FileAttributeType, flags : LibGio::FileAttributeInfoFlags) : Void
  fun file_attribute_info_list_dup = g_file_attribute_info_list_dup(this : FileAttributeInfoList*) : Pointer(LibGio::FileAttributeInfoList)
  fun file_attribute_info_list_lookup = g_file_attribute_info_list_lookup(this : FileAttributeInfoList*, name : Pointer(UInt8)) : Pointer(LibGio::FileAttributeInfo)
  fun file_attribute_info_list_ref = g_file_attribute_info_list_ref(this : FileAttributeInfoList*) : Pointer(LibGio::FileAttributeInfoList)
  fun file_attribute_info_list_unref = g_file_attribute_info_list_unref(this : FileAttributeInfoList*) : Void

  struct FileAttributeMatcher # struct
    _data : UInt8[0]
  end

  fun _g_file_attribute_matcher_get_type = g_file_attribute_matcher_get_type : UInt64
  fun file_attribute_matcher_new = g_file_attribute_matcher_new(attributes : Pointer(UInt8)) : Pointer(LibGio::FileAttributeMatcher)
  fun file_attribute_matcher_enumerate_namespace = g_file_attribute_matcher_enumerate_namespace(this : FileAttributeMatcher*, ns : Pointer(UInt8)) : LibC::Int
  fun file_attribute_matcher_enumerate_next = g_file_attribute_matcher_enumerate_next(this : FileAttributeMatcher*) : Pointer(UInt8)
  fun file_attribute_matcher_matches = g_file_attribute_matcher_matches(this : FileAttributeMatcher*, attribute : Pointer(UInt8)) : LibC::Int
  fun file_attribute_matcher_matches_only = g_file_attribute_matcher_matches_only(this : FileAttributeMatcher*, attribute : Pointer(UInt8)) : LibC::Int
  fun file_attribute_matcher_ref = g_file_attribute_matcher_ref(this : FileAttributeMatcher*) : Pointer(LibGio::FileAttributeMatcher)
  fun file_attribute_matcher_subtract = g_file_attribute_matcher_subtract(this : FileAttributeMatcher*, subtract : Pointer(LibGio::FileAttributeMatcher)) : Pointer(LibGio::FileAttributeMatcher)
  fun file_attribute_matcher_to_string = g_file_attribute_matcher_to_string(this : FileAttributeMatcher*) : Pointer(UInt8)
  fun file_attribute_matcher_unref = g_file_attribute_matcher_unref(this : FileAttributeMatcher*) : Void

  struct FileDescriptorBasedIface # struct
    g_iface : LibGObject::TypeInterface
    get_fd : Pointer(LibGio::FileDescriptorBased) -> Int32
  end

  struct FileEnumeratorClass # struct
    parent_class : LibGObject::ObjectClass
    next_file : Pointer(LibGio::FileEnumerator), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    close_fn : Pointer(LibGio::FileEnumerator), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    next_files_async : Pointer(LibGio::FileEnumerator), Int32, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    next_files_finish : Pointer(LibGio::FileEnumerator), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    close_async : Pointer(LibGio::FileEnumerator), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    close_finish : Pointer(LibGio::FileEnumerator), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
  end

  struct FileEnumeratorPrivate # struct
    _data : UInt8[0]
  end

  struct FileIOStreamClass # struct
    parent_class : LibGio::IOStreamClass
    tell : Pointer(LibGio::FileIOStream) -> Int64
    can_seek : Pointer(LibGio::FileIOStream) -> LibC::Int
    seek : Pointer(LibGio::FileIOStream), Int64, LibGLib::SeekType, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_truncate : Pointer(LibGio::FileIOStream) -> LibC::Int
    truncate_fn : Pointer(LibGio::FileIOStream), Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    query_info : Pointer(LibGio::FileIOStream), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_info_async : Pointer(LibGio::FileIOStream), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_info_finish : Pointer(LibGio::FileIOStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    get_etag : Pointer(LibGio::FileIOStream) -> Pointer(UInt8)
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct FileIOStreamPrivate # struct
    _data : UInt8[0]
  end

  struct FileIconClass # struct
    _data : UInt8[0]
  end

  struct FileIface # struct
    g_iface : LibGObject::TypeInterface
    dup : Pointer(LibGio::File) -> Pointer(LibGio::File)
    hash : Pointer(LibGio::File) -> UInt32
    equal : Pointer(LibGio::File), Pointer(LibGio::File) -> LibC::Int
    is_native : Pointer(LibGio::File) -> LibC::Int
    has_uri_scheme : Pointer(LibGio::File), Pointer(UInt8) -> LibC::Int
    get_uri_scheme : Pointer(LibGio::File) -> Pointer(UInt8)
    get_basename : Pointer(LibGio::File) -> Pointer(UInt8)
    get_path : Pointer(LibGio::File) -> Pointer(UInt8)
    get_uri : Pointer(LibGio::File) -> Pointer(UInt8)
    get_parse_name : Pointer(LibGio::File) -> Pointer(UInt8)
    get_parent : Pointer(LibGio::File) -> Pointer(LibGio::File)
    prefix_matches : Pointer(LibGio::File), Pointer(LibGio::File) -> LibC::Int
    get_relative_path : Pointer(LibGio::File), Pointer(LibGio::File) -> Pointer(UInt8)
    resolve_relative_path : Pointer(LibGio::File), Pointer(UInt8) -> Pointer(LibGio::File)
    get_child_for_display_name : Pointer(LibGio::File), Pointer(UInt8), LibGLib::Error* -> Pointer(LibGio::File)
    enumerate_children : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileEnumerator)
    enumerate_children_async : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    enumerate_children_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileEnumerator)
    query_info : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_info_async : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_info_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_filesystem_info : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_filesystem_info_async : Pointer(LibGio::File), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_filesystem_info_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    find_enclosing_mount : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::Mount)
    find_enclosing_mount_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    find_enclosing_mount_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::Mount)
    set_display_name : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::File)
    set_display_name_async : Pointer(LibGio::File), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    set_display_name_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::File)
    query_settable_attributes : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileAttributeInfoList)
    _query_settable_attributes_async : Pointer(Void)
    _query_settable_attributes_finish : Pointer(Void)
    query_writable_namespaces : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileAttributeInfoList)
    _query_writable_namespaces_async : Pointer(Void)
    _query_writable_namespaces_finish : Pointer(Void)
    set_attribute : Pointer(LibGio::File), Pointer(UInt8), LibGio::FileAttributeType, Pointer(Void), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    set_attributes_from_info : Pointer(LibGio::File), Pointer(LibGio::FileInfo), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    set_attributes_async : Pointer(LibGio::File), Pointer(LibGio::FileInfo), LibGio::FileQueryInfoFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    set_attributes_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), Pointer(LibGio::FileInfo), LibGLib::Error* -> LibC::Int
    read_fn : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInputStream)
    read_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    read_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInputStream)
    append_to : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    append_to_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    append_to_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    create : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    create_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    create_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    replace : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    replace_async : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    replace_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileOutputStream)
    delete_file : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    delete_file_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    delete_file_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    trash : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    trash_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    trash_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    make_directory : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    make_directory_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    make_directory_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    make_symbolic_link : Pointer(LibGio::File), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    _make_symbolic_link_async : Pointer(Void)
    _make_symbolic_link_finish : Pointer(Void)
    copy : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGLib::Error* -> LibC::Int
    copy_async : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Int32, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    copy_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    move : Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileCopyFlags, Pointer(LibGio::Cancellable), LibGio::FileProgressCallback, Pointer(Void), LibGLib::Error* -> LibC::Int
    _move_async : Pointer(Void)
    _move_finish : Pointer(Void)
    mount_mountable : Pointer(LibGio::File), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::File)
    unmount_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    mount_enclosing_volume : Pointer(LibGio::File), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_enclosing_volume_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    monitor_dir : Pointer(LibGio::File), LibGio::FileMonitorFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileMonitor)
    monitor_file : Pointer(LibGio::File), LibGio::FileMonitorFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileMonitor)
    open_readwrite : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    open_readwrite_async : Pointer(LibGio::File), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    open_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    create_readwrite : Pointer(LibGio::File), LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    create_readwrite_async : Pointer(LibGio::File), LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    create_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    replace_readwrite : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    replace_readwrite_async : Pointer(LibGio::File), Pointer(UInt8), LibC::Int, LibGio::FileCreateFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    replace_readwrite_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileIOStream)
    start_mountable : Pointer(LibGio::File), LibGio::DriveStartFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    start_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    stop_mountable : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    stop_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    supports_thread_contexts : LibC::Int
    unmount_mountable_with_operation : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_mountable_with_operation_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_mountable_with_operation : Pointer(LibGio::File), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_mountable_with_operation_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    poll_mountable : Pointer(LibGio::File), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    poll_mountable_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    measure_disk_usage : Pointer(Void)
    measure_disk_usage_async : Pointer(Void)
    measure_disk_usage_finish : Pointer(LibGio::File), Pointer(LibGio::AsyncResult), UInt64, UInt64, UInt64, LibGLib::Error* -> LibC::Int
  end

  struct FileInfoClass # struct
    _data : UInt8[0]
  end

  struct FileInputStreamClass # struct
    parent_class : LibGio::InputStreamClass
    tell : Pointer(LibGio::FileInputStream) -> Int64
    can_seek : Pointer(LibGio::FileInputStream) -> LibC::Int
    seek : Pointer(LibGio::FileInputStream), Int64, LibGLib::SeekType, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    query_info : Pointer(LibGio::FileInputStream), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_info_async : Pointer(LibGio::FileInputStream), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_info_finish : Pointer(LibGio::FileInputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct FileInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct FileMonitorClass # struct
    parent_class : LibGObject::ObjectClass
    changed : Pointer(LibGio::FileMonitor), Pointer(LibGio::File), Pointer(LibGio::File), LibGio::FileMonitorEvent -> Void
    cancel : Pointer(LibGio::FileMonitor) -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct FileMonitorPrivate # struct
    _data : UInt8[0]
  end

  struct FileOutputStreamClass # struct
    parent_class : LibGio::OutputStreamClass
    tell : Pointer(LibGio::FileOutputStream) -> Int64
    can_seek : Pointer(LibGio::FileOutputStream) -> LibC::Int
    seek : Pointer(LibGio::FileOutputStream), Int64, LibGLib::SeekType, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_truncate : Pointer(LibGio::FileOutputStream) -> LibC::Int
    truncate_fn : Pointer(LibGio::FileOutputStream), Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    query_info : Pointer(LibGio::FileOutputStream), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    query_info_async : Pointer(LibGio::FileOutputStream), Pointer(UInt8), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    query_info_finish : Pointer(LibGio::FileOutputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::FileInfo)
    get_etag : Pointer(LibGio::FileOutputStream) -> Pointer(UInt8)
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct FileOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct FilenameCompleterClass # struct
    parent_class : LibGObject::ObjectClass
    got_completion_data : Pointer(LibGio::FilenameCompleter) -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
  end

  struct FilterInputStreamClass # struct
    parent_class : LibGio::InputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
  end

  struct FilterOutputStreamClass # struct
    parent_class : LibGio::OutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
  end

  struct IOExtension # struct
    _data : UInt8[0]
  end

  fun i_o_extension_get_name = g_io_extension_get_name(this : IOExtension*) : Pointer(UInt8)
  fun i_o_extension_get_priority = g_io_extension_get_priority(this : IOExtension*) : Int32
  fun i_o_extension_get_type = g_io_extension_get_type(this : IOExtension*) : UInt64

  struct IOExtensionPoint # struct
    _data : UInt8[0]
  end

  fun i_o_extension_point_get_extension_by_name = g_io_extension_point_get_extension_by_name(this : IOExtensionPoint*, name : Pointer(UInt8)) : Pointer(LibGio::IOExtension)
  fun i_o_extension_point_get_extensions = g_io_extension_point_get_extensions(this : IOExtensionPoint*) : Pointer(Void*)
  fun i_o_extension_point_get_required_type = g_io_extension_point_get_required_type(this : IOExtensionPoint*) : UInt64
  fun i_o_extension_point_set_required_type = g_io_extension_point_set_required_type(this : IOExtensionPoint*, type : UInt64) : Void
  fun i_o_extension_point_implement = g_io_extension_point_implement(extension_point_name : Pointer(UInt8), type : UInt64, extension_name : Pointer(UInt8), priority : Int32) : Pointer(LibGio::IOExtension)
  fun i_o_extension_point_lookup = g_io_extension_point_lookup(name : Pointer(UInt8)) : Pointer(LibGio::IOExtensionPoint)
  fun i_o_extension_point_register = g_io_extension_point_register(name : Pointer(UInt8)) : Pointer(LibGio::IOExtensionPoint)

  struct IOModuleClass # struct
    _data : UInt8[0]
  end

  struct IOModuleScope # struct
    _data : UInt8[0]
  end

  fun i_o_module_scope_block = g_io_module_scope_block(this : IOModuleScope*, basename : Pointer(UInt8)) : Void
  fun i_o_module_scope_free = g_io_module_scope_free(this : IOModuleScope*) : Void

  struct IOSchedulerJob # struct
    _data : UInt8[0]
  end

  fun i_o_scheduler_job_send_to_mainloop = g_io_scheduler_job_send_to_mainloop(this : IOSchedulerJob*, func : LibGLib::SourceFunc, user_data : Pointer(Void), notify : LibGLib::DestroyNotify) : LibC::Int
  fun i_o_scheduler_job_send_to_mainloop_async = g_io_scheduler_job_send_to_mainloop_async(this : IOSchedulerJob*, func : LibGLib::SourceFunc, user_data : Pointer(Void), notify : LibGLib::DestroyNotify) : Void

  struct IOStreamAdapter # struct
    _data : UInt8[0]
  end

  struct IOStreamClass # struct
    parent_class : LibGObject::ObjectClass
    get_input_stream : Pointer(LibGio::IOStream) -> Pointer(LibGio::InputStream)
    get_output_stream : Pointer(LibGio::IOStream) -> Pointer(LibGio::OutputStream)
    close_fn : Pointer(LibGio::IOStream), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    close_async : Pointer(LibGio::IOStream), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    close_finish : Pointer(LibGio::IOStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
    _g_reserved8 : Pointer(Void)
    _g_reserved9 : Pointer(Void)
    _g_reserved10 : Pointer(Void)
  end

  struct IOStreamPrivate # struct
    _data : UInt8[0]
  end

  struct IconIface # struct
    g_iface : LibGObject::TypeInterface
    hash : Pointer(LibGio::Icon) -> UInt32
    equal : Pointer(LibGio::Icon), Pointer(LibGio::Icon) -> LibC::Int
    to_tokens : Pointer(Void)
    from_tokens : Pointer(Void)
    serialize : Pointer(LibGio::Icon) -> Pointer(LibGLib::Variant)
  end

  struct InetAddressClass # struct
    parent_class : LibGObject::ObjectClass
    to_string : Pointer(LibGio::InetAddress) -> Pointer(UInt8)
    to_bytes : Pointer(LibGio::InetAddress) -> Pointer(UInt8)
  end

  struct InetAddressMaskClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct InetAddressMaskPrivate # struct
    _data : UInt8[0]
  end

  struct InetAddressPrivate # struct
    _data : UInt8[0]
  end

  struct InetSocketAddressClass # struct
    parent_class : LibGio::SocketAddressClass
  end

  struct InetSocketAddressPrivate # struct
    _data : UInt8[0]
  end

  struct InitableIface # struct
    g_iface : LibGObject::TypeInterface
    init : Pointer(LibGio::Initable), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
  end

  struct InputMessage # struct
    address : Pointer(LibGio::SocketAddress)
    vectors : Pointer(LibGio::InputVector)
    num_vectors : UInt32
    bytes_received : UInt64
    flags : Int32
    control_messages : Pointer(Pointer(LibGio::SocketControlMessage))
    num_control_messages : Pointer(UInt32)
  end

  struct InputStreamClass # struct
    parent_class : LibGObject::ObjectClass
    read_fn : Pointer(LibGio::InputStream), Pointer(Void), UInt64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int64
    skip : Pointer(LibGio::InputStream), UInt64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int64
    close_fn : Pointer(LibGio::InputStream), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    read_async : Pointer(LibGio::InputStream), Pointer(UInt8), UInt64, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    read_finish : Pointer(LibGio::InputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Int64
    skip_async : Pointer(LibGio::InputStream), UInt64, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    skip_finish : Pointer(LibGio::InputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Int64
    close_async : Pointer(LibGio::InputStream), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    close_finish : Pointer(LibGio::InputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct InputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct InputVector # struct
    buffer : Pointer(Void)
    size : UInt64
  end

  struct ListModelInterface # struct
    g_iface : LibGObject::TypeInterface
    get_item_type : Pointer(LibGio::ListModel) -> UInt64
    get_n_items : Pointer(LibGio::ListModel) -> UInt32
    get_item : Pointer(LibGio::ListModel), UInt32 -> Pointer(LibGObject::Object)
  end

  struct ListStoreClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct LoadableIconIface # struct
    g_iface : LibGObject::TypeInterface
    load : Pointer(LibGio::LoadableIcon), Int32, Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::InputStream)
    load_async : Pointer(LibGio::LoadableIcon), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    load_finish : Pointer(LibGio::LoadableIcon), Pointer(LibGio::AsyncResult), Pointer(UInt8), LibGLib::Error* -> Pointer(LibGio::InputStream)
  end

  struct MemoryInputStreamClass # struct
    parent_class : LibGio::InputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct MemoryInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct MemoryMonitorInterface # struct
    g_iface : LibGObject::TypeInterface
    low_memory_warning : Pointer(LibGio::MemoryMonitor), LibGio::MemoryMonitorWarningLevel -> Void
  end

  struct MemoryOutputStreamClass # struct
    parent_class : LibGio::OutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct MemoryOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct MenuAttributeIterClass # struct
    parent_class : LibGObject::ObjectClass
    get_next : Pointer(LibGio::MenuAttributeIter), Pointer(UInt8), Pointer(LibGLib::Variant) -> LibC::Int
  end

  struct MenuAttributeIterPrivate # struct
    _data : UInt8[0]
  end

  struct MenuLinkIterClass # struct
    parent_class : LibGObject::ObjectClass
    get_next : Pointer(LibGio::MenuLinkIter), Pointer(UInt8), Pointer(LibGio::MenuModel) -> LibC::Int
  end

  struct MenuLinkIterPrivate # struct
    _data : UInt8[0]
  end

  struct MenuModelClass # struct
    parent_class : LibGObject::ObjectClass
    is_mutable : Pointer(LibGio::MenuModel) -> LibC::Int
    get_n_items : Pointer(LibGio::MenuModel) -> Int32
    get_item_attributes : Pointer(LibGio::MenuModel), Int32, Pointer(Void*) -> Void
    iterate_item_attributes : Pointer(LibGio::MenuModel), Int32 -> Pointer(LibGio::MenuAttributeIter)
    get_item_attribute_value : Pointer(LibGio::MenuModel), Int32, Pointer(UInt8), Pointer(LibGLib::VariantType) -> Pointer(LibGLib::Variant)
    get_item_links : Pointer(LibGio::MenuModel), Int32, Pointer(Void*) -> Void
    iterate_item_links : Pointer(LibGio::MenuModel), Int32 -> Pointer(LibGio::MenuLinkIter)
    get_item_link : Pointer(LibGio::MenuModel), Int32, Pointer(UInt8) -> Pointer(LibGio::MenuModel)
  end

  struct MenuModelPrivate # struct
    _data : UInt8[0]
  end

  struct MountIface # struct
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Mount) -> Void
    unmounted : Pointer(LibGio::Mount) -> Void
    get_root : Pointer(LibGio::Mount) -> Pointer(LibGio::File)
    get_name : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Mount) -> Pointer(LibGio::Icon)
    get_uuid : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_volume : Pointer(LibGio::Mount) -> Pointer(LibGio::Volume)
    get_drive : Pointer(LibGio::Mount) -> Pointer(LibGio::Drive)
    can_unmount : Pointer(LibGio::Mount) -> LibC::Int
    can_eject : Pointer(LibGio::Mount) -> LibC::Int
    unmount : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    remount : Pointer(LibGio::Mount), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    remount_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    guess_content_type : Pointer(LibGio::Mount), LibC::Int, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    guess_content_type_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Pointer(UInt8))
    guess_content_type_sync : Pointer(LibGio::Mount), LibC::Int, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Pointer(UInt8))
    pre_unmount : Pointer(LibGio::Mount) -> Void
    unmount_with_operation : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    unmount_with_operation_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject_with_operation : Pointer(LibGio::Mount), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Mount), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_default_location : Pointer(LibGio::Mount) -> Pointer(LibGio::File)
    get_sort_key : Pointer(LibGio::Mount) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Mount) -> Pointer(LibGio::Icon)
  end

  struct MountOperationClass # struct
    parent_class : LibGObject::ObjectClass
    ask_password : Pointer(LibGio::MountOperation), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), LibGio::AskPasswordFlags -> Void
    ask_question : Pointer(LibGio::MountOperation), Pointer(UInt8), Pointer(Pointer(UInt8)) -> Void
    reply : Pointer(LibGio::MountOperation), LibGio::MountOperationResult -> Void
    aborted : Pointer(LibGio::MountOperation) -> Void
    show_processes : Pointer(LibGio::MountOperation), Pointer(UInt8), Pointer(Void), Pointer(Pointer(UInt8)) -> Void
    show_unmount_progress : Pointer(LibGio::MountOperation), Pointer(UInt8), Int64, Int64 -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
    _g_reserved8 : Pointer(Void)
    _g_reserved9 : Pointer(Void)
  end

  struct MountOperationPrivate # struct
    _data : UInt8[0]
  end

  struct NativeSocketAddressClass # struct
    parent_class : LibGio::SocketAddressClass
  end

  struct NativeSocketAddressPrivate # struct
    _data : UInt8[0]
  end

  struct NativeVolumeMonitorClass # struct
    parent_class : LibGio::VolumeMonitorClass
    get_mount_for_mount_path : Pointer(Void)
  end

  struct NetworkAddressClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct NetworkAddressPrivate # struct
    _data : UInt8[0]
  end

  struct NetworkMonitorInterface # struct
    g_iface : LibGObject::TypeInterface
    network_changed : Pointer(LibGio::NetworkMonitor), LibC::Int -> Void
    can_reach : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::SocketConnectable), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_reach_async : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::SocketConnectable), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    can_reach_finish : Pointer(LibGio::NetworkMonitor), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
  end

  struct NetworkServiceClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct NetworkServicePrivate # struct
    _data : UInt8[0]
  end

  struct OutputMessage # struct
    address : Pointer(LibGio::SocketAddress)
    vectors : Pointer(LibGio::OutputVector)
    num_vectors : UInt32
    bytes_sent : UInt32
    control_messages : Pointer(Pointer(LibGio::SocketControlMessage))
    num_control_messages : UInt32
  end

  struct OutputStreamClass # struct
    parent_class : LibGObject::ObjectClass
    write_fn : Pointer(LibGio::OutputStream), Pointer(UInt8), UInt64, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int64
    splice : Pointer(LibGio::OutputStream), Pointer(LibGio::InputStream), LibGio::OutputStreamSpliceFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Int64
    flush : Pointer(LibGio::OutputStream), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    close_fn : Pointer(LibGio::OutputStream), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    write_async : Pointer(LibGio::OutputStream), Pointer(UInt8), UInt64, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    write_finish : Pointer(LibGio::OutputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Int64
    splice_async : Pointer(LibGio::OutputStream), Pointer(LibGio::InputStream), LibGio::OutputStreamSpliceFlags, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    splice_finish : Pointer(LibGio::OutputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Int64
    flush_async : Pointer(LibGio::OutputStream), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    flush_finish : Pointer(LibGio::OutputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    close_async : Pointer(LibGio::OutputStream), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    close_finish : Pointer(LibGio::OutputStream), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    writev_fn : Pointer(LibGio::OutputStream), Pointer(LibGio::OutputVector), UInt64, UInt64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    writev_async : Pointer(LibGio::OutputStream), Pointer(LibGio::OutputVector), UInt64, Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    writev_finish : Pointer(LibGio::OutputStream), Pointer(LibGio::AsyncResult), UInt64, LibGLib::Error* -> LibC::Int
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
    _g_reserved8 : Pointer(Void)
  end

  struct OutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct OutputVector # struct
    buffer : Pointer(Void)
    size : UInt64
  end

  struct PermissionClass # struct
    parent_class : LibGObject::ObjectClass
    acquire : Pointer(LibGio::Permission), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    acquire_async : Pointer(LibGio::Permission), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    acquire_finish : Pointer(LibGio::Permission), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    release : Pointer(LibGio::Permission), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    release_async : Pointer(LibGio::Permission), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    release_finish : Pointer(LibGio::Permission), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    reserved : Pointer(Void)[16]
  end

  struct PermissionPrivate # struct
    _data : UInt8[0]
  end

  struct PollableInputStreamInterface # struct
    g_iface : LibGObject::TypeInterface
    can_poll : Pointer(LibGio::PollableInputStream) -> LibC::Int
    is_readable : Pointer(LibGio::PollableInputStream) -> LibC::Int
    create_source : Pointer(LibGio::PollableInputStream), Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    read_nonblocking : Pointer(LibGio::PollableInputStream), Pointer(UInt8), UInt64, LibGLib::Error* -> Int64
  end

  struct PollableOutputStreamInterface # struct
    g_iface : LibGObject::TypeInterface
    can_poll : Pointer(LibGio::PollableOutputStream) -> LibC::Int
    is_writable : Pointer(LibGio::PollableOutputStream) -> LibC::Int
    create_source : Pointer(LibGio::PollableOutputStream), Pointer(LibGio::Cancellable) -> Pointer(LibGLib::Source)
    write_nonblocking : Pointer(LibGio::PollableOutputStream), Pointer(UInt8), UInt64, LibGLib::Error* -> Int64
    writev_nonblocking : Pointer(LibGio::PollableOutputStream), Pointer(LibGio::OutputVector), UInt64, UInt64, LibGLib::Error* -> LibGio::PollableReturn
  end

  struct ProxyAddressClass # struct
    parent_class : LibGio::InetSocketAddressClass
  end

  struct ProxyAddressEnumeratorClass # struct
    parent_class : LibGio::SocketAddressEnumeratorClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
  end

  struct ProxyAddressEnumeratorPrivate # struct
    _data : UInt8[0]
  end

  struct ProxyAddressPrivate # struct
    _data : UInt8[0]
  end

  struct ProxyInterface # struct
    g_iface : LibGObject::TypeInterface
    connect : Pointer(LibGio::Proxy), Pointer(LibGio::IOStream), Pointer(LibGio::ProxyAddress), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::IOStream)
    connect_async : Pointer(LibGio::Proxy), Pointer(LibGio::IOStream), Pointer(LibGio::ProxyAddress), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    connect_finish : Pointer(LibGio::Proxy), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::IOStream)
    supports_hostname : Pointer(LibGio::Proxy) -> LibC::Int
  end

  struct ProxyResolverInterface # struct
    g_iface : LibGObject::TypeInterface
    is_supported : Pointer(LibGio::ProxyResolver) -> LibC::Int
    lookup : Pointer(LibGio::ProxyResolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Pointer(UInt8))
    lookup_async : Pointer(LibGio::ProxyResolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_finish : Pointer(LibGio::ProxyResolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Pointer(UInt8))
  end

  struct RemoteActionGroupInterface # struct
    g_iface : LibGObject::TypeInterface
    activate_action_full : Pointer(LibGio::RemoteActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> Void
    change_action_state_full : Pointer(LibGio::RemoteActionGroup), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGLib::Variant) -> Void
  end

  struct ResolverClass # struct
    parent_class : LibGObject::ObjectClass
    reload : Pointer(LibGio::Resolver) -> Void
    lookup_by_name : Pointer(LibGio::Resolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Void*)
    lookup_by_name_async : Pointer(LibGio::Resolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_by_name_finish : Pointer(LibGio::Resolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    lookup_by_address : Pointer(LibGio::Resolver), Pointer(LibGio::InetAddress), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(UInt8)
    lookup_by_address_async : Pointer(LibGio::Resolver), Pointer(LibGio::InetAddress), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_by_address_finish : Pointer(LibGio::Resolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(UInt8)
    lookup_service : Pointer(Void)
    lookup_service_async : Pointer(LibGio::Resolver), Pointer(UInt8), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_service_finish : Pointer(LibGio::Resolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    lookup_records : Pointer(LibGio::Resolver), Pointer(UInt8), LibGio::ResolverRecordType, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Void*)
    lookup_records_async : Pointer(LibGio::Resolver), Pointer(UInt8), LibGio::ResolverRecordType, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_records_finish : Pointer(LibGio::Resolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    lookup_by_name_with_flags_async : Pointer(LibGio::Resolver), Pointer(UInt8), LibGio::ResolverNameLookupFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_by_name_with_flags_finish : Pointer(LibGio::Resolver), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    lookup_by_name_with_flags : Pointer(LibGio::Resolver), Pointer(UInt8), LibGio::ResolverNameLookupFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Void*)
  end

  struct ResolverPrivate # struct
    _data : UInt8[0]
  end

  struct Resource # struct
    _data : UInt8[0]
  end

  fun _g_resource_get_type = g_resource_get_type : UInt64
  fun resource_new_from_data = g_resource_new_from_data(data : Pointer(LibGLib::Bytes), error : LibGLib::Error**) : Pointer(LibGio::Resource)
  fun resource_register = g_resources_register(this : Resource*) : Void
  fun resource_unregister = g_resources_unregister(this : Resource*) : Void
  fun resource_enumerate_children = g_resource_enumerate_children(this : Resource*, path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(Pointer(UInt8))
  fun resource_get_info = g_resource_get_info(this : Resource*, path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, size : UInt64*, flags : UInt32*, error : LibGLib::Error**) : LibC::Int
  fun resource_lookup_data = g_resource_lookup_data(this : Resource*, path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun resource_open_stream = g_resource_open_stream(this : Resource*, path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(LibGio::InputStream)
  fun resource_ref = g_resource_ref(this : Resource*) : Pointer(LibGio::Resource)
  fun resource_unref = g_resource_unref(this : Resource*) : Void
  fun resource_load = g_resource_load(filename : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::Resource)

  struct SeekableIface # struct
    g_iface : LibGObject::TypeInterface
    tell : Pointer(LibGio::Seekable) -> Int64
    can_seek : Pointer(LibGio::Seekable) -> LibC::Int
    seek : Pointer(LibGio::Seekable), Int64, LibGLib::SeekType, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    can_truncate : Pointer(LibGio::Seekable) -> LibC::Int
    truncate_fn : Pointer(LibGio::Seekable), Int64, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
  end

  struct SettingsBackendClass # struct
    parent_class : LibGObject::ObjectClass
    read : Pointer(LibGio::SettingsBackend), Pointer(UInt8), Pointer(LibGLib::VariantType), LibC::Int -> Pointer(LibGLib::Variant)
    get_writable : Pointer(LibGio::SettingsBackend), Pointer(UInt8) -> LibC::Int
    write : Pointer(LibGio::SettingsBackend), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(Void) -> LibC::Int
    write_tree : Pointer(LibGio::SettingsBackend), Pointer(LibGLib::Tree), Pointer(Void) -> LibC::Int
    reset : Pointer(LibGio::SettingsBackend), Pointer(UInt8), Pointer(Void) -> Void
    subscribe : Pointer(LibGio::SettingsBackend), Pointer(UInt8) -> Void
    unsubscribe : Pointer(LibGio::SettingsBackend), Pointer(UInt8) -> Void
    sync : Pointer(LibGio::SettingsBackend) -> Void
    get_permission : Pointer(Void)
    read_user_value : Pointer(LibGio::SettingsBackend), Pointer(UInt8), Pointer(LibGLib::VariantType) -> Pointer(LibGLib::Variant)
    padding : Pointer(Void)[23]
  end

  struct SettingsBackendPrivate # struct
    _data : UInt8[0]
  end

  struct SettingsClass # struct
    parent_class : LibGObject::ObjectClass
    writable_changed : Pointer(LibGio::Settings), Pointer(UInt8) -> Void
    changed : Pointer(LibGio::Settings), Pointer(UInt8) -> Void
    writable_change_event : Pointer(LibGio::Settings), UInt32 -> LibC::Int
    change_event : Pointer(LibGio::Settings), Pointer(UInt32), Int32 -> LibC::Int
    padding : Pointer(Void)[20]
  end

  struct SettingsPrivate # struct
    _data : UInt8[0]
  end

  struct SettingsSchema # struct
    _data : UInt8[0]
  end

  fun _g_settings_schema_get_type = g_settings_schema_get_type : UInt64
  fun settings_schema_get_id = g_settings_schema_get_id(this : SettingsSchema*) : Pointer(UInt8)
  fun settings_schema_get_key = g_settings_schema_get_key(this : SettingsSchema*, name : Pointer(UInt8)) : Pointer(LibGio::SettingsSchemaKey)
  fun settings_schema_get_path = g_settings_schema_get_path(this : SettingsSchema*) : Pointer(UInt8)
  fun settings_schema_has_key = g_settings_schema_has_key(this : SettingsSchema*, name : Pointer(UInt8)) : LibC::Int
  fun settings_schema_list_children = g_settings_schema_list_children(this : SettingsSchema*) : Pointer(Pointer(UInt8))
  fun settings_schema_list_keys = g_settings_schema_list_keys(this : SettingsSchema*) : Pointer(Pointer(UInt8))
  fun settings_schema_ref = g_settings_schema_ref(this : SettingsSchema*) : Pointer(LibGio::SettingsSchema)
  fun settings_schema_unref = g_settings_schema_unref(this : SettingsSchema*) : Void

  struct SettingsSchemaKey # struct
    _data : UInt8[0]
  end

  fun _g_settings_schema_key_get_type = g_settings_schema_key_get_type : UInt64
  fun settings_schema_key_get_default_value = g_settings_schema_key_get_default_value(this : SettingsSchemaKey*) : Pointer(LibGLib::Variant)
  fun settings_schema_key_get_description = g_settings_schema_key_get_description(this : SettingsSchemaKey*) : Pointer(UInt8)
  fun settings_schema_key_get_name = g_settings_schema_key_get_name(this : SettingsSchemaKey*) : Pointer(UInt8)
  fun settings_schema_key_get_range = g_settings_schema_key_get_range(this : SettingsSchemaKey*) : Pointer(LibGLib::Variant)
  fun settings_schema_key_get_summary = g_settings_schema_key_get_summary(this : SettingsSchemaKey*) : Pointer(UInt8)
  fun settings_schema_key_get_value_type = g_settings_schema_key_get_value_type(this : SettingsSchemaKey*) : Pointer(LibGLib::VariantType)
  fun settings_schema_key_range_check = g_settings_schema_key_range_check(this : SettingsSchemaKey*, value : Pointer(LibGLib::Variant)) : LibC::Int
  fun settings_schema_key_ref = g_settings_schema_key_ref(this : SettingsSchemaKey*) : Pointer(LibGio::SettingsSchemaKey)
  fun settings_schema_key_unref = g_settings_schema_key_unref(this : SettingsSchemaKey*) : Void

  struct SettingsSchemaSource # struct
    _data : UInt8[0]
  end

  fun _g_settings_schema_source_get_type = g_settings_schema_source_get_type : UInt64
  fun settings_schema_source_new_from_directory = g_settings_schema_source_new_from_directory(directory : Pointer(UInt8), parent : Pointer(LibGio::SettingsSchemaSource), trusted : LibC::Int, error : LibGLib::Error**) : Pointer(LibGio::SettingsSchemaSource)
  fun settings_schema_source_list_schemas = g_settings_schema_source_list_schemas(this : SettingsSchemaSource*, recursive : LibC::Int, non_relocatable : Pointer(Pointer(UInt8))*, relocatable : Pointer(Pointer(UInt8))*) : Void
  fun settings_schema_source_lookup = g_settings_schema_source_lookup(this : SettingsSchemaSource*, schema_id : Pointer(UInt8), recursive : LibC::Int) : Pointer(LibGio::SettingsSchema)
  fun settings_schema_source_ref = g_settings_schema_source_ref(this : SettingsSchemaSource*) : Pointer(LibGio::SettingsSchemaSource)
  fun settings_schema_source_unref = g_settings_schema_source_unref(this : SettingsSchemaSource*) : Void
  fun settings_schema_source_get_default = g_settings_schema_source_get_default : Pointer(LibGio::SettingsSchemaSource)

  struct SimpleActionGroupClass # struct
    parent_class : LibGObject::ObjectClass
    padding : Pointer(Void)[12]
  end

  struct SimpleActionGroupPrivate # struct
    _data : UInt8[0]
  end

  struct SimpleAsyncResultClass # struct
    _data : UInt8[0]
  end

  struct SimpleProxyResolverClass # struct
    parent_class : LibGObject::ObjectClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct SimpleProxyResolverPrivate # struct
    _data : UInt8[0]
  end

  struct SocketAddressClass # struct
    parent_class : LibGObject::ObjectClass
    get_family : Pointer(LibGio::SocketAddress) -> LibGio::SocketFamily
    get_native_size : Pointer(LibGio::SocketAddress) -> Int64
    to_native : Pointer(LibGio::SocketAddress), Pointer(Void), UInt64, LibGLib::Error* -> LibC::Int
  end

  struct SocketAddressEnumeratorClass # struct
    parent_class : LibGObject::ObjectClass
    _next : Pointer(LibGio::SocketAddressEnumerator), Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::SocketAddress)
    next_async : Pointer(LibGio::SocketAddressEnumerator), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    next_finish : Pointer(LibGio::SocketAddressEnumerator), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::SocketAddress)
  end

  struct SocketClass # struct
    parent_class : LibGObject::ObjectClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
    _g_reserved7 : Pointer(Void)
    _g_reserved8 : Pointer(Void)
    _g_reserved9 : Pointer(Void)
    _g_reserved10 : Pointer(Void)
  end

  struct SocketClientClass # struct
    parent_class : LibGObject::ObjectClass
    event : Pointer(LibGio::SocketClient), LibGio::SocketClientEvent, Pointer(LibGio::SocketConnectable), Pointer(LibGio::IOStream) -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
  end

  struct SocketClientPrivate # struct
    _data : UInt8[0]
  end

  struct SocketConnectableIface # struct
    g_iface : LibGObject::TypeInterface
    enumerate : Pointer(LibGio::SocketConnectable) -> Pointer(LibGio::SocketAddressEnumerator)
    proxy_enumerate : Pointer(LibGio::SocketConnectable) -> Pointer(LibGio::SocketAddressEnumerator)
    to_string : Pointer(LibGio::SocketConnectable) -> Pointer(UInt8)
  end

  struct SocketConnectionClass # struct
    parent_class : LibGio::IOStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
  end

  struct SocketConnectionPrivate # struct
    _data : UInt8[0]
  end

  struct SocketControlMessageClass # struct
    parent_class : LibGObject::ObjectClass
    get_size : Pointer(LibGio::SocketControlMessage) -> UInt64
    get_level : Pointer(LibGio::SocketControlMessage) -> Int32
    get_type : Pointer(LibGio::SocketControlMessage) -> Int32
    serialize : Pointer(LibGio::SocketControlMessage), Pointer(Void) -> Void
    deserialize : Pointer(Void)
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct SocketControlMessagePrivate # struct
    _data : UInt8[0]
  end

  struct SocketListenerClass # struct
    parent_class : LibGObject::ObjectClass
    changed : Pointer(LibGio::SocketListener) -> Void
    event : Pointer(LibGio::SocketListener), LibGio::SocketListenerEvent, Pointer(LibGio::Socket) -> Void
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
  end

  struct SocketListenerPrivate # struct
    _data : UInt8[0]
  end

  struct SocketPrivate # struct
    _data : UInt8[0]
  end

  struct SocketServiceClass # struct
    parent_class : LibGio::SocketListenerClass
    incoming : Pointer(LibGio::SocketService), Pointer(LibGio::SocketConnection), Pointer(LibGObject::Object) -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
  end

  struct SocketServicePrivate # struct
    _data : UInt8[0]
  end

  struct SrvTarget # struct
    _data : UInt8[0]
  end

  fun _g_srv_target_get_type = g_srv_target_get_type : UInt64
  fun srv_target_new = g_srv_target_new(hostname : Pointer(UInt8), port : UInt16, priority : UInt16, weight : UInt16) : Pointer(LibGio::SrvTarget)
  fun srv_target_copy = g_srv_target_copy(this : SrvTarget*) : Pointer(LibGio::SrvTarget)
  fun srv_target_free = g_srv_target_free(this : SrvTarget*) : Void
  fun srv_target_get_hostname = g_srv_target_get_hostname(this : SrvTarget*) : Pointer(UInt8)
  fun srv_target_get_port = g_srv_target_get_port(this : SrvTarget*) : UInt16
  fun srv_target_get_priority = g_srv_target_get_priority(this : SrvTarget*) : UInt16
  fun srv_target_get_weight = g_srv_target_get_weight(this : SrvTarget*) : UInt16

  struct StaticResource # struct
    data : Pointer(UInt8)
    data_len : UInt64
    resource : Pointer(LibGio::Resource)
    _next : Pointer(LibGio::StaticResource)
    padding : Pointer(Void)
  end

  fun static_resource_fini = g_static_resource_fini(this : StaticResource*) : Void
  fun static_resource_get_resource = g_static_resource_get_resource(this : StaticResource*) : Pointer(LibGio::Resource)
  fun static_resource_init = g_static_resource_init(this : StaticResource*) : Void

  struct TaskClass # struct
    _data : UInt8[0]
  end

  struct TcpConnectionClass # struct
    parent_class : LibGio::SocketConnectionClass
  end

  struct TcpConnectionPrivate # struct
    _data : UInt8[0]
  end

  struct TcpWrapperConnectionClass # struct
    parent_class : LibGio::TcpConnectionClass
  end

  struct TcpWrapperConnectionPrivate # struct
    _data : UInt8[0]
  end

  struct ThemedIconClass # struct
    _data : UInt8[0]
  end

  struct ThreadedSocketServiceClass # struct
    parent_class : LibGio::SocketServiceClass
    run : Pointer(LibGio::ThreadedSocketService), Pointer(LibGio::SocketConnection), Pointer(LibGObject::Object) -> LibC::Int
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct ThreadedSocketServicePrivate # struct
    _data : UInt8[0]
  end

  struct TlsBackendInterface # struct
    g_iface : LibGObject::TypeInterface
    supports_tls : Pointer(LibGio::TlsBackend) -> LibC::Int
    get_certificate_type : -> UInt64
    get_client_connection_type : -> UInt64
    get_server_connection_type : -> UInt64
    get_file_database_type : -> UInt64
    get_default_database : Pointer(LibGio::TlsBackend) -> Pointer(LibGio::TlsDatabase)
    supports_dtls : Pointer(LibGio::TlsBackend) -> LibC::Int
    get_dtls_client_connection_type : -> UInt64
    get_dtls_server_connection_type : -> UInt64
  end

  struct TlsCertificateClass # struct
    parent_class : LibGObject::ObjectClass
    verify : Pointer(LibGio::TlsCertificate), Pointer(LibGio::SocketConnectable), Pointer(LibGio::TlsCertificate) -> LibGio::TlsCertificateFlags
    padding : Pointer(Void)[8]
  end

  struct TlsCertificatePrivate # struct
    _data : UInt8[0]
  end

  struct TlsClientConnectionInterface # struct
    g_iface : LibGObject::TypeInterface
    copy_session_state : Pointer(LibGio::TlsClientConnection), Pointer(LibGio::TlsClientConnection) -> Void
  end

  struct TlsConnectionClass # struct
    parent_class : LibGio::IOStreamClass
    accept_certificate : Pointer(LibGio::TlsConnection), Pointer(LibGio::TlsCertificate), LibGio::TlsCertificateFlags -> LibC::Int
    handshake : Pointer(LibGio::TlsConnection), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    handshake_async : Pointer(LibGio::TlsConnection), Int32, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    handshake_finish : Pointer(LibGio::TlsConnection), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    padding : Pointer(Void)[8]
  end

  struct TlsConnectionPrivate # struct
    _data : UInt8[0]
  end

  struct TlsDatabaseClass # struct
    parent_class : LibGObject::ObjectClass
    verify_chain : Pointer(LibGio::TlsDatabase), Pointer(LibGio::TlsCertificate), Pointer(UInt8), Pointer(LibGio::SocketConnectable), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseVerifyFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibGio::TlsCertificateFlags
    verify_chain_async : Pointer(LibGio::TlsDatabase), Pointer(LibGio::TlsCertificate), Pointer(UInt8), Pointer(LibGio::SocketConnectable), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseVerifyFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    verify_chain_finish : Pointer(LibGio::TlsDatabase), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibGio::TlsCertificateFlags
    create_certificate_handle : Pointer(LibGio::TlsDatabase), Pointer(LibGio::TlsCertificate) -> Pointer(UInt8)
    lookup_certificate_for_handle : Pointer(LibGio::TlsDatabase), Pointer(UInt8), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::TlsCertificate)
    lookup_certificate_for_handle_async : Pointer(LibGio::TlsDatabase), Pointer(UInt8), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_certificate_for_handle_finish : Pointer(LibGio::TlsDatabase), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::TlsCertificate)
    lookup_certificate_issuer : Pointer(LibGio::TlsDatabase), Pointer(LibGio::TlsCertificate), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(LibGio::TlsCertificate)
    lookup_certificate_issuer_async : Pointer(LibGio::TlsDatabase), Pointer(LibGio::TlsCertificate), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_certificate_issuer_finish : Pointer(LibGio::TlsDatabase), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(LibGio::TlsCertificate)
    lookup_certificates_issued_by : Pointer(LibGio::TlsDatabase), Pointer(Void), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> Pointer(Void*)
    lookup_certificates_issued_by_async : Pointer(LibGio::TlsDatabase), Pointer(Void), Pointer(LibGio::TlsInteraction), LibGio::TlsDatabaseLookupFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    lookup_certificates_issued_by_finish : Pointer(LibGio::TlsDatabase), Pointer(LibGio::AsyncResult), LibGLib::Error* -> Pointer(Void*)
    padding : Pointer(Void)[16]
  end

  struct TlsDatabasePrivate # struct
    _data : UInt8[0]
  end

  struct TlsFileDatabaseInterface # struct
    g_iface : LibGObject::TypeInterface
    padding : Pointer(Void)[8]
  end

  struct TlsInteractionClass # struct
    parent_class : LibGObject::ObjectClass
    ask_password : Pointer(LibGio::TlsInteraction), Pointer(LibGio::TlsPassword), Pointer(LibGio::Cancellable), LibGLib::Error* -> LibGio::TlsInteractionResult
    ask_password_async : Pointer(LibGio::TlsInteraction), Pointer(LibGio::TlsPassword), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    ask_password_finish : Pointer(LibGio::TlsInteraction), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibGio::TlsInteractionResult
    request_certificate : Pointer(LibGio::TlsInteraction), Pointer(LibGio::TlsConnection), LibGio::TlsCertificateRequestFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibGio::TlsInteractionResult
    request_certificate_async : Pointer(LibGio::TlsInteraction), Pointer(LibGio::TlsConnection), LibGio::TlsCertificateRequestFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    request_certificate_finish : Pointer(LibGio::TlsInteraction), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibGio::TlsInteractionResult
    padding : Pointer(Void)[21]
  end

  struct TlsInteractionPrivate # struct
    _data : UInt8[0]
  end

  struct TlsPasswordClass # struct
    parent_class : LibGObject::ObjectClass
    get_value : Pointer(LibGio::TlsPassword), Pointer(UInt64) -> Pointer(UInt8)
    set_value : Pointer(LibGio::TlsPassword), Pointer(UInt8), Int64, LibGLib::DestroyNotify -> Void
    get_default_warning : Pointer(LibGio::TlsPassword) -> Pointer(UInt8)
    padding : Pointer(Void)[4]
  end

  struct TlsPasswordPrivate # struct
    _data : UInt8[0]
  end

  struct TlsServerConnectionInterface # struct
    g_iface : LibGObject::TypeInterface
  end

  struct UnixConnectionClass # struct
    parent_class : LibGio::SocketConnectionClass
  end

  struct UnixConnectionPrivate # struct
    _data : UInt8[0]
  end

  struct UnixCredentialsMessageClass # struct
    parent_class : LibGio::SocketControlMessageClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
  end

  struct UnixCredentialsMessagePrivate # struct
    _data : UInt8[0]
  end

  struct UnixFDListClass # struct
    parent_class : LibGObject::ObjectClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct UnixFDListPrivate # struct
    _data : UInt8[0]
  end

  struct UnixFDMessageClass # struct
    parent_class : LibGio::SocketControlMessageClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
  end

  struct UnixFDMessagePrivate # struct
    _data : UInt8[0]
  end

  struct UnixInputStreamClass # struct
    parent_class : LibGio::InputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct UnixInputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct UnixMountEntry # struct
    _data : UInt8[0]
  end

  fun _g_unix_mount_entry_get_type = g_unix_mount_entry_get_type : UInt64

  struct UnixMountMonitorClass # struct
    _data : UInt8[0]
  end

  struct UnixMountPoint # struct
    _data : UInt8[0]
  end

  fun _g_unix_mount_point_get_type = g_unix_mount_point_get_type : UInt64
  fun unix_mount_point_compare = g_unix_mount_point_compare(this : UnixMountPoint*, mount2 : Pointer(LibGio::UnixMountPoint)) : Int32
  fun unix_mount_point_copy = g_unix_mount_point_copy(this : UnixMountPoint*) : Pointer(LibGio::UnixMountPoint)
  fun unix_mount_point_free = g_unix_mount_point_free(this : UnixMountPoint*) : Void
  fun unix_mount_point_get_device_path = g_unix_mount_point_get_device_path(this : UnixMountPoint*) : Pointer(UInt8)
  fun unix_mount_point_get_fs_type = g_unix_mount_point_get_fs_type(this : UnixMountPoint*) : Pointer(UInt8)
  fun unix_mount_point_get_mount_path = g_unix_mount_point_get_mount_path(this : UnixMountPoint*) : Pointer(UInt8)
  fun unix_mount_point_get_options = g_unix_mount_point_get_options(this : UnixMountPoint*) : Pointer(UInt8)
  fun unix_mount_point_guess_can_eject = g_unix_mount_point_guess_can_eject(this : UnixMountPoint*) : LibC::Int
  fun unix_mount_point_guess_icon = g_unix_mount_point_guess_icon(this : UnixMountPoint*) : Pointer(LibGio::Icon)
  fun unix_mount_point_guess_name = g_unix_mount_point_guess_name(this : UnixMountPoint*) : Pointer(UInt8)
  fun unix_mount_point_guess_symbolic_icon = g_unix_mount_point_guess_symbolic_icon(this : UnixMountPoint*) : Pointer(LibGio::Icon)
  fun unix_mount_point_is_loopback = g_unix_mount_point_is_loopback(this : UnixMountPoint*) : LibC::Int
  fun unix_mount_point_is_readonly = g_unix_mount_point_is_readonly(this : UnixMountPoint*) : LibC::Int
  fun unix_mount_point_is_user_mountable = g_unix_mount_point_is_user_mountable(this : UnixMountPoint*) : LibC::Int

  struct UnixOutputStreamClass # struct
    parent_class : LibGio::OutputStreamClass
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
  end

  struct UnixOutputStreamPrivate # struct
    _data : UInt8[0]
  end

  struct UnixSocketAddressClass # struct
    parent_class : LibGio::SocketAddressClass
  end

  struct UnixSocketAddressPrivate # struct
    _data : UInt8[0]
  end

  struct VfsClass # struct
    parent_class : LibGObject::ObjectClass
    is_active : Pointer(LibGio::Vfs) -> LibC::Int
    get_file_for_path : Pointer(LibGio::Vfs), Pointer(UInt8) -> Pointer(LibGio::File)
    get_file_for_uri : Pointer(LibGio::Vfs), Pointer(UInt8) -> Pointer(LibGio::File)
    get_supported_uri_schemes : Pointer(LibGio::Vfs) -> Pointer(Pointer(UInt8))
    parse_name : Pointer(LibGio::Vfs), Pointer(UInt8) -> Pointer(LibGio::File)
    local_file_add_info : Pointer(LibGio::Vfs), Pointer(UInt8), UInt64, Pointer(LibGio::FileAttributeMatcher), Pointer(LibGio::FileInfo), Pointer(LibGio::Cancellable), Pointer(Void), Pointer(LibGLib::DestroyNotify) -> Void
    add_writable_namespaces : Pointer(LibGio::Vfs), Pointer(LibGio::FileAttributeInfoList) -> Void
    local_file_set_attributes : Pointer(LibGio::Vfs), Pointer(UInt8), Pointer(LibGio::FileInfo), LibGio::FileQueryInfoFlags, Pointer(LibGio::Cancellable), LibGLib::Error* -> LibC::Int
    local_file_removed : Pointer(LibGio::Vfs), Pointer(UInt8) -> Void
    local_file_moved : Pointer(LibGio::Vfs), Pointer(UInt8), Pointer(UInt8) -> Void
    deserialize_icon : Pointer(Void)
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
  end

  struct VolumeIface # struct
    g_iface : LibGObject::TypeInterface
    changed : Pointer(LibGio::Volume) -> Void
    removed : Pointer(LibGio::Volume) -> Void
    get_name : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_icon : Pointer(LibGio::Volume) -> Pointer(LibGio::Icon)
    get_uuid : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_drive : Pointer(LibGio::Volume) -> Pointer(LibGio::Drive)
    get_mount : Pointer(LibGio::Volume) -> Pointer(LibGio::Mount)
    can_mount : Pointer(LibGio::Volume) -> LibC::Int
    can_eject : Pointer(LibGio::Volume) -> LibC::Int
    mount_fn : Pointer(LibGio::Volume), LibGio::MountMountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    mount_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    eject : Pointer(LibGio::Volume), LibGio::MountUnmountFlags, Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_identifier : Pointer(LibGio::Volume), Pointer(UInt8) -> Pointer(UInt8)
    enumerate_identifiers : Pointer(LibGio::Volume) -> Pointer(Pointer(UInt8))
    should_automount : Pointer(LibGio::Volume) -> LibC::Int
    get_activation_root : Pointer(LibGio::Volume) -> Pointer(LibGio::File)
    eject_with_operation : Pointer(LibGio::Volume), LibGio::MountUnmountFlags, Pointer(LibGio::MountOperation), Pointer(LibGio::Cancellable), LibGio::AsyncReadyCallback, Pointer(Void) -> Void
    eject_with_operation_finish : Pointer(LibGio::Volume), Pointer(LibGio::AsyncResult), LibGLib::Error* -> LibC::Int
    get_sort_key : Pointer(LibGio::Volume) -> Pointer(UInt8)
    get_symbolic_icon : Pointer(LibGio::Volume) -> Pointer(LibGio::Icon)
  end

  struct VolumeMonitorClass # struct
    parent_class : LibGObject::ObjectClass
    volume_added : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Volume) -> Void
    volume_removed : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Volume) -> Void
    volume_changed : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Volume) -> Void
    mount_added : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Mount) -> Void
    mount_removed : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Mount) -> Void
    mount_pre_unmount : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Mount) -> Void
    mount_changed : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Mount) -> Void
    drive_connected : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Drive) -> Void
    drive_disconnected : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Drive) -> Void
    drive_changed : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Drive) -> Void
    is_supported : -> LibC::Int
    get_connected_drives : Pointer(LibGio::VolumeMonitor) -> Pointer(Void*)
    get_volumes : Pointer(LibGio::VolumeMonitor) -> Pointer(Void*)
    get_mounts : Pointer(LibGio::VolumeMonitor) -> Pointer(Void*)
    get_volume_for_uuid : Pointer(LibGio::VolumeMonitor), Pointer(UInt8) -> Pointer(LibGio::Volume)
    get_mount_for_uuid : Pointer(LibGio::VolumeMonitor), Pointer(UInt8) -> Pointer(LibGio::Mount)
    adopt_orphan_mount : Pointer(Void)
    drive_eject_button : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Drive) -> Void
    drive_stop_button : Pointer(LibGio::VolumeMonitor), Pointer(LibGio::Drive) -> Void
    _g_reserved1 : Pointer(Void)
    _g_reserved2 : Pointer(Void)
    _g_reserved3 : Pointer(Void)
    _g_reserved4 : Pointer(Void)
    _g_reserved5 : Pointer(Void)
    _g_reserved6 : Pointer(Void)
  end

  struct ZlibCompressorClass # struct
    parent_class : LibGObject::ObjectClass
  end

  struct ZlibDecompressorClass # struct
    parent_class : LibGObject::ObjectClass
  end

  ###########################################
  # #    Flags
  ###########################################

  alias AppInfoCreateFlags = UInt32

  alias ApplicationFlags = UInt32

  alias AskPasswordFlags = UInt32

  alias BusNameOwnerFlags = UInt32

  alias BusNameWatcherFlags = UInt32

  alias ConverterFlags = UInt32

  alias DBusCallFlags = UInt32

  alias DBusCapabilityFlags = UInt32

  alias DBusConnectionFlags = UInt32

  alias DBusInterfaceSkeletonFlags = UInt32

  alias DBusMessageFlags = UInt32

  alias DBusObjectManagerClientFlags = UInt32

  alias DBusPropertyInfoFlags = UInt32

  alias DBusProxyFlags = UInt32

  alias DBusSendMessageFlags = UInt32

  alias DBusServerFlags = UInt32

  alias DBusSignalFlags = UInt32

  alias DBusSubtreeFlags = UInt32

  alias DriveStartFlags = UInt32

  alias FileAttributeInfoFlags = UInt32

  alias FileCopyFlags = UInt32

  alias FileCreateFlags = UInt32

  alias FileMeasureFlags = UInt32

  alias FileMonitorFlags = UInt32

  alias FileQueryInfoFlags = UInt32

  alias IOStreamSpliceFlags = UInt32

  alias MountMountFlags = UInt32

  alias MountUnmountFlags = UInt32

  alias OutputStreamSpliceFlags = UInt32

  alias ResolverNameLookupFlags = UInt32

  alias ResourceFlags = UInt32

  alias ResourceLookupFlags = UInt32

  alias SettingsBindFlags = UInt32

  alias SocketMsgFlags = UInt32

  alias SubprocessFlags = UInt32

  alias TestDBusFlags = UInt32

  alias TlsCertificateFlags = UInt32

  alias TlsDatabaseVerifyFlags = UInt32

  alias TlsPasswordFlags = UInt32

  ###########################################
  # #    Objects
  ###########################################

  struct AppInfoMonitor # object
    _data : UInt8[0]
    # Signal changed
  end

  fun _g_app_info_monitor_get_type = g_app_info_monitor_get_type : UInt64
  fun app_info_monitor_get = g_app_info_monitor_get : Pointer(LibGio::AppInfoMonitor)

  struct AppLaunchContext # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::AppLaunchContextPrivate)
    # Signal launch-failed
    # Signal launched
    # Virtual function get_display
    # Virtual function get_startup_notify_id
    # Virtual function launch_failed
    # Virtual function launched
  end

  fun _g_app_launch_context_get_type = g_app_launch_context_get_type : UInt64
  fun app_launch_context_new = g_app_launch_context_new : Pointer(LibGio::AppLaunchContext)
  fun app_launch_context_get_display = g_app_launch_context_get_display(this : AppLaunchContext*, info : Pointer(LibGio::AppInfo), files : Pointer(Void*)) : Pointer(UInt8)
  fun app_launch_context_get_environment = g_app_launch_context_get_environment(this : AppLaunchContext*) : Pointer(Pointer(UInt8))
  fun app_launch_context_get_startup_notify_id = g_app_launch_context_get_startup_notify_id(this : AppLaunchContext*, info : Pointer(LibGio::AppInfo), files : Pointer(Void*)) : Pointer(UInt8)
  fun app_launch_context_launch_failed = g_app_launch_context_launch_failed(this : AppLaunchContext*, startup_notify_id : Pointer(UInt8)) : Void
  fun app_launch_context_setenv = g_app_launch_context_setenv(this : AppLaunchContext*, variable : Pointer(UInt8), value : Pointer(UInt8)) : Void
  fun app_launch_context_unsetenv = g_app_launch_context_unsetenv(this : AppLaunchContext*, variable : Pointer(UInt8)) : Void

  struct Application # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::ApplicationPrivate)
    # Signal activate
    # Signal command-line
    # Signal handle-local-options
    # Signal name-lost
    # Signal open
    # Signal shutdown
    # Signal startup
    # Virtual function activate
    # Virtual function add_platform_data
    # Virtual function after_emit
    # Virtual function before_emit
    # Virtual function command_line
    # Virtual function dbus_register
    # Virtual function dbus_unregister
    # Virtual function handle_local_options
    # Virtual function local_command_line
    # Virtual function name_lost
    # Virtual function open
    # Virtual function quit_mainloop
    # Virtual function run_mainloop
    # Virtual function shutdown
    # Virtual function startup
    # Property action-group : LibGio::ActionGroup
    # Property application-id : Pointer(UInt8)
    # Property flags : LibGio::ApplicationFlags
    # Property inactivity-timeout : UInt32
    # Property is-busy : LibC::Int
    # Property is-registered : LibC::Int
    # Property is-remote : LibC::Int
    # Property resource-base-path : Pointer(UInt8)
  end

  fun _g_application_get_type = g_application_get_type : UInt64
  fun application_new = g_application_new(application_id : Pointer(UInt8), flags : LibGio::ApplicationFlags) : Pointer(LibGio::Application)
  fun application_get_default = g_application_get_default : Pointer(LibGio::Application)
  fun application_id_is_valid = g_application_id_is_valid(application_id : Pointer(UInt8)) : LibC::Int
  fun application_activate = g_application_activate(this : Application*) : Void
  fun application_add_main_option = g_application_add_main_option(this : Application*, long_name : Pointer(UInt8), short_name : Int8, flags : LibGLib::OptionFlags, arg : LibGLib::OptionArg, description : Pointer(UInt8), arg_description : Pointer(UInt8)) : Void
  fun application_add_main_option_entries = g_application_add_main_option_entries(this : Application*, entries : Pointer(LibGLib::OptionEntry)) : Void
  fun application_add_option_group = g_application_add_option_group(this : Application*, group : Pointer(LibGLib::OptionGroup)) : Void
  fun application_bind_busy_property = g_application_bind_busy_property(this : Application*, object : Pointer(LibGObject::Object), property : Pointer(UInt8)) : Void
  fun application_get_application_id = g_application_get_application_id(this : Application*) : Pointer(UInt8)
  fun application_get_dbus_connection = g_application_get_dbus_connection(this : Application*) : Pointer(LibGio::DBusConnection)
  fun application_get_dbus_object_path = g_application_get_dbus_object_path(this : Application*) : Pointer(UInt8)
  fun application_get_flags = g_application_get_flags(this : Application*) : LibGio::ApplicationFlags
  fun application_get_inactivity_timeout = g_application_get_inactivity_timeout(this : Application*) : UInt32
  fun application_get_is_busy = g_application_get_is_busy(this : Application*) : LibC::Int
  fun application_get_is_registered = g_application_get_is_registered(this : Application*) : LibC::Int
  fun application_get_is_remote = g_application_get_is_remote(this : Application*) : LibC::Int
  fun application_get_resource_base_path = g_application_get_resource_base_path(this : Application*) : Pointer(UInt8)
  fun application_hold = g_application_hold(this : Application*) : Void
  fun application_mark_busy = g_application_mark_busy(this : Application*) : Void
  fun application_open = g_application_open(this : Application*, files : Pointer(Pointer(LibGio::File)), n_files : Int32, hint : Pointer(UInt8)) : Void
  fun application_quit = g_application_quit(this : Application*) : Void
  fun application_register = g_application_register(this : Application*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun application_release = g_application_release(this : Application*) : Void
  fun application_run = g_application_run(this : Application*, argc : Int32, argv : Pointer(Pointer(UInt8))) : Int32
  fun application_send_notification = g_application_send_notification(this : Application*, id : Pointer(UInt8), notification : Pointer(LibGio::Notification)) : Void
  fun application_set_action_group = g_application_set_action_group(this : Application*, action_group : Pointer(LibGio::ActionGroup)) : Void
  fun application_set_application_id = g_application_set_application_id(this : Application*, application_id : Pointer(UInt8)) : Void
  fun application_set_default = g_application_set_default(this : Application*) : Void
  fun application_set_flags = g_application_set_flags(this : Application*, flags : LibGio::ApplicationFlags) : Void
  fun application_set_inactivity_timeout = g_application_set_inactivity_timeout(this : Application*, inactivity_timeout : UInt32) : Void
  fun application_set_option_context_description = g_application_set_option_context_description(this : Application*, description : Pointer(UInt8)) : Void
  fun application_set_option_context_parameter_string = g_application_set_option_context_parameter_string(this : Application*, parameter_string : Pointer(UInt8)) : Void
  fun application_set_option_context_summary = g_application_set_option_context_summary(this : Application*, summary : Pointer(UInt8)) : Void
  fun application_set_resource_base_path = g_application_set_resource_base_path(this : Application*, resource_path : Pointer(UInt8)) : Void
  fun application_unbind_busy_property = g_application_unbind_busy_property(this : Application*, object : Pointer(LibGObject::Object), property : Pointer(UInt8)) : Void
  fun application_unmark_busy = g_application_unmark_busy(this : Application*) : Void
  fun application_withdraw_notification = g_application_withdraw_notification(this : Application*, id : Pointer(UInt8)) : Void

  struct ApplicationCommandLine # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::ApplicationCommandLinePrivate)
    # Virtual function get_stdin
    # Virtual function print_literal
    # Virtual function printerr_literal
    # Property arguments : LibGLib::Variant
    # Property is-remote : LibC::Int
    # Property options : LibGLib::Variant
    # Property platform-data : LibGLib::Variant
  end

  fun _g_application_command_line_get_type = g_application_command_line_get_type : UInt64
  fun application_command_line_create_file_for_arg = g_application_command_line_create_file_for_arg(this : ApplicationCommandLine*, arg : Pointer(UInt8)) : Pointer(LibGio::File)
  fun application_command_line_get_arguments = g_application_command_line_get_arguments(this : ApplicationCommandLine*, argc : Int32*) : Pointer(Pointer(UInt8))
  fun application_command_line_get_cwd = g_application_command_line_get_cwd(this : ApplicationCommandLine*) : Pointer(UInt8)
  fun application_command_line_get_environ = g_application_command_line_get_environ(this : ApplicationCommandLine*) : Pointer(Pointer(UInt8))
  fun application_command_line_get_exit_status = g_application_command_line_get_exit_status(this : ApplicationCommandLine*) : Int32
  fun application_command_line_get_is_remote = g_application_command_line_get_is_remote(this : ApplicationCommandLine*) : LibC::Int
  fun application_command_line_get_options_dict = g_application_command_line_get_options_dict(this : ApplicationCommandLine*) : Pointer(LibGLib::VariantDict)
  fun application_command_line_get_platform_data = g_application_command_line_get_platform_data(this : ApplicationCommandLine*) : Pointer(LibGLib::Variant)
  fun application_command_line_get_stdin = g_application_command_line_get_stdin(this : ApplicationCommandLine*) : Pointer(LibGio::InputStream)
  fun application_command_line_getenv = g_application_command_line_getenv(this : ApplicationCommandLine*, name : Pointer(UInt8)) : Pointer(UInt8)
  fun application_command_line_set_exit_status = g_application_command_line_set_exit_status(this : ApplicationCommandLine*, exit_status : Int32) : Void

  struct BufferedInputStream # object
    parent_instance : LibGio::FilterInputStream
    priv : Pointer(LibGio::BufferedInputStreamPrivate)
    # Virtual function fill
    # Virtual function fill_async
    # Virtual function fill_finish
    # Property buffer-size : UInt32
  end

  fun _g_buffered_input_stream_get_type = g_buffered_input_stream_get_type : UInt64
  fun buffered_input_stream_new = g_buffered_input_stream_new(base_stream : Pointer(LibGio::InputStream)) : Pointer(LibGio::InputStream)
  fun buffered_input_stream_new_sized = g_buffered_input_stream_new_sized(base_stream : Pointer(LibGio::InputStream), size : UInt64) : Pointer(LibGio::InputStream)
  fun buffered_input_stream_fill = g_buffered_input_stream_fill(this : BufferedInputStream*, count : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun buffered_input_stream_fill_async = g_buffered_input_stream_fill_async(this : BufferedInputStream*, count : Int64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun buffered_input_stream_fill_finish = g_buffered_input_stream_fill_finish(this : BufferedInputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64
  fun buffered_input_stream_get_available = g_buffered_input_stream_get_available(this : BufferedInputStream*) : UInt64
  fun buffered_input_stream_get_buffer_size = g_buffered_input_stream_get_buffer_size(this : BufferedInputStream*) : UInt64
  fun buffered_input_stream_peek = g_buffered_input_stream_peek(this : BufferedInputStream*, buffer : Pointer(UInt8), offset : UInt64, count : UInt64) : UInt64
  fun buffered_input_stream_peek_buffer = g_buffered_input_stream_peek_buffer(this : BufferedInputStream*, count : UInt64*) : Pointer(UInt8)
  fun buffered_input_stream_read_byte = g_buffered_input_stream_read_byte(this : BufferedInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun buffered_input_stream_set_buffer_size = g_buffered_input_stream_set_buffer_size(this : BufferedInputStream*, size : UInt64) : Void

  struct BufferedOutputStream # object
    parent_instance : LibGio::FilterOutputStream
    priv : Pointer(LibGio::BufferedOutputStreamPrivate)
    # Property auto-grow : LibC::Int
    # Property buffer-size : UInt32
  end

  fun _g_buffered_output_stream_get_type = g_buffered_output_stream_get_type : UInt64
  fun buffered_output_stream_new = g_buffered_output_stream_new(base_stream : Pointer(LibGio::OutputStream)) : Pointer(LibGio::OutputStream)
  fun buffered_output_stream_new_sized = g_buffered_output_stream_new_sized(base_stream : Pointer(LibGio::OutputStream), size : UInt64) : Pointer(LibGio::OutputStream)
  fun buffered_output_stream_get_auto_grow = g_buffered_output_stream_get_auto_grow(this : BufferedOutputStream*) : LibC::Int
  fun buffered_output_stream_get_buffer_size = g_buffered_output_stream_get_buffer_size(this : BufferedOutputStream*) : UInt64
  fun buffered_output_stream_set_auto_grow = g_buffered_output_stream_set_auto_grow(this : BufferedOutputStream*, auto_grow : LibC::Int) : Void
  fun buffered_output_stream_set_buffer_size = g_buffered_output_stream_set_buffer_size(this : BufferedOutputStream*, size : UInt64) : Void

  struct BytesIcon # object
    _data : UInt8[0]
    # Property bytes : LibGLib::Bytes
  end

  fun _g_bytes_icon_get_type = g_bytes_icon_get_type : UInt64
  fun bytes_icon_new = g_bytes_icon_new(bytes : Pointer(LibGLib::Bytes)) : Pointer(LibGio::BytesIcon)
  fun bytes_icon_get_bytes = g_bytes_icon_get_bytes(this : BytesIcon*) : Pointer(LibGLib::Bytes)

  struct Cancellable # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::CancellablePrivate)
    # Signal cancelled
    # Virtual function cancelled
  end

  fun _g_cancellable_get_type = g_cancellable_get_type : UInt64
  fun cancellable_new = g_cancellable_new : Pointer(LibGio::Cancellable)
  fun cancellable_get_current = g_cancellable_get_current : Pointer(LibGio::Cancellable)
  fun cancellable_cancel = g_cancellable_cancel(this : Cancellable*) : Void
  fun cancellable_connect = g_cancellable_connect(this : Cancellable*, callback : LibGObject::Callback, data : Pointer(Void), data_destroy_func : LibGLib::DestroyNotify) : UInt64
  fun cancellable_disconnect = g_cancellable_disconnect(this : Cancellable*, handler_id : UInt64) : Void
  fun cancellable_get_fd = g_cancellable_get_fd(this : Cancellable*) : Int32
  fun cancellable_is_cancelled = g_cancellable_is_cancelled(this : Cancellable*) : LibC::Int
  fun cancellable_make_pollfd = g_cancellable_make_pollfd(this : Cancellable*, pollfd : Pointer(LibGLib::PollFD)) : LibC::Int
  fun cancellable_pop_current = g_cancellable_pop_current(this : Cancellable*) : Void
  fun cancellable_push_current = g_cancellable_push_current(this : Cancellable*) : Void
  fun cancellable_release_fd = g_cancellable_release_fd(this : Cancellable*) : Void
  fun cancellable_reset = g_cancellable_reset(this : Cancellable*) : Void
  fun cancellable_set_error_if_cancelled = g_cancellable_set_error_if_cancelled(this : Cancellable*, error : LibGLib::Error**) : LibC::Int
  fun cancellable_source_new = g_cancellable_source_new(this : Cancellable*) : Pointer(LibGLib::Source)

  struct CharsetConverter # object
    _data : UInt8[0]
    # Property from-charset : Pointer(UInt8)
    # Property to-charset : Pointer(UInt8)
    # Property use-fallback : LibC::Int
  end

  fun _g_charset_converter_get_type = g_charset_converter_get_type : UInt64
  fun charset_converter_new = g_charset_converter_new(to_charset : Pointer(UInt8), from_charset : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::CharsetConverter)
  fun charset_converter_get_num_fallbacks = g_charset_converter_get_num_fallbacks(this : CharsetConverter*) : UInt32
  fun charset_converter_get_use_fallback = g_charset_converter_get_use_fallback(this : CharsetConverter*) : LibC::Int
  fun charset_converter_set_use_fallback = g_charset_converter_set_use_fallback(this : CharsetConverter*, use_fallback : LibC::Int) : Void

  struct ConverterInputStream # object
    parent_instance : LibGio::FilterInputStream
    priv : Pointer(LibGio::ConverterInputStreamPrivate)
    # Property converter : LibGio::Converter
  end

  fun _g_converter_input_stream_get_type = g_converter_input_stream_get_type : UInt64
  fun converter_input_stream_new = g_converter_input_stream_new(base_stream : Pointer(LibGio::InputStream), converter : Pointer(LibGio::Converter)) : Pointer(LibGio::InputStream)
  fun converter_input_stream_get_converter = g_converter_input_stream_get_converter(this : ConverterInputStream*) : Pointer(LibGio::Converter)

  struct ConverterOutputStream # object
    parent_instance : LibGio::FilterOutputStream
    priv : Pointer(LibGio::ConverterOutputStreamPrivate)
    # Property converter : LibGio::Converter
  end

  fun _g_converter_output_stream_get_type = g_converter_output_stream_get_type : UInt64
  fun converter_output_stream_new = g_converter_output_stream_new(base_stream : Pointer(LibGio::OutputStream), converter : Pointer(LibGio::Converter)) : Pointer(LibGio::OutputStream)
  fun converter_output_stream_get_converter = g_converter_output_stream_get_converter(this : ConverterOutputStream*) : Pointer(LibGio::Converter)

  struct Credentials # object
    _data : UInt8[0]
  end

  fun _g_credentials_get_type = g_credentials_get_type : UInt64
  fun credentials_new = g_credentials_new : Pointer(LibGio::Credentials)
  fun credentials_get_unix_pid = g_credentials_get_unix_pid(this : Credentials*, error : LibGLib::Error**) : Int32
  fun credentials_get_unix_user = g_credentials_get_unix_user(this : Credentials*, error : LibGLib::Error**) : UInt32
  fun credentials_is_same_user = g_credentials_is_same_user(this : Credentials*, other_credentials : Pointer(LibGio::Credentials), error : LibGLib::Error**) : LibC::Int
  fun credentials_set_native = g_credentials_set_native(this : Credentials*, native_type : LibGio::CredentialsType, native : Pointer(Void)) : Void
  fun credentials_set_unix_user = g_credentials_set_unix_user(this : Credentials*, uid : UInt32, error : LibGLib::Error**) : LibC::Int
  fun credentials_to_string = g_credentials_to_string(this : Credentials*) : Pointer(UInt8)

  struct DBusActionGroup # object
    _data : UInt8[0]
  end

  fun _g_dbus_action_group_get_type = g_dbus_action_group_get_type : UInt64
  fun d_bus_action_group_get = g_dbus_action_group_get(connection : Pointer(LibGio::DBusConnection), bus_name : Pointer(UInt8), object_path : Pointer(UInt8)) : Pointer(LibGio::DBusActionGroup)

  struct DBusAuthObserver # object
    _data : UInt8[0]
    # Signal allow-mechanism
    # Signal authorize-authenticated-peer
  end

  fun _g_dbus_auth_observer_get_type = g_dbus_auth_observer_get_type : UInt64
  fun d_bus_auth_observer_new = g_dbus_auth_observer_new : Pointer(LibGio::DBusAuthObserver)
  fun d_bus_auth_observer_allow_mechanism = g_dbus_auth_observer_allow_mechanism(this : DBusAuthObserver*, mechanism : Pointer(UInt8)) : LibC::Int
  fun d_bus_auth_observer_authorize_authenticated_peer = g_dbus_auth_observer_authorize_authenticated_peer(this : DBusAuthObserver*, stream : Pointer(LibGio::IOStream), credentials : Pointer(LibGio::Credentials)) : LibC::Int

  struct DBusConnection # object
    _data : UInt8[0]
    # Signal closed
    # Property address : Pointer(UInt8)
    # Property authentication-observer : LibGio::DBusAuthObserver
    # Property capabilities : LibGio::DBusCapabilityFlags
    # Property closed : LibC::Int
    # Property exit-on-close : LibC::Int
    # Property flags : LibGio::DBusConnectionFlags
    # Property guid : Pointer(UInt8)
    # Property stream : LibGio::IOStream
    # Property unique-name : Pointer(UInt8)
  end

  fun _g_dbus_connection_get_type = g_dbus_connection_get_type : UInt64
  fun d_bus_connection_new_finish = g_dbus_connection_new_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun d_bus_connection_new_for_address_finish = g_dbus_connection_new_for_address_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun d_bus_connection_new_for_address_sync = g_dbus_connection_new_for_address_sync(address : Pointer(UInt8), flags : LibGio::DBusConnectionFlags, observer : Pointer(LibGio::DBusAuthObserver), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun d_bus_connection_new_sync = g_dbus_connection_new_sync(stream : Pointer(LibGio::IOStream), guid : Pointer(UInt8), flags : LibGio::DBusConnectionFlags, observer : Pointer(LibGio::DBusAuthObserver), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun d_bus_connection_new = g_dbus_connection_new(stream : Pointer(LibGio::IOStream), guid : Pointer(UInt8), flags : LibGio::DBusConnectionFlags, observer : Pointer(LibGio::DBusAuthObserver), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_new_for_address = g_dbus_connection_new_for_address(address : Pointer(UInt8), flags : LibGio::DBusConnectionFlags, observer : Pointer(LibGio::DBusAuthObserver), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_add_filter = g_dbus_connection_add_filter(this : DBusConnection*, filter_function : LibGio::DBusMessageFilterFunction, user_data : Pointer(Void), user_data_free_func : LibGLib::DestroyNotify) : UInt32
  fun d_bus_connection_call = g_dbus_connection_call(this : DBusConnection*, bus_name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), reply_type : Pointer(LibGLib::VariantType), flags : LibGio::DBusCallFlags, timeout_msec : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_call_finish = g_dbus_connection_call_finish(this : DBusConnection*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_connection_call_sync = g_dbus_connection_call_sync(this : DBusConnection*, bus_name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), reply_type : Pointer(LibGLib::VariantType), flags : LibGio::DBusCallFlags, timeout_msec : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_connection_call_with_unix_fd_list = g_dbus_connection_call_with_unix_fd_list(this : DBusConnection*, bus_name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), reply_type : Pointer(LibGLib::VariantType), flags : LibGio::DBusCallFlags, timeout_msec : Int32, fd_list : Pointer(LibGio::UnixFDList), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_call_with_unix_fd_list_finish = g_dbus_connection_call_with_unix_fd_list_finish(this : DBusConnection*, out_fd_list : Pointer(LibGio::UnixFDList)*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_connection_call_with_unix_fd_list_sync = g_dbus_connection_call_with_unix_fd_list_sync(this : DBusConnection*, bus_name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), reply_type : Pointer(LibGLib::VariantType), flags : LibGio::DBusCallFlags, timeout_msec : Int32, fd_list : Pointer(LibGio::UnixFDList), out_fd_list : Pointer(LibGio::UnixFDList)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_connection_close = g_dbus_connection_close(this : DBusConnection*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_close_finish = g_dbus_connection_close_finish(this : DBusConnection*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_close_sync = g_dbus_connection_close_sync(this : DBusConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_emit_signal = g_dbus_connection_emit_signal(this : DBusConnection*, destination_bus_name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), signal_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_export_action_group = g_dbus_connection_export_action_group(this : DBusConnection*, object_path : Pointer(UInt8), action_group : Pointer(LibGio::ActionGroup), error : LibGLib::Error**) : UInt32
  fun d_bus_connection_export_menu_model = g_dbus_connection_export_menu_model(this : DBusConnection*, object_path : Pointer(UInt8), menu : Pointer(LibGio::MenuModel), error : LibGLib::Error**) : UInt32
  fun d_bus_connection_flush = g_dbus_connection_flush(this : DBusConnection*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_flush_finish = g_dbus_connection_flush_finish(this : DBusConnection*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_flush_sync = g_dbus_connection_flush_sync(this : DBusConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_get_capabilities = g_dbus_connection_get_capabilities(this : DBusConnection*) : LibGio::DBusCapabilityFlags
  fun d_bus_connection_get_exit_on_close = g_dbus_connection_get_exit_on_close(this : DBusConnection*) : LibC::Int
  fun d_bus_connection_get_flags = g_dbus_connection_get_flags(this : DBusConnection*) : LibGio::DBusConnectionFlags
  fun d_bus_connection_get_guid = g_dbus_connection_get_guid(this : DBusConnection*) : Pointer(UInt8)
  fun d_bus_connection_get_last_serial = g_dbus_connection_get_last_serial(this : DBusConnection*) : UInt32
  fun d_bus_connection_get_peer_credentials = g_dbus_connection_get_peer_credentials(this : DBusConnection*) : Pointer(LibGio::Credentials)
  fun d_bus_connection_get_stream = g_dbus_connection_get_stream(this : DBusConnection*) : Pointer(LibGio::IOStream)
  fun d_bus_connection_get_unique_name = g_dbus_connection_get_unique_name(this : DBusConnection*) : Pointer(UInt8)
  fun d_bus_connection_is_closed = g_dbus_connection_is_closed(this : DBusConnection*) : LibC::Int
  fun d_bus_connection_register_object = g_dbus_connection_register_object_with_closures(this : DBusConnection*, object_path : Pointer(UInt8), interface_info : Pointer(LibGio::DBusInterfaceInfo), method_call_closure : Pointer(LibGObject::Closure), get_property_closure : Pointer(LibGObject::Closure), set_property_closure : Pointer(LibGObject::Closure), error : LibGLib::Error**) : UInt32
  fun d_bus_connection_register_subtree = g_dbus_connection_register_subtree(this : DBusConnection*, object_path : Pointer(UInt8), vtable : Pointer(LibGio::DBusSubtreeVTable), flags : LibGio::DBusSubtreeFlags, user_data : Pointer(Void), user_data_free_func : LibGLib::DestroyNotify, error : LibGLib::Error**) : UInt32
  fun d_bus_connection_remove_filter = g_dbus_connection_remove_filter(this : DBusConnection*, filter_id : UInt32) : Void
  fun d_bus_connection_send_message = g_dbus_connection_send_message(this : DBusConnection*, message : Pointer(LibGio::DBusMessage), flags : LibGio::DBusSendMessageFlags, out_serial : UInt32*, error : LibGLib::Error**) : LibC::Int
  fun d_bus_connection_send_message_with_reply = g_dbus_connection_send_message_with_reply(this : DBusConnection*, message : Pointer(LibGio::DBusMessage), flags : LibGio::DBusSendMessageFlags, timeout_msec : Int32, out_serial : UInt32*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_connection_send_message_with_reply_finish = g_dbus_connection_send_message_with_reply_finish(this : DBusConnection*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusMessage)
  fun d_bus_connection_send_message_with_reply_sync = g_dbus_connection_send_message_with_reply_sync(this : DBusConnection*, message : Pointer(LibGio::DBusMessage), flags : LibGio::DBusSendMessageFlags, timeout_msec : Int32, out_serial : UInt32*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusMessage)
  fun d_bus_connection_set_exit_on_close = g_dbus_connection_set_exit_on_close(this : DBusConnection*, exit_on_close : LibC::Int) : Void
  fun d_bus_connection_signal_subscribe = g_dbus_connection_signal_subscribe(this : DBusConnection*, sender : Pointer(UInt8), interface_name : Pointer(UInt8), member : Pointer(UInt8), object_path : Pointer(UInt8), arg0 : Pointer(UInt8), flags : LibGio::DBusSignalFlags, callback : LibGio::DBusSignalCallback, user_data : Pointer(Void), user_data_free_func : LibGLib::DestroyNotify) : UInt32
  fun d_bus_connection_signal_unsubscribe = g_dbus_connection_signal_unsubscribe(this : DBusConnection*, subscription_id : UInt32) : Void
  fun d_bus_connection_start_message_processing = g_dbus_connection_start_message_processing(this : DBusConnection*) : Void
  fun d_bus_connection_unexport_action_group = g_dbus_connection_unexport_action_group(this : DBusConnection*, export_id : UInt32) : Void
  fun d_bus_connection_unexport_menu_model = g_dbus_connection_unexport_menu_model(this : DBusConnection*, export_id : UInt32) : Void
  fun d_bus_connection_unregister_object = g_dbus_connection_unregister_object(this : DBusConnection*, registration_id : UInt32) : LibC::Int
  fun d_bus_connection_unregister_subtree = g_dbus_connection_unregister_subtree(this : DBusConnection*, registration_id : UInt32) : LibC::Int

  struct DBusInterfaceSkeleton # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusInterfaceSkeletonPrivate)
    # Signal g-authorize-method
    # Virtual function flush
    # Virtual function g_authorize_method
    # Virtual function get_info
    # Virtual function get_properties
    # Property g-flags : LibGio::DBusInterfaceSkeletonFlags
  end

  fun _g_dbus_interface_skeleton_get_type = g_dbus_interface_skeleton_get_type : UInt64
  fun d_bus_interface_skeleton_export = g_dbus_interface_skeleton_export(this : DBusInterfaceSkeleton*, connection : Pointer(LibGio::DBusConnection), object_path : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun d_bus_interface_skeleton_flush = g_dbus_interface_skeleton_flush(this : DBusInterfaceSkeleton*) : Void
  fun d_bus_interface_skeleton_get_connection = g_dbus_interface_skeleton_get_connection(this : DBusInterfaceSkeleton*) : Pointer(LibGio::DBusConnection)
  fun d_bus_interface_skeleton_get_connections = g_dbus_interface_skeleton_get_connections(this : DBusInterfaceSkeleton*) : Pointer(Void*)
  fun d_bus_interface_skeleton_get_flags = g_dbus_interface_skeleton_get_flags(this : DBusInterfaceSkeleton*) : LibGio::DBusInterfaceSkeletonFlags
  fun d_bus_interface_skeleton_get_info = g_dbus_interface_skeleton_get_info(this : DBusInterfaceSkeleton*) : Pointer(LibGio::DBusInterfaceInfo)
  fun d_bus_interface_skeleton_get_object_path = g_dbus_interface_skeleton_get_object_path(this : DBusInterfaceSkeleton*) : Pointer(UInt8)
  fun d_bus_interface_skeleton_get_properties = g_dbus_interface_skeleton_get_properties(this : DBusInterfaceSkeleton*) : Pointer(LibGLib::Variant)
  fun d_bus_interface_skeleton_has_connection = g_dbus_interface_skeleton_has_connection(this : DBusInterfaceSkeleton*, connection : Pointer(LibGio::DBusConnection)) : LibC::Int
  fun d_bus_interface_skeleton_set_flags = g_dbus_interface_skeleton_set_flags(this : DBusInterfaceSkeleton*, flags : LibGio::DBusInterfaceSkeletonFlags) : Void
  fun d_bus_interface_skeleton_unexport = g_dbus_interface_skeleton_unexport(this : DBusInterfaceSkeleton*) : Void
  fun d_bus_interface_skeleton_unexport_from_connection = g_dbus_interface_skeleton_unexport_from_connection(this : DBusInterfaceSkeleton*, connection : Pointer(LibGio::DBusConnection)) : Void

  struct DBusMenuModel # object
    _data : UInt8[0]
  end

  fun _g_dbus_menu_model_get_type = g_dbus_menu_model_get_type : UInt64
  fun d_bus_menu_model_get = g_dbus_menu_model_get(connection : Pointer(LibGio::DBusConnection), bus_name : Pointer(UInt8), object_path : Pointer(UInt8)) : Pointer(LibGio::DBusMenuModel)

  struct DBusMessage # object
    _data : UInt8[0]
    # Property locked : LibC::Int
  end

  fun _g_dbus_message_get_type = g_dbus_message_get_type : UInt64
  fun d_bus_message_new = g_dbus_message_new : Pointer(LibGio::DBusMessage)
  fun d_bus_message_new_from_blob = g_dbus_message_new_from_blob(blob : Pointer(UInt8), blob_len : UInt64, capabilities : LibGio::DBusCapabilityFlags, error : LibGLib::Error**) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_new_method_call = g_dbus_message_new_method_call(name : Pointer(UInt8), path : Pointer(UInt8), interface_ : Pointer(UInt8), method : Pointer(UInt8)) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_new_signal = g_dbus_message_new_signal(path : Pointer(UInt8), interface_ : Pointer(UInt8), signal : Pointer(UInt8)) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_bytes_needed = g_dbus_message_bytes_needed(blob : Pointer(UInt8), blob_len : UInt64, error : LibGLib::Error**) : Int64
  fun d_bus_message_copy = g_dbus_message_copy(this : DBusMessage*, error : LibGLib::Error**) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_get_arg0 = g_dbus_message_get_arg0(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_body = g_dbus_message_get_body(this : DBusMessage*) : Pointer(LibGLib::Variant)
  fun d_bus_message_get_byte_order = g_dbus_message_get_byte_order(this : DBusMessage*) : LibGio::DBusMessageByteOrder
  fun d_bus_message_get_destination = g_dbus_message_get_destination(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_error_name = g_dbus_message_get_error_name(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_flags = g_dbus_message_get_flags(this : DBusMessage*) : LibGio::DBusMessageFlags
  fun d_bus_message_get_header = g_dbus_message_get_header(this : DBusMessage*, header_field : LibGio::DBusMessageHeaderField) : Pointer(LibGLib::Variant)
  fun d_bus_message_get_header_fields = g_dbus_message_get_header_fields(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_interface = g_dbus_message_get_interface(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_locked = g_dbus_message_get_locked(this : DBusMessage*) : LibC::Int
  fun d_bus_message_get_member = g_dbus_message_get_member(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_message_type = g_dbus_message_get_message_type(this : DBusMessage*) : LibGio::DBusMessageType
  fun d_bus_message_get_num_unix_fds = g_dbus_message_get_num_unix_fds(this : DBusMessage*) : UInt32
  fun d_bus_message_get_path = g_dbus_message_get_path(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_reply_serial = g_dbus_message_get_reply_serial(this : DBusMessage*) : UInt32
  fun d_bus_message_get_sender = g_dbus_message_get_sender(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_serial = g_dbus_message_get_serial(this : DBusMessage*) : UInt32
  fun d_bus_message_get_signature = g_dbus_message_get_signature(this : DBusMessage*) : Pointer(UInt8)
  fun d_bus_message_get_unix_fd_list = g_dbus_message_get_unix_fd_list(this : DBusMessage*) : Pointer(LibGio::UnixFDList)
  fun d_bus_message_lock = g_dbus_message_lock(this : DBusMessage*) : Void
  fun d_bus_message_new_method_error_literal = g_dbus_message_new_method_error_literal(this : DBusMessage*, error_name : Pointer(UInt8), error_message : Pointer(UInt8)) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_new_method_reply = g_dbus_message_new_method_reply(this : DBusMessage*) : Pointer(LibGio::DBusMessage)
  fun d_bus_message_print = g_dbus_message_print(this : DBusMessage*, indent : UInt32) : Pointer(UInt8)
  fun d_bus_message_set_body = g_dbus_message_set_body(this : DBusMessage*, body : Pointer(LibGLib::Variant)) : Void
  fun d_bus_message_set_byte_order = g_dbus_message_set_byte_order(this : DBusMessage*, byte_order : LibGio::DBusMessageByteOrder) : Void
  fun d_bus_message_set_destination = g_dbus_message_set_destination(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_error_name = g_dbus_message_set_error_name(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_flags = g_dbus_message_set_flags(this : DBusMessage*, flags : LibGio::DBusMessageFlags) : Void
  fun d_bus_message_set_header = g_dbus_message_set_header(this : DBusMessage*, header_field : LibGio::DBusMessageHeaderField, value : Pointer(LibGLib::Variant)) : Void
  fun d_bus_message_set_interface = g_dbus_message_set_interface(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_member = g_dbus_message_set_member(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_message_type = g_dbus_message_set_message_type(this : DBusMessage*, type : LibGio::DBusMessageType) : Void
  fun d_bus_message_set_num_unix_fds = g_dbus_message_set_num_unix_fds(this : DBusMessage*, value : UInt32) : Void
  fun d_bus_message_set_path = g_dbus_message_set_path(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_reply_serial = g_dbus_message_set_reply_serial(this : DBusMessage*, value : UInt32) : Void
  fun d_bus_message_set_sender = g_dbus_message_set_sender(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_serial = g_dbus_message_set_serial(this : DBusMessage*, serial : UInt32) : Void
  fun d_bus_message_set_signature = g_dbus_message_set_signature(this : DBusMessage*, value : Pointer(UInt8)) : Void
  fun d_bus_message_set_unix_fd_list = g_dbus_message_set_unix_fd_list(this : DBusMessage*, fd_list : Pointer(LibGio::UnixFDList)) : Void
  fun d_bus_message_to_blob = g_dbus_message_to_blob(this : DBusMessage*, out_size : UInt64*, capabilities : LibGio::DBusCapabilityFlags, error : LibGLib::Error**) : Pointer(UInt8)
  fun d_bus_message_to_gerror = g_dbus_message_to_gerror(this : DBusMessage*, error : LibGLib::Error**) : LibC::Int

  struct DBusMethodInvocation # object
    _data : UInt8[0]
  end

  fun _g_dbus_method_invocation_get_type = g_dbus_method_invocation_get_type : UInt64
  fun d_bus_method_invocation_get_connection = g_dbus_method_invocation_get_connection(this : DBusMethodInvocation*) : Pointer(LibGio::DBusConnection)
  fun d_bus_method_invocation_get_interface_name = g_dbus_method_invocation_get_interface_name(this : DBusMethodInvocation*) : Pointer(UInt8)
  fun d_bus_method_invocation_get_message = g_dbus_method_invocation_get_message(this : DBusMethodInvocation*) : Pointer(LibGio::DBusMessage)
  fun d_bus_method_invocation_get_method_info = g_dbus_method_invocation_get_method_info(this : DBusMethodInvocation*) : Pointer(LibGio::DBusMethodInfo)
  fun d_bus_method_invocation_get_method_name = g_dbus_method_invocation_get_method_name(this : DBusMethodInvocation*) : Pointer(UInt8)
  fun d_bus_method_invocation_get_object_path = g_dbus_method_invocation_get_object_path(this : DBusMethodInvocation*) : Pointer(UInt8)
  fun d_bus_method_invocation_get_parameters = g_dbus_method_invocation_get_parameters(this : DBusMethodInvocation*) : Pointer(LibGLib::Variant)
  fun d_bus_method_invocation_get_property_info = g_dbus_method_invocation_get_property_info(this : DBusMethodInvocation*) : Pointer(LibGio::DBusPropertyInfo)
  fun d_bus_method_invocation_get_sender = g_dbus_method_invocation_get_sender(this : DBusMethodInvocation*) : Pointer(UInt8)
  fun d_bus_method_invocation_return_dbus_error = g_dbus_method_invocation_return_dbus_error(this : DBusMethodInvocation*, error_name : Pointer(UInt8), error_message : Pointer(UInt8)) : Void
  fun d_bus_method_invocation_return_error_literal = g_dbus_method_invocation_return_error_literal(this : DBusMethodInvocation*, domain : UInt32, code : Int32, message : Pointer(UInt8)) : Void
  fun d_bus_method_invocation_return_gerror = g_dbus_method_invocation_return_gerror(this : DBusMethodInvocation*, error : Pointer(LibGLib::Error*)) : Void
  fun d_bus_method_invocation_return_value = g_dbus_method_invocation_return_value(this : DBusMethodInvocation*, parameters : Pointer(LibGLib::Variant)) : Void
  fun d_bus_method_invocation_return_value_with_unix_fd_list = g_dbus_method_invocation_return_value_with_unix_fd_list(this : DBusMethodInvocation*, parameters : Pointer(LibGLib::Variant), fd_list : Pointer(LibGio::UnixFDList)) : Void

  struct DBusObjectManagerClient # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusObjectManagerClientPrivate)
    # Signal interface-proxy-properties-changed
    # Signal interface-proxy-signal
    # Virtual function interface_proxy_properties_changed
    # Virtual function interface_proxy_signal
    # Property bus-type : LibGio::BusType
    # Property connection : LibGio::DBusConnection
    # Property flags : LibGio::DBusObjectManagerClientFlags
    # Property get-proxy-type-destroy-notify : Pointer(Void)
    # Property get-proxy-type-func : Pointer(Void)
    # Property get-proxy-type-user-data : Pointer(Void)
    # Property name : Pointer(UInt8)
    # Property name-owner : Pointer(UInt8)
    # Property object-path : Pointer(UInt8)
  end

  fun _g_dbus_object_manager_client_get_type = g_dbus_object_manager_client_get_type : UInt64
  fun d_bus_object_manager_client_new_finish = g_dbus_object_manager_client_new_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusObjectManagerClient)
  fun d_bus_object_manager_client_new_for_bus_finish = g_dbus_object_manager_client_new_for_bus_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusObjectManagerClient)
  fun d_bus_object_manager_client_new_for_bus_sync = g_dbus_object_manager_client_new_for_bus_sync(bus_type : LibGio::BusType, flags : LibGio::DBusObjectManagerClientFlags, name : Pointer(UInt8), object_path : Pointer(UInt8), get_proxy_type_func : LibGio::DBusProxyTypeFunc, get_proxy_type_user_data : Pointer(Void), get_proxy_type_destroy_notify : LibGLib::DestroyNotify, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusObjectManagerClient)
  fun d_bus_object_manager_client_new_sync = g_dbus_object_manager_client_new_sync(connection : Pointer(LibGio::DBusConnection), flags : LibGio::DBusObjectManagerClientFlags, name : Pointer(UInt8), object_path : Pointer(UInt8), get_proxy_type_func : LibGio::DBusProxyTypeFunc, get_proxy_type_user_data : Pointer(Void), get_proxy_type_destroy_notify : LibGLib::DestroyNotify, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusObjectManagerClient)
  fun d_bus_object_manager_client_new = g_dbus_object_manager_client_new(connection : Pointer(LibGio::DBusConnection), flags : LibGio::DBusObjectManagerClientFlags, name : Pointer(UInt8), object_path : Pointer(UInt8), get_proxy_type_func : LibGio::DBusProxyTypeFunc, get_proxy_type_user_data : Pointer(Void), get_proxy_type_destroy_notify : LibGLib::DestroyNotify, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_object_manager_client_new_for_bus = g_dbus_object_manager_client_new_for_bus(bus_type : LibGio::BusType, flags : LibGio::DBusObjectManagerClientFlags, name : Pointer(UInt8), object_path : Pointer(UInt8), get_proxy_type_func : LibGio::DBusProxyTypeFunc, get_proxy_type_user_data : Pointer(Void), get_proxy_type_destroy_notify : LibGLib::DestroyNotify, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_object_manager_client_get_connection = g_dbus_object_manager_client_get_connection(this : DBusObjectManagerClient*) : Pointer(LibGio::DBusConnection)
  fun d_bus_object_manager_client_get_flags = g_dbus_object_manager_client_get_flags(this : DBusObjectManagerClient*) : LibGio::DBusObjectManagerClientFlags
  fun d_bus_object_manager_client_get_name = g_dbus_object_manager_client_get_name(this : DBusObjectManagerClient*) : Pointer(UInt8)
  fun d_bus_object_manager_client_get_name_owner = g_dbus_object_manager_client_get_name_owner(this : DBusObjectManagerClient*) : Pointer(UInt8)

  struct DBusObjectManagerServer # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusObjectManagerServerPrivate)
    # Property connection : LibGio::DBusConnection
    # Property object-path : Pointer(UInt8)
  end

  fun _g_dbus_object_manager_server_get_type = g_dbus_object_manager_server_get_type : UInt64
  fun d_bus_object_manager_server_new = g_dbus_object_manager_server_new(object_path : Pointer(UInt8)) : Pointer(LibGio::DBusObjectManagerServer)
  fun d_bus_object_manager_server_export = g_dbus_object_manager_server_export(this : DBusObjectManagerServer*, object : Pointer(LibGio::DBusObjectSkeleton)) : Void
  fun d_bus_object_manager_server_export_uniquely = g_dbus_object_manager_server_export_uniquely(this : DBusObjectManagerServer*, object : Pointer(LibGio::DBusObjectSkeleton)) : Void
  fun d_bus_object_manager_server_get_connection = g_dbus_object_manager_server_get_connection(this : DBusObjectManagerServer*) : Pointer(LibGio::DBusConnection)
  fun d_bus_object_manager_server_is_exported = g_dbus_object_manager_server_is_exported(this : DBusObjectManagerServer*, object : Pointer(LibGio::DBusObjectSkeleton)) : LibC::Int
  fun d_bus_object_manager_server_set_connection = g_dbus_object_manager_server_set_connection(this : DBusObjectManagerServer*, connection : Pointer(LibGio::DBusConnection)) : Void
  fun d_bus_object_manager_server_unexport = g_dbus_object_manager_server_unexport(this : DBusObjectManagerServer*, object_path : Pointer(UInt8)) : LibC::Int

  struct DBusObjectProxy # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusObjectProxyPrivate)
    # Property g-connection : LibGio::DBusConnection
    # Property g-object-path : Pointer(UInt8)
  end

  fun _g_dbus_object_proxy_get_type = g_dbus_object_proxy_get_type : UInt64
  fun d_bus_object_proxy_new = g_dbus_object_proxy_new(connection : Pointer(LibGio::DBusConnection), object_path : Pointer(UInt8)) : Pointer(LibGio::DBusObjectProxy)
  fun d_bus_object_proxy_get_connection = g_dbus_object_proxy_get_connection(this : DBusObjectProxy*) : Pointer(LibGio::DBusConnection)

  struct DBusObjectSkeleton # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusObjectSkeletonPrivate)
    # Signal authorize-method
    # Virtual function authorize_method
    # Property g-object-path : Pointer(UInt8)
  end

  fun _g_dbus_object_skeleton_get_type = g_dbus_object_skeleton_get_type : UInt64
  fun d_bus_object_skeleton_new = g_dbus_object_skeleton_new(object_path : Pointer(UInt8)) : Pointer(LibGio::DBusObjectSkeleton)
  fun d_bus_object_skeleton_add_interface = g_dbus_object_skeleton_add_interface(this : DBusObjectSkeleton*, interface_ : Pointer(LibGio::DBusInterfaceSkeleton)) : Void
  fun d_bus_object_skeleton_flush = g_dbus_object_skeleton_flush(this : DBusObjectSkeleton*) : Void
  fun d_bus_object_skeleton_remove_interface = g_dbus_object_skeleton_remove_interface(this : DBusObjectSkeleton*, interface_ : Pointer(LibGio::DBusInterfaceSkeleton)) : Void
  fun d_bus_object_skeleton_remove_interface_by_name = g_dbus_object_skeleton_remove_interface_by_name(this : DBusObjectSkeleton*, interface_name : Pointer(UInt8)) : Void
  fun d_bus_object_skeleton_set_object_path = g_dbus_object_skeleton_set_object_path(this : DBusObjectSkeleton*, object_path : Pointer(UInt8)) : Void

  struct DBusProxy # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::DBusProxyPrivate)
    # Signal g-properties-changed
    # Signal g-signal
    # Virtual function g_properties_changed
    # Virtual function g_signal
    # Property g-bus-type : LibGio::BusType
    # Property g-connection : LibGio::DBusConnection
    # Property g-default-timeout : Int32
    # Property g-flags : LibGio::DBusProxyFlags
    # Property g-interface-info : LibGio::DBusInterfaceInfo
    # Property g-interface-name : Pointer(UInt8)
    # Property g-name : Pointer(UInt8)
    # Property g-name-owner : Pointer(UInt8)
    # Property g-object-path : Pointer(UInt8)
  end

  fun _g_dbus_proxy_get_type = g_dbus_proxy_get_type : UInt64
  fun d_bus_proxy_new_finish = g_dbus_proxy_new_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusProxy)
  fun d_bus_proxy_new_for_bus_finish = g_dbus_proxy_new_for_bus_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusProxy)
  fun d_bus_proxy_new_for_bus_sync = g_dbus_proxy_new_for_bus_sync(bus_type : LibGio::BusType, flags : LibGio::DBusProxyFlags, info : Pointer(LibGio::DBusInterfaceInfo), name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusProxy)
  fun d_bus_proxy_new_sync = g_dbus_proxy_new_sync(connection : Pointer(LibGio::DBusConnection), flags : LibGio::DBusProxyFlags, info : Pointer(LibGio::DBusInterfaceInfo), name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusProxy)
  fun d_bus_proxy_new = g_dbus_proxy_new(connection : Pointer(LibGio::DBusConnection), flags : LibGio::DBusProxyFlags, info : Pointer(LibGio::DBusInterfaceInfo), name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_proxy_new_for_bus = g_dbus_proxy_new_for_bus(bus_type : LibGio::BusType, flags : LibGio::DBusProxyFlags, info : Pointer(LibGio::DBusInterfaceInfo), name : Pointer(UInt8), object_path : Pointer(UInt8), interface_name : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_proxy_call = g_dbus_proxy_call(this : DBusProxy*, method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), flags : LibGio::DBusCallFlags, timeout_msec : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_proxy_call_finish = g_dbus_proxy_call_finish(this : DBusProxy*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_proxy_call_sync = g_dbus_proxy_call_sync(this : DBusProxy*, method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), flags : LibGio::DBusCallFlags, timeout_msec : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_proxy_call_with_unix_fd_list = g_dbus_proxy_call_with_unix_fd_list(this : DBusProxy*, method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), flags : LibGio::DBusCallFlags, timeout_msec : Int32, fd_list : Pointer(LibGio::UnixFDList), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun d_bus_proxy_call_with_unix_fd_list_finish = g_dbus_proxy_call_with_unix_fd_list_finish(this : DBusProxy*, out_fd_list : Pointer(LibGio::UnixFDList)*, res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_proxy_call_with_unix_fd_list_sync = g_dbus_proxy_call_with_unix_fd_list_sync(this : DBusProxy*, method_name : Pointer(UInt8), parameters : Pointer(LibGLib::Variant), flags : LibGio::DBusCallFlags, timeout_msec : Int32, fd_list : Pointer(LibGio::UnixFDList), out_fd_list : Pointer(LibGio::UnixFDList)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGLib::Variant)
  fun d_bus_proxy_get_cached_property = g_dbus_proxy_get_cached_property(this : DBusProxy*, property_name : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun d_bus_proxy_get_cached_property_names = g_dbus_proxy_get_cached_property_names(this : DBusProxy*) : Pointer(Pointer(UInt8))
  fun d_bus_proxy_get_connection = g_dbus_proxy_get_connection(this : DBusProxy*) : Pointer(LibGio::DBusConnection)
  fun d_bus_proxy_get_default_timeout = g_dbus_proxy_get_default_timeout(this : DBusProxy*) : Int32
  fun d_bus_proxy_get_flags = g_dbus_proxy_get_flags(this : DBusProxy*) : LibGio::DBusProxyFlags
  fun d_bus_proxy_get_interface_info = g_dbus_proxy_get_interface_info(this : DBusProxy*) : Pointer(LibGio::DBusInterfaceInfo)
  fun d_bus_proxy_get_interface_name = g_dbus_proxy_get_interface_name(this : DBusProxy*) : Pointer(UInt8)
  fun d_bus_proxy_get_name = g_dbus_proxy_get_name(this : DBusProxy*) : Pointer(UInt8)
  fun d_bus_proxy_get_name_owner = g_dbus_proxy_get_name_owner(this : DBusProxy*) : Pointer(UInt8)
  fun d_bus_proxy_get_object_path = g_dbus_proxy_get_object_path(this : DBusProxy*) : Pointer(UInt8)
  fun d_bus_proxy_set_cached_property = g_dbus_proxy_set_cached_property(this : DBusProxy*, property_name : Pointer(UInt8), value : Pointer(LibGLib::Variant)) : Void
  fun d_bus_proxy_set_default_timeout = g_dbus_proxy_set_default_timeout(this : DBusProxy*, timeout_msec : Int32) : Void
  fun d_bus_proxy_set_interface_info = g_dbus_proxy_set_interface_info(this : DBusProxy*, info : Pointer(LibGio::DBusInterfaceInfo)) : Void

  struct DBusServer # object
    _data : UInt8[0]
    # Signal new-connection
    # Property active : LibC::Int
    # Property address : Pointer(UInt8)
    # Property authentication-observer : LibGio::DBusAuthObserver
    # Property client-address : Pointer(UInt8)
    # Property flags : LibGio::DBusServerFlags
    # Property guid : Pointer(UInt8)
  end

  fun _g_dbus_server_get_type = g_dbus_server_get_type : UInt64
  fun d_bus_server_new_sync = g_dbus_server_new_sync(address : Pointer(UInt8), flags : LibGio::DBusServerFlags, guid : Pointer(UInt8), observer : Pointer(LibGio::DBusAuthObserver), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusServer)
  fun d_bus_server_get_client_address = g_dbus_server_get_client_address(this : DBusServer*) : Pointer(UInt8)
  fun d_bus_server_get_flags = g_dbus_server_get_flags(this : DBusServer*) : LibGio::DBusServerFlags
  fun d_bus_server_get_guid = g_dbus_server_get_guid(this : DBusServer*) : Pointer(UInt8)
  fun d_bus_server_is_active = g_dbus_server_is_active(this : DBusServer*) : LibC::Int
  fun d_bus_server_start = g_dbus_server_start(this : DBusServer*) : Void
  fun d_bus_server_stop = g_dbus_server_stop(this : DBusServer*) : Void

  struct DataInputStream # object
    parent_instance : LibGio::BufferedInputStream
    priv : Pointer(LibGio::DataInputStreamPrivate)
    # Property byte-order : LibGio::DataStreamByteOrder
    # Property newline-type : LibGio::DataStreamNewlineType
  end

  fun _g_data_input_stream_get_type = g_data_input_stream_get_type : UInt64
  fun data_input_stream_new = g_data_input_stream_new(base_stream : Pointer(LibGio::InputStream)) : Pointer(LibGio::DataInputStream)
  fun data_input_stream_get_byte_order = g_data_input_stream_get_byte_order(this : DataInputStream*) : LibGio::DataStreamByteOrder
  fun data_input_stream_get_newline_type = g_data_input_stream_get_newline_type(this : DataInputStream*) : LibGio::DataStreamNewlineType
  fun data_input_stream_read_byte = g_data_input_stream_read_byte(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : UInt8
  fun data_input_stream_read_int16 = g_data_input_stream_read_int16(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int16
  fun data_input_stream_read_int32 = g_data_input_stream_read_int32(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun data_input_stream_read_int64 = g_data_input_stream_read_int64(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun data_input_stream_read_line = g_data_input_stream_read_line(this : DataInputStream*, length : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_line_async = g_data_input_stream_read_line_async(this : DataInputStream*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun data_input_stream_read_line_finish = g_data_input_stream_read_line_finish(this : DataInputStream*, result : Pointer(LibGio::AsyncResult), length : UInt64*, error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_line_finish_utf8 = g_data_input_stream_read_line_finish_utf8(this : DataInputStream*, result : Pointer(LibGio::AsyncResult), length : UInt64*, error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_line_utf8 = g_data_input_stream_read_line_utf8(this : DataInputStream*, length : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_uint16 = g_data_input_stream_read_uint16(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : UInt16
  fun data_input_stream_read_uint32 = g_data_input_stream_read_uint32(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : UInt32
  fun data_input_stream_read_uint64 = g_data_input_stream_read_uint64(this : DataInputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : UInt64
  fun data_input_stream_read_until = g_data_input_stream_read_until(this : DataInputStream*, stop_chars : Pointer(UInt8), length : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_until_async = g_data_input_stream_read_until_async(this : DataInputStream*, stop_chars : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun data_input_stream_read_until_finish = g_data_input_stream_read_until_finish(this : DataInputStream*, result : Pointer(LibGio::AsyncResult), length : UInt64*, error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_upto = g_data_input_stream_read_upto(this : DataInputStream*, stop_chars : Pointer(UInt8), stop_chars_len : Int64, length : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_read_upto_async = g_data_input_stream_read_upto_async(this : DataInputStream*, stop_chars : Pointer(UInt8), stop_chars_len : Int64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun data_input_stream_read_upto_finish = g_data_input_stream_read_upto_finish(this : DataInputStream*, result : Pointer(LibGio::AsyncResult), length : UInt64*, error : LibGLib::Error**) : Pointer(UInt8)
  fun data_input_stream_set_byte_order = g_data_input_stream_set_byte_order(this : DataInputStream*, order : LibGio::DataStreamByteOrder) : Void
  fun data_input_stream_set_newline_type = g_data_input_stream_set_newline_type(this : DataInputStream*, type : LibGio::DataStreamNewlineType) : Void

  struct DataOutputStream # object
    parent_instance : LibGio::FilterOutputStream
    priv : Pointer(LibGio::DataOutputStreamPrivate)
    # Property byte-order : LibGio::DataStreamByteOrder
  end

  fun _g_data_output_stream_get_type = g_data_output_stream_get_type : UInt64
  fun data_output_stream_new = g_data_output_stream_new(base_stream : Pointer(LibGio::OutputStream)) : Pointer(LibGio::DataOutputStream)
  fun data_output_stream_get_byte_order = g_data_output_stream_get_byte_order(this : DataOutputStream*) : LibGio::DataStreamByteOrder
  fun data_output_stream_put_byte = g_data_output_stream_put_byte(this : DataOutputStream*, data : UInt8, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_int16 = g_data_output_stream_put_int16(this : DataOutputStream*, data : Int16, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_int32 = g_data_output_stream_put_int32(this : DataOutputStream*, data : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_int64 = g_data_output_stream_put_int64(this : DataOutputStream*, data : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_string = g_data_output_stream_put_string(this : DataOutputStream*, str : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_uint16 = g_data_output_stream_put_uint16(this : DataOutputStream*, data : UInt16, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_uint32 = g_data_output_stream_put_uint32(this : DataOutputStream*, data : UInt32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_put_uint64 = g_data_output_stream_put_uint64(this : DataOutputStream*, data : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun data_output_stream_set_byte_order = g_data_output_stream_set_byte_order(this : DataOutputStream*, order : LibGio::DataStreamByteOrder) : Void

  struct DesktopAppInfo # object
    _data : UInt8[0]
    # Property filename : Pointer(UInt8)
  end

  fun _g_desktop_app_info_get_type = g_desktop_app_info_get_type : UInt64
  fun desktop_app_info_new = g_desktop_app_info_new(desktop_id : Pointer(UInt8)) : Pointer(LibGio::DesktopAppInfo)
  fun desktop_app_info_new_from_filename = g_desktop_app_info_new_from_filename(filename : Pointer(UInt8)) : Pointer(LibGio::DesktopAppInfo)
  fun desktop_app_info_new_from_keyfile = g_desktop_app_info_new_from_keyfile(key_file : Pointer(LibGLib::KeyFile)) : Pointer(LibGio::DesktopAppInfo)
  fun desktop_app_info_get_implementations = g_desktop_app_info_get_implementations(interface : Pointer(UInt8)) : Pointer(Void*)
  fun desktop_app_info_search = g_desktop_app_info_search(search_string : Pointer(UInt8)) : Pointer(Pointer(Pointer(UInt8)))
  fun desktop_app_info_set_desktop_env = g_desktop_app_info_set_desktop_env(desktop_env : Pointer(UInt8)) : Void
  fun desktop_app_info_get_action_name = g_desktop_app_info_get_action_name(this : DesktopAppInfo*, action_name : Pointer(UInt8)) : Pointer(UInt8)
  fun desktop_app_info_get_boolean = g_desktop_app_info_get_boolean(this : DesktopAppInfo*, key : Pointer(UInt8)) : LibC::Int
  fun desktop_app_info_get_categories = g_desktop_app_info_get_categories(this : DesktopAppInfo*) : Pointer(UInt8)
  fun desktop_app_info_get_filename = g_desktop_app_info_get_filename(this : DesktopAppInfo*) : Pointer(UInt8)
  fun desktop_app_info_get_generic_name = g_desktop_app_info_get_generic_name(this : DesktopAppInfo*) : Pointer(UInt8)
  fun desktop_app_info_get_is_hidden = g_desktop_app_info_get_is_hidden(this : DesktopAppInfo*) : LibC::Int
  fun desktop_app_info_get_keywords = g_desktop_app_info_get_keywords(this : DesktopAppInfo*) : Pointer(Pointer(UInt8))
  fun desktop_app_info_get_locale_string = g_desktop_app_info_get_locale_string(this : DesktopAppInfo*, key : Pointer(UInt8)) : Pointer(UInt8)
  fun desktop_app_info_get_nodisplay = g_desktop_app_info_get_nodisplay(this : DesktopAppInfo*) : LibC::Int
  fun desktop_app_info_get_show_in = g_desktop_app_info_get_show_in(this : DesktopAppInfo*, desktop_env : Pointer(UInt8)) : LibC::Int
  fun desktop_app_info_get_startup_wm_class = g_desktop_app_info_get_startup_wm_class(this : DesktopAppInfo*) : Pointer(UInt8)
  fun desktop_app_info_get_string = g_desktop_app_info_get_string(this : DesktopAppInfo*, key : Pointer(UInt8)) : Pointer(UInt8)
  fun desktop_app_info_get_string_list = g_desktop_app_info_get_string_list(this : DesktopAppInfo*, key : Pointer(UInt8), length : UInt64*) : Pointer(Pointer(UInt8))
  fun desktop_app_info_has_key = g_desktop_app_info_has_key(this : DesktopAppInfo*, key : Pointer(UInt8)) : LibC::Int
  fun desktop_app_info_launch_action = g_desktop_app_info_launch_action(this : DesktopAppInfo*, action_name : Pointer(UInt8), launch_context : Pointer(LibGio::AppLaunchContext)) : Void
  fun desktop_app_info_launch_uris_as_manager = g_desktop_app_info_launch_uris_as_manager(this : DesktopAppInfo*, uris : Pointer(Void*), launch_context : Pointer(LibGio::AppLaunchContext), spawn_flags : LibGLib::SpawnFlags, user_setup : LibGLib::SpawnChildSetupFunc, user_setup_data : Pointer(Void), pid_callback : LibGio::DesktopAppLaunchCallback, pid_callback_data : Pointer(Void), error : LibGLib::Error**) : LibC::Int
  fun desktop_app_info_launch_uris_as_manager_with_fds = g_desktop_app_info_launch_uris_as_manager_with_fds(this : DesktopAppInfo*, uris : Pointer(Void*), launch_context : Pointer(LibGio::AppLaunchContext), spawn_flags : LibGLib::SpawnFlags, user_setup : LibGLib::SpawnChildSetupFunc, user_setup_data : Pointer(Void), pid_callback : LibGio::DesktopAppLaunchCallback, pid_callback_data : Pointer(Void), stdin_fd : Int32, stdout_fd : Int32, stderr_fd : Int32, error : LibGLib::Error**) : LibC::Int
  fun desktop_app_info_list_actions = g_desktop_app_info_list_actions(this : DesktopAppInfo*) : Pointer(Pointer(UInt8))

  struct Emblem # object
    _data : UInt8[0]
    # Property icon : LibGObject::Object
    # Property origin : LibGio::EmblemOrigin
  end

  fun _g_emblem_get_type = g_emblem_get_type : UInt64
  fun emblem_new = g_emblem_new(icon : Pointer(LibGio::Icon)) : Pointer(LibGio::Emblem)
  fun emblem_new_with_origin = g_emblem_new_with_origin(icon : Pointer(LibGio::Icon), origin : LibGio::EmblemOrigin) : Pointer(LibGio::Emblem)
  fun emblem_get_icon = g_emblem_get_icon(this : Emblem*) : Pointer(LibGio::Icon)
  fun emblem_get_origin = g_emblem_get_origin(this : Emblem*) : LibGio::EmblemOrigin

  struct EmblemedIcon # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::EmblemedIconPrivate)
    # Property gicon : LibGio::Icon
  end

  fun _g_emblemed_icon_get_type = g_emblemed_icon_get_type : UInt64
  fun emblemed_icon_new = g_emblemed_icon_new(icon : Pointer(LibGio::Icon), emblem : Pointer(LibGio::Emblem)) : Pointer(LibGio::EmblemedIcon)
  fun emblemed_icon_add_emblem = g_emblemed_icon_add_emblem(this : EmblemedIcon*, emblem : Pointer(LibGio::Emblem)) : Void
  fun emblemed_icon_clear_emblems = g_emblemed_icon_clear_emblems(this : EmblemedIcon*) : Void
  fun emblemed_icon_get_emblems = g_emblemed_icon_get_emblems(this : EmblemedIcon*) : Pointer(Void*)
  fun emblemed_icon_get_icon = g_emblemed_icon_get_icon(this : EmblemedIcon*) : Pointer(LibGio::Icon)

  struct FileEnumerator # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::FileEnumeratorPrivate)
    # Virtual function close_async
    # Virtual function close_finish
    # Virtual function close_fn
    # Virtual function next_file
    # Virtual function next_files_async
    # Virtual function next_files_finish
    # Property container : LibGio::File
  end

  fun _g_file_enumerator_get_type = g_file_enumerator_get_type : UInt64
  fun file_enumerator_close = g_file_enumerator_close(this : FileEnumerator*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_enumerator_close_async = g_file_enumerator_close_async(this : FileEnumerator*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_enumerator_close_finish = g_file_enumerator_close_finish(this : FileEnumerator*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun file_enumerator_get_child = g_file_enumerator_get_child(this : FileEnumerator*, info : Pointer(LibGio::FileInfo)) : Pointer(LibGio::File)
  fun file_enumerator_get_container = g_file_enumerator_get_container(this : FileEnumerator*) : Pointer(LibGio::File)
  fun file_enumerator_has_pending = g_file_enumerator_has_pending(this : FileEnumerator*) : LibC::Int
  fun file_enumerator_is_closed = g_file_enumerator_is_closed(this : FileEnumerator*) : LibC::Int
  fun file_enumerator_iterate = g_file_enumerator_iterate(this : FileEnumerator*, out_info : Pointer(LibGio::FileInfo)*, out_child : Pointer(LibGio::File)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun file_enumerator_next_file = g_file_enumerator_next_file(this : FileEnumerator*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_enumerator_next_files_async = g_file_enumerator_next_files_async(this : FileEnumerator*, num_files : Int32, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_enumerator_next_files_finish = g_file_enumerator_next_files_finish(this : FileEnumerator*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun file_enumerator_set_pending = g_file_enumerator_set_pending(this : FileEnumerator*, pending : LibC::Int) : Void

  struct FileIOStream # object
    parent_instance : LibGio::IOStream
    priv : Pointer(LibGio::FileIOStreamPrivate)
    # Virtual function can_seek
    # Virtual function can_truncate
    # Virtual function get_etag
    # Virtual function query_info
    # Virtual function query_info_async
    # Virtual function query_info_finish
    # Virtual function seek
    # Virtual function tell
    # Virtual function truncate_fn
  end

  fun _g_file_io_stream_get_type = g_file_io_stream_get_type : UInt64
  fun file_i_o_stream_get_etag = g_file_io_stream_get_etag(this : FileIOStream*) : Pointer(UInt8)
  fun file_i_o_stream_query_info = g_file_io_stream_query_info(this : FileIOStream*, attributes : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_i_o_stream_query_info_async = g_file_io_stream_query_info_async(this : FileIOStream*, attributes : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_i_o_stream_query_info_finish = g_file_io_stream_query_info_finish(this : FileIOStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)

  struct FileIcon # object
    _data : UInt8[0]
    # Property file : LibGio::File
  end

  fun _g_file_icon_get_type = g_file_icon_get_type : UInt64
  fun file_icon_new = g_file_icon_new(file : Pointer(LibGio::File)) : Pointer(LibGio::FileIcon)
  fun file_icon_get_file = g_file_icon_get_file(this : FileIcon*) : Pointer(LibGio::File)

  struct FileInfo # object
    _data : UInt8[0]
  end

  fun _g_file_info_get_type = g_file_info_get_type : UInt64
  fun file_info_new = g_file_info_new : Pointer(LibGio::FileInfo)
  fun file_info_clear_status = g_file_info_clear_status(this : FileInfo*) : Void
  fun file_info_copy_into = g_file_info_copy_into(this : FileInfo*, dest_info : Pointer(LibGio::FileInfo)) : Void
  fun file_info_dup = g_file_info_dup(this : FileInfo*) : Pointer(LibGio::FileInfo)
  fun file_info_get_attribute_as_string = g_file_info_get_attribute_as_string(this : FileInfo*, attribute : Pointer(UInt8)) : Pointer(UInt8)
  fun file_info_get_attribute_boolean = g_file_info_get_attribute_boolean(this : FileInfo*, attribute : Pointer(UInt8)) : LibC::Int
  fun file_info_get_attribute_byte_string = g_file_info_get_attribute_byte_string(this : FileInfo*, attribute : Pointer(UInt8)) : Pointer(UInt8)
  fun file_info_get_attribute_data = g_file_info_get_attribute_data(this : FileInfo*, attribute : Pointer(UInt8), type : LibGio::FileAttributeType*, value_pp : Pointer(Void)*, status : LibGio::FileAttributeStatus*) : LibC::Int
  fun file_info_get_attribute_int32 = g_file_info_get_attribute_int32(this : FileInfo*, attribute : Pointer(UInt8)) : Int32
  fun file_info_get_attribute_int64 = g_file_info_get_attribute_int64(this : FileInfo*, attribute : Pointer(UInt8)) : Int64
  fun file_info_get_attribute_object = g_file_info_get_attribute_object(this : FileInfo*, attribute : Pointer(UInt8)) : Pointer(LibGObject::Object)
  fun file_info_get_attribute_status = g_file_info_get_attribute_status(this : FileInfo*, attribute : Pointer(UInt8)) : LibGio::FileAttributeStatus
  fun file_info_get_attribute_string = g_file_info_get_attribute_string(this : FileInfo*, attribute : Pointer(UInt8)) : Pointer(UInt8)
  fun file_info_get_attribute_stringv = g_file_info_get_attribute_stringv(this : FileInfo*, attribute : Pointer(UInt8)) : Pointer(Pointer(UInt8))
  fun file_info_get_attribute_type = g_file_info_get_attribute_type(this : FileInfo*, attribute : Pointer(UInt8)) : LibGio::FileAttributeType
  fun file_info_get_attribute_uint32 = g_file_info_get_attribute_uint32(this : FileInfo*, attribute : Pointer(UInt8)) : UInt32
  fun file_info_get_attribute_uint64 = g_file_info_get_attribute_uint64(this : FileInfo*, attribute : Pointer(UInt8)) : UInt64
  fun file_info_get_content_type = g_file_info_get_content_type(this : FileInfo*) : Pointer(UInt8)
  fun file_info_get_deletion_date = g_file_info_get_deletion_date(this : FileInfo*) : Pointer(LibGLib::DateTime)
  fun file_info_get_display_name = g_file_info_get_display_name(this : FileInfo*) : Pointer(UInt8)
  fun file_info_get_edit_name = g_file_info_get_edit_name(this : FileInfo*) : Pointer(UInt8)
  fun file_info_get_etag = g_file_info_get_etag(this : FileInfo*) : Pointer(UInt8)
  fun file_info_get_file_type = g_file_info_get_file_type(this : FileInfo*) : LibGio::FileType
  fun file_info_get_icon = g_file_info_get_icon(this : FileInfo*) : Pointer(LibGio::Icon)
  fun file_info_get_is_backup = g_file_info_get_is_backup(this : FileInfo*) : LibC::Int
  fun file_info_get_is_hidden = g_file_info_get_is_hidden(this : FileInfo*) : LibC::Int
  fun file_info_get_is_symlink = g_file_info_get_is_symlink(this : FileInfo*) : LibC::Int
  fun file_info_get_modification_date_time = g_file_info_get_modification_date_time(this : FileInfo*) : Pointer(LibGLib::DateTime)
  fun file_info_get_modification_time = g_file_info_get_modification_time(this : FileInfo*, result : LibGLib::TimeVal*) : Void
  fun file_info_get_name = g_file_info_get_name(this : FileInfo*) : Pointer(UInt8)
  fun file_info_get_size = g_file_info_get_size(this : FileInfo*) : Int64
  fun file_info_get_sort_order = g_file_info_get_sort_order(this : FileInfo*) : Int32
  fun file_info_get_symbolic_icon = g_file_info_get_symbolic_icon(this : FileInfo*) : Pointer(LibGio::Icon)
  fun file_info_get_symlink_target = g_file_info_get_symlink_target(this : FileInfo*) : Pointer(UInt8)
  fun file_info_has_attribute = g_file_info_has_attribute(this : FileInfo*, attribute : Pointer(UInt8)) : LibC::Int
  fun file_info_has_namespace = g_file_info_has_namespace(this : FileInfo*, name_space : Pointer(UInt8)) : LibC::Int
  fun file_info_list_attributes = g_file_info_list_attributes(this : FileInfo*, name_space : Pointer(UInt8)) : Pointer(Pointer(UInt8))
  fun file_info_remove_attribute = g_file_info_remove_attribute(this : FileInfo*, attribute : Pointer(UInt8)) : Void
  fun file_info_set_attribute = g_file_info_set_attribute(this : FileInfo*, attribute : Pointer(UInt8), type : LibGio::FileAttributeType, value_p : Pointer(Void)) : Void
  fun file_info_set_attribute_boolean = g_file_info_set_attribute_boolean(this : FileInfo*, attribute : Pointer(UInt8), attr_value : LibC::Int) : Void
  fun file_info_set_attribute_byte_string = g_file_info_set_attribute_byte_string(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Pointer(UInt8)) : Void
  fun file_info_set_attribute_int32 = g_file_info_set_attribute_int32(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Int32) : Void
  fun file_info_set_attribute_int64 = g_file_info_set_attribute_int64(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Int64) : Void
  fun file_info_set_attribute_mask = g_file_info_set_attribute_mask(this : FileInfo*, mask : Pointer(LibGio::FileAttributeMatcher)) : Void
  fun file_info_set_attribute_object = g_file_info_set_attribute_object(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Pointer(LibGObject::Object)) : Void
  fun file_info_set_attribute_status = g_file_info_set_attribute_status(this : FileInfo*, attribute : Pointer(UInt8), status : LibGio::FileAttributeStatus) : LibC::Int
  fun file_info_set_attribute_string = g_file_info_set_attribute_string(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Pointer(UInt8)) : Void
  fun file_info_set_attribute_stringv = g_file_info_set_attribute_stringv(this : FileInfo*, attribute : Pointer(UInt8), attr_value : Pointer(Pointer(UInt8))) : Void
  fun file_info_set_attribute_uint32 = g_file_info_set_attribute_uint32(this : FileInfo*, attribute : Pointer(UInt8), attr_value : UInt32) : Void
  fun file_info_set_attribute_uint64 = g_file_info_set_attribute_uint64(this : FileInfo*, attribute : Pointer(UInt8), attr_value : UInt64) : Void
  fun file_info_set_content_type = g_file_info_set_content_type(this : FileInfo*, content_type : Pointer(UInt8)) : Void
  fun file_info_set_display_name = g_file_info_set_display_name(this : FileInfo*, display_name : Pointer(UInt8)) : Void
  fun file_info_set_edit_name = g_file_info_set_edit_name(this : FileInfo*, edit_name : Pointer(UInt8)) : Void
  fun file_info_set_file_type = g_file_info_set_file_type(this : FileInfo*, type : LibGio::FileType) : Void
  fun file_info_set_icon = g_file_info_set_icon(this : FileInfo*, icon : Pointer(LibGio::Icon)) : Void
  fun file_info_set_is_hidden = g_file_info_set_is_hidden(this : FileInfo*, is_hidden : LibC::Int) : Void
  fun file_info_set_is_symlink = g_file_info_set_is_symlink(this : FileInfo*, is_symlink : LibC::Int) : Void
  fun file_info_set_modification_date_time = g_file_info_set_modification_date_time(this : FileInfo*, mtime : Pointer(LibGLib::DateTime)) : Void
  fun file_info_set_modification_time = g_file_info_set_modification_time(this : FileInfo*, mtime : Pointer(LibGLib::TimeVal)) : Void
  fun file_info_set_name = g_file_info_set_name(this : FileInfo*, name : Pointer(UInt8)) : Void
  fun file_info_set_size = g_file_info_set_size(this : FileInfo*, size : Int64) : Void
  fun file_info_set_sort_order = g_file_info_set_sort_order(this : FileInfo*, sort_order : Int32) : Void
  fun file_info_set_symbolic_icon = g_file_info_set_symbolic_icon(this : FileInfo*, icon : Pointer(LibGio::Icon)) : Void
  fun file_info_set_symlink_target = g_file_info_set_symlink_target(this : FileInfo*, symlink_target : Pointer(UInt8)) : Void
  fun file_info_unset_attribute_mask = g_file_info_unset_attribute_mask(this : FileInfo*) : Void

  struct FileInputStream # object
    parent_instance : LibGio::InputStream
    priv : Pointer(LibGio::FileInputStreamPrivate)
    # Virtual function can_seek
    # Virtual function query_info
    # Virtual function query_info_async
    # Virtual function query_info_finish
    # Virtual function seek
    # Virtual function tell
  end

  fun _g_file_input_stream_get_type = g_file_input_stream_get_type : UInt64
  fun file_input_stream_query_info = g_file_input_stream_query_info(this : FileInputStream*, attributes : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_input_stream_query_info_async = g_file_input_stream_query_info_async(this : FileInputStream*, attributes : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_input_stream_query_info_finish = g_file_input_stream_query_info_finish(this : FileInputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)

  struct FileMonitor # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::FileMonitorPrivate)
    # Signal changed
    # Virtual function cancel
    # Virtual function changed
    # Property cancelled : LibC::Int
    # Property rate-limit : Int32
  end

  fun _g_file_monitor_get_type = g_file_monitor_get_type : UInt64
  fun file_monitor_cancel = g_file_monitor_cancel(this : FileMonitor*) : LibC::Int
  fun file_monitor_emit_event = g_file_monitor_emit_event(this : FileMonitor*, child : Pointer(LibGio::File), other_file : Pointer(LibGio::File), event_type : LibGio::FileMonitorEvent) : Void
  fun file_monitor_is_cancelled = g_file_monitor_is_cancelled(this : FileMonitor*) : LibC::Int
  fun file_monitor_set_rate_limit = g_file_monitor_set_rate_limit(this : FileMonitor*, limit_msecs : Int32) : Void

  struct FileOutputStream # object
    parent_instance : LibGio::OutputStream
    priv : Pointer(LibGio::FileOutputStreamPrivate)
    # Virtual function can_seek
    # Virtual function can_truncate
    # Virtual function get_etag
    # Virtual function query_info
    # Virtual function query_info_async
    # Virtual function query_info_finish
    # Virtual function seek
    # Virtual function tell
    # Virtual function truncate_fn
  end

  fun _g_file_output_stream_get_type = g_file_output_stream_get_type : UInt64
  fun file_output_stream_get_etag = g_file_output_stream_get_etag(this : FileOutputStream*) : Pointer(UInt8)
  fun file_output_stream_query_info = g_file_output_stream_query_info(this : FileOutputStream*, attributes : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)
  fun file_output_stream_query_info_async = g_file_output_stream_query_info_async(this : FileOutputStream*, attributes : Pointer(UInt8), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun file_output_stream_query_info_finish = g_file_output_stream_query_info_finish(this : FileOutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::FileInfo)

  struct FilenameCompleter # object
    _data : UInt8[0]
    # Signal got-completion-data
    # Virtual function got_completion_data
  end

  fun _g_filename_completer_get_type = g_filename_completer_get_type : UInt64
  fun filename_completer_new = g_filename_completer_new : Pointer(LibGio::FilenameCompleter)
  fun filename_completer_get_completion_suffix = g_filename_completer_get_completion_suffix(this : FilenameCompleter*, initial_text : Pointer(UInt8)) : Pointer(UInt8)
  fun filename_completer_get_completions = g_filename_completer_get_completions(this : FilenameCompleter*, initial_text : Pointer(UInt8)) : Pointer(Pointer(UInt8))
  fun filename_completer_set_dirs_only = g_filename_completer_set_dirs_only(this : FilenameCompleter*, dirs_only : LibC::Int) : Void

  struct FilterInputStream # object
    parent_instance : LibGio::InputStream
    base_stream : Pointer(LibGio::InputStream)
    # Property base-stream : LibGio::InputStream
    # Property close-base-stream : LibC::Int
  end

  fun _g_filter_input_stream_get_type = g_filter_input_stream_get_type : UInt64
  fun filter_input_stream_get_base_stream = g_filter_input_stream_get_base_stream(this : FilterInputStream*) : Pointer(LibGio::InputStream)
  fun filter_input_stream_get_close_base_stream = g_filter_input_stream_get_close_base_stream(this : FilterInputStream*) : LibC::Int
  fun filter_input_stream_set_close_base_stream = g_filter_input_stream_set_close_base_stream(this : FilterInputStream*, close_base : LibC::Int) : Void

  struct FilterOutputStream # object
    parent_instance : LibGio::OutputStream
    base_stream : Pointer(LibGio::OutputStream)
    # Property base-stream : LibGio::OutputStream
    # Property close-base-stream : LibC::Int
  end

  fun _g_filter_output_stream_get_type = g_filter_output_stream_get_type : UInt64
  fun filter_output_stream_get_base_stream = g_filter_output_stream_get_base_stream(this : FilterOutputStream*) : Pointer(LibGio::OutputStream)
  fun filter_output_stream_get_close_base_stream = g_filter_output_stream_get_close_base_stream(this : FilterOutputStream*) : LibC::Int
  fun filter_output_stream_set_close_base_stream = g_filter_output_stream_set_close_base_stream(this : FilterOutputStream*, close_base : LibC::Int) : Void

  struct IOModule # object
    _data : UInt8[0]
  end

  fun _g_io_module_get_type = g_io_module_get_type : UInt64
  fun i_o_module_new = g_io_module_new(filename : Pointer(UInt8)) : Pointer(LibGio::IOModule)
  fun i_o_module_query = g_io_module_query : Pointer(Pointer(UInt8))
  fun i_o_module_load = g_io_module_load(this : IOModule*) : Void
  fun i_o_module_unload = g_io_module_unload(this : IOModule*) : Void

  struct IOStream # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::IOStreamPrivate)
    # Virtual function close_async
    # Virtual function close_finish
    # Virtual function close_fn
    # Virtual function get_input_stream
    # Virtual function get_output_stream
    # Property closed : LibC::Int
    # Property input-stream : LibGio::InputStream
    # Property output-stream : LibGio::OutputStream
  end

  fun _g_io_stream_get_type = g_io_stream_get_type : UInt64
  fun i_o_stream_splice_finish = g_io_stream_splice_finish(result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun i_o_stream_clear_pending = g_io_stream_clear_pending(this : IOStream*) : Void
  fun i_o_stream_close = g_io_stream_close(this : IOStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun i_o_stream_close_async = g_io_stream_close_async(this : IOStream*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun i_o_stream_close_finish = g_io_stream_close_finish(this : IOStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun i_o_stream_get_input_stream = g_io_stream_get_input_stream(this : IOStream*) : Pointer(LibGio::InputStream)
  fun i_o_stream_get_output_stream = g_io_stream_get_output_stream(this : IOStream*) : Pointer(LibGio::OutputStream)
  fun i_o_stream_has_pending = g_io_stream_has_pending(this : IOStream*) : LibC::Int
  fun i_o_stream_is_closed = g_io_stream_is_closed(this : IOStream*) : LibC::Int
  fun i_o_stream_set_pending = g_io_stream_set_pending(this : IOStream*, error : LibGLib::Error**) : LibC::Int
  fun i_o_stream_splice_async = g_io_stream_splice_async(this : IOStream*, stream2 : Pointer(LibGio::IOStream), flags : LibGio::IOStreamSpliceFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void

  struct InetAddress # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::InetAddressPrivate)
    # Virtual function to_string
    # Property bytes : Pointer(Void)
    # Property family : LibGio::SocketFamily
    # Property is-any : LibC::Int
    # Property is-link-local : LibC::Int
    # Property is-loopback : LibC::Int
    # Property is-mc-global : LibC::Int
    # Property is-mc-link-local : LibC::Int
    # Property is-mc-node-local : LibC::Int
    # Property is-mc-org-local : LibC::Int
    # Property is-mc-site-local : LibC::Int
    # Property is-multicast : LibC::Int
    # Property is-site-local : LibC::Int
  end

  fun _g_inet_address_get_type = g_inet_address_get_type : UInt64
  fun inet_address_new_any = g_inet_address_new_any(family : LibGio::SocketFamily) : Pointer(LibGio::InetAddress)
  fun inet_address_new_from_bytes = g_inet_address_new_from_bytes(bytes : Pointer(UInt8), family : LibGio::SocketFamily) : Pointer(LibGio::InetAddress)
  fun inet_address_new_from_string = g_inet_address_new_from_string(string : Pointer(UInt8)) : Pointer(LibGio::InetAddress)
  fun inet_address_new_loopback = g_inet_address_new_loopback(family : LibGio::SocketFamily) : Pointer(LibGio::InetAddress)
  fun inet_address_equal = g_inet_address_equal(this : InetAddress*, other_address : Pointer(LibGio::InetAddress)) : LibC::Int
  fun inet_address_get_family = g_inet_address_get_family(this : InetAddress*) : LibGio::SocketFamily
  fun inet_address_get_is_any = g_inet_address_get_is_any(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_link_local = g_inet_address_get_is_link_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_loopback = g_inet_address_get_is_loopback(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_mc_global = g_inet_address_get_is_mc_global(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_mc_link_local = g_inet_address_get_is_mc_link_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_mc_node_local = g_inet_address_get_is_mc_node_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_mc_org_local = g_inet_address_get_is_mc_org_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_mc_site_local = g_inet_address_get_is_mc_site_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_multicast = g_inet_address_get_is_multicast(this : InetAddress*) : LibC::Int
  fun inet_address_get_is_site_local = g_inet_address_get_is_site_local(this : InetAddress*) : LibC::Int
  fun inet_address_get_native_size = g_inet_address_get_native_size(this : InetAddress*) : UInt64
  fun inet_address_to_string = g_inet_address_to_string(this : InetAddress*) : Pointer(UInt8)

  struct InetAddressMask # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::InetAddressMaskPrivate)
    # Property address : LibGio::InetAddress
    # Property family : LibGio::SocketFamily
    # Property length : UInt32
  end

  fun _g_inet_address_mask_get_type = g_inet_address_mask_get_type : UInt64
  fun inet_address_mask_new = g_inet_address_mask_new(addr : Pointer(LibGio::InetAddress), length : UInt32, error : LibGLib::Error**) : Pointer(LibGio::InetAddressMask)
  fun inet_address_mask_new_from_string = g_inet_address_mask_new_from_string(mask_string : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::InetAddressMask)
  fun inet_address_mask_equal = g_inet_address_mask_equal(this : InetAddressMask*, mask2 : Pointer(LibGio::InetAddressMask)) : LibC::Int
  fun inet_address_mask_get_address = g_inet_address_mask_get_address(this : InetAddressMask*) : Pointer(LibGio::InetAddress)
  fun inet_address_mask_get_family = g_inet_address_mask_get_family(this : InetAddressMask*) : LibGio::SocketFamily
  fun inet_address_mask_get_length = g_inet_address_mask_get_length(this : InetAddressMask*) : UInt32
  fun inet_address_mask_matches = g_inet_address_mask_matches(this : InetAddressMask*, address : Pointer(LibGio::InetAddress)) : LibC::Int
  fun inet_address_mask_to_string = g_inet_address_mask_to_string(this : InetAddressMask*) : Pointer(UInt8)

  struct InetSocketAddress # object
    parent_instance : LibGio::SocketAddress
    priv : Pointer(LibGio::InetSocketAddressPrivate)
    # Property address : LibGio::InetAddress
    # Property flowinfo : UInt32
    # Property port : UInt32
    # Property scope-id : UInt32
  end

  fun _g_inet_socket_address_get_type = g_inet_socket_address_get_type : UInt64
  fun inet_socket_address_new = g_inet_socket_address_new(address : Pointer(LibGio::InetAddress), port : UInt16) : Pointer(LibGio::SocketAddress)
  fun inet_socket_address_new_from_string = g_inet_socket_address_new_from_string(address : Pointer(UInt8), port : UInt32) : Pointer(LibGio::SocketAddress)
  fun inet_socket_address_get_address = g_inet_socket_address_get_address(this : InetSocketAddress*) : Pointer(LibGio::InetAddress)
  fun inet_socket_address_get_flowinfo = g_inet_socket_address_get_flowinfo(this : InetSocketAddress*) : UInt32
  fun inet_socket_address_get_port = g_inet_socket_address_get_port(this : InetSocketAddress*) : UInt16
  fun inet_socket_address_get_scope_id = g_inet_socket_address_get_scope_id(this : InetSocketAddress*) : UInt32

  struct InputStream # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::InputStreamPrivate)
    # Virtual function close_async
    # Virtual function close_finish
    # Virtual function close_fn
    # Virtual function read_async
    # Virtual function read_finish
    # Virtual function read_fn
    # Virtual function skip
    # Virtual function skip_async
    # Virtual function skip_finish
  end

  fun _g_input_stream_get_type = g_input_stream_get_type : UInt64
  fun input_stream_clear_pending = g_input_stream_clear_pending(this : InputStream*) : Void
  fun input_stream_close = g_input_stream_close(this : InputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun input_stream_close_async = g_input_stream_close_async(this : InputStream*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun input_stream_close_finish = g_input_stream_close_finish(this : InputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun input_stream_has_pending = g_input_stream_has_pending(this : InputStream*) : LibC::Int
  fun input_stream_is_closed = g_input_stream_is_closed(this : InputStream*) : LibC::Int
  fun input_stream_read = g_input_stream_read(this : InputStream*, buffer : Pointer(UInt8)*, count : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun input_stream_read_all = g_input_stream_read_all(this : InputStream*, buffer : Pointer(UInt8)*, count : UInt64*, bytes_read : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun input_stream_read_all_async = g_input_stream_read_all_async(this : InputStream*, buffer : Pointer(UInt8)*, count : UInt64*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun input_stream_read_all_finish = g_input_stream_read_all_finish(this : InputStream*, result : Pointer(LibGio::AsyncResult), bytes_read : UInt64*, error : LibGLib::Error**) : LibC::Int
  fun input_stream_read_async = g_input_stream_read_async(this : InputStream*, buffer : Pointer(UInt8)*, count : UInt64*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun input_stream_read_bytes = g_input_stream_read_bytes(this : InputStream*, count : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun input_stream_read_bytes_async = g_input_stream_read_bytes_async(this : InputStream*, count : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun input_stream_read_bytes_finish = g_input_stream_read_bytes_finish(this : InputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun input_stream_read_finish = g_input_stream_read_finish(this : InputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64
  fun input_stream_set_pending = g_input_stream_set_pending(this : InputStream*, error : LibGLib::Error**) : LibC::Int
  fun input_stream_skip = g_input_stream_skip(this : InputStream*, count : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun input_stream_skip_async = g_input_stream_skip_async(this : InputStream*, count : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun input_stream_skip_finish = g_input_stream_skip_finish(this : InputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64

  struct ListStore # object
    _data : UInt8[0]
    # Property item-type : UInt64
  end

  fun _g_list_store_get_type = g_list_store_get_type : UInt64
  fun list_store_new = g_list_store_new(item_type : UInt64) : Pointer(LibGio::ListStore)
  fun list_store_append = g_list_store_append(this : ListStore*, item : Pointer(LibGObject::Object)) : Void
  fun list_store_find = g_list_store_find(this : ListStore*, item : Pointer(LibGObject::Object), position : UInt32*) : LibC::Int
  fun list_store_find_with_equal_func = g_list_store_find_with_equal_func(this : ListStore*, item : Pointer(LibGObject::Object), equal_func : LibGLib::EqualFunc, position : UInt32*) : LibC::Int
  fun list_store_insert = g_list_store_insert(this : ListStore*, position : UInt32, item : Pointer(LibGObject::Object)) : Void
  fun list_store_insert_sorted = g_list_store_insert_sorted(this : ListStore*, item : Pointer(LibGObject::Object), compare_func : LibGLib::CompareDataFunc, user_data : Pointer(Void)) : UInt32
  fun list_store_remove = g_list_store_remove(this : ListStore*, position : UInt32) : Void
  fun list_store_remove_all = g_list_store_remove_all(this : ListStore*) : Void
  fun list_store_sort = g_list_store_sort(this : ListStore*, compare_func : LibGLib::CompareDataFunc, user_data : Pointer(Void)) : Void
  fun list_store_splice = g_list_store_splice(this : ListStore*, position : UInt32, n_removals : UInt32, additions : Pointer(LibGObject::Object), n_additions : UInt32) : Void

  struct MemoryInputStream # object
    parent_instance : LibGio::InputStream
    priv : Pointer(LibGio::MemoryInputStreamPrivate)
  end

  fun _g_memory_input_stream_get_type = g_memory_input_stream_get_type : UInt64
  fun memory_input_stream_new = g_memory_input_stream_new : Pointer(LibGio::InputStream)
  fun memory_input_stream_new_from_bytes = g_memory_input_stream_new_from_bytes(bytes : Pointer(LibGLib::Bytes)) : Pointer(LibGio::InputStream)
  fun memory_input_stream_new_from_data = g_memory_input_stream_new_from_data(data : Pointer(UInt8), len : Int64, destroy : LibGLib::DestroyNotify) : Pointer(LibGio::InputStream)
  fun memory_input_stream_add_bytes = g_memory_input_stream_add_bytes(this : MemoryInputStream*, bytes : Pointer(LibGLib::Bytes)) : Void
  fun memory_input_stream_add_data = g_memory_input_stream_add_data(this : MemoryInputStream*, data : Pointer(UInt8), len : Int64, destroy : LibGLib::DestroyNotify) : Void

  struct MemoryOutputStream # object
    parent_instance : LibGio::OutputStream
    priv : Pointer(LibGio::MemoryOutputStreamPrivate)
    # Property data : Pointer(Void)
    # Property data-size : UInt64
    # Property size : UInt64
  end

  fun _g_memory_output_stream_get_type = g_memory_output_stream_get_type : UInt64
  fun memory_output_stream_new_resizable = g_memory_output_stream_new_resizable : Pointer(LibGio::OutputStream)
  fun memory_output_stream_get_data = g_memory_output_stream_get_data(this : MemoryOutputStream*) : Pointer(Void)
  fun memory_output_stream_get_data_size = g_memory_output_stream_get_data_size(this : MemoryOutputStream*) : UInt64
  fun memory_output_stream_get_size = g_memory_output_stream_get_size(this : MemoryOutputStream*) : UInt64
  fun memory_output_stream_steal_as_bytes = g_memory_output_stream_steal_as_bytes(this : MemoryOutputStream*) : Pointer(LibGLib::Bytes)
  fun memory_output_stream_steal_data = g_memory_output_stream_steal_data(this : MemoryOutputStream*) : Pointer(Void)

  struct Menu # object
    _data : UInt8[0]
  end

  fun _g_menu_get_type = g_menu_get_type : UInt64
  fun menu_new = g_menu_new : Pointer(LibGio::Menu)
  fun menu_append = g_menu_append(this : Menu*, label : Pointer(UInt8), detailed_action : Pointer(UInt8)) : Void
  fun menu_append_item = g_menu_append_item(this : Menu*, item : Pointer(LibGio::MenuItem)) : Void
  fun menu_append_section = g_menu_append_section(this : Menu*, label : Pointer(UInt8), section : Pointer(LibGio::MenuModel)) : Void
  fun menu_append_submenu = g_menu_append_submenu(this : Menu*, label : Pointer(UInt8), submenu : Pointer(LibGio::MenuModel)) : Void
  fun menu_freeze = g_menu_freeze(this : Menu*) : Void
  fun menu_insert = g_menu_insert(this : Menu*, position : Int32, label : Pointer(UInt8), detailed_action : Pointer(UInt8)) : Void
  fun menu_insert_item = g_menu_insert_item(this : Menu*, position : Int32, item : Pointer(LibGio::MenuItem)) : Void
  fun menu_insert_section = g_menu_insert_section(this : Menu*, position : Int32, label : Pointer(UInt8), section : Pointer(LibGio::MenuModel)) : Void
  fun menu_insert_submenu = g_menu_insert_submenu(this : Menu*, position : Int32, label : Pointer(UInt8), submenu : Pointer(LibGio::MenuModel)) : Void
  fun menu_prepend = g_menu_prepend(this : Menu*, label : Pointer(UInt8), detailed_action : Pointer(UInt8)) : Void
  fun menu_prepend_item = g_menu_prepend_item(this : Menu*, item : Pointer(LibGio::MenuItem)) : Void
  fun menu_prepend_section = g_menu_prepend_section(this : Menu*, label : Pointer(UInt8), section : Pointer(LibGio::MenuModel)) : Void
  fun menu_prepend_submenu = g_menu_prepend_submenu(this : Menu*, label : Pointer(UInt8), submenu : Pointer(LibGio::MenuModel)) : Void
  fun menu_remove = g_menu_remove(this : Menu*, position : Int32) : Void
  fun menu_remove_all = g_menu_remove_all(this : Menu*) : Void

  struct MenuAttributeIter # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::MenuAttributeIterPrivate)
    # Virtual function get_next
  end

  fun _g_menu_attribute_iter_get_type = g_menu_attribute_iter_get_type : UInt64
  fun menu_attribute_iter_get_name = g_menu_attribute_iter_get_name(this : MenuAttributeIter*) : Pointer(UInt8)
  fun menu_attribute_iter_get_next = g_menu_attribute_iter_get_next(this : MenuAttributeIter*, out_name : Pointer(UInt8)*, value : Pointer(LibGLib::Variant)*) : LibC::Int
  fun menu_attribute_iter_get_value = g_menu_attribute_iter_get_value(this : MenuAttributeIter*) : Pointer(LibGLib::Variant)
  fun menu_attribute_iter_next = g_menu_attribute_iter_next(this : MenuAttributeIter*) : LibC::Int

  struct MenuItem # object
    _data : UInt8[0]
  end

  fun _g_menu_item_get_type = g_menu_item_get_type : UInt64
  fun menu_item_new = g_menu_item_new(label : Pointer(UInt8), detailed_action : Pointer(UInt8)) : Pointer(LibGio::MenuItem)
  fun menu_item_new_from_model = g_menu_item_new_from_model(model : Pointer(LibGio::MenuModel), item_index : Int32) : Pointer(LibGio::MenuItem)
  fun menu_item_new_section = g_menu_item_new_section(label : Pointer(UInt8), section : Pointer(LibGio::MenuModel)) : Pointer(LibGio::MenuItem)
  fun menu_item_new_submenu = g_menu_item_new_submenu(label : Pointer(UInt8), submenu : Pointer(LibGio::MenuModel)) : Pointer(LibGio::MenuItem)
  fun menu_item_get_attribute_value = g_menu_item_get_attribute_value(this : MenuItem*, attribute : Pointer(UInt8), expected_type : Pointer(LibGLib::VariantType)) : Pointer(LibGLib::Variant)
  fun menu_item_get_link = g_menu_item_get_link(this : MenuItem*, link : Pointer(UInt8)) : Pointer(LibGio::MenuModel)
  fun menu_item_set_action_and_target_value = g_menu_item_set_action_and_target_value(this : MenuItem*, action : Pointer(UInt8), target_value : Pointer(LibGLib::Variant)) : Void
  fun menu_item_set_attribute_value = g_menu_item_set_attribute_value(this : MenuItem*, attribute : Pointer(UInt8), value : Pointer(LibGLib::Variant)) : Void
  fun menu_item_set_detailed_action = g_menu_item_set_detailed_action(this : MenuItem*, detailed_action : Pointer(UInt8)) : Void
  fun menu_item_set_icon = g_menu_item_set_icon(this : MenuItem*, icon : Pointer(LibGio::Icon)) : Void
  fun menu_item_set_label = g_menu_item_set_label(this : MenuItem*, label : Pointer(UInt8)) : Void
  fun menu_item_set_link = g_menu_item_set_link(this : MenuItem*, link : Pointer(UInt8), model : Pointer(LibGio::MenuModel)) : Void
  fun menu_item_set_section = g_menu_item_set_section(this : MenuItem*, section : Pointer(LibGio::MenuModel)) : Void
  fun menu_item_set_submenu = g_menu_item_set_submenu(this : MenuItem*, submenu : Pointer(LibGio::MenuModel)) : Void

  struct MenuLinkIter # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::MenuLinkIterPrivate)
    # Virtual function get_next
  end

  fun _g_menu_link_iter_get_type = g_menu_link_iter_get_type : UInt64
  fun menu_link_iter_get_name = g_menu_link_iter_get_name(this : MenuLinkIter*) : Pointer(UInt8)
  fun menu_link_iter_get_next = g_menu_link_iter_get_next(this : MenuLinkIter*, out_link : Pointer(UInt8)*, value : Pointer(LibGio::MenuModel)*) : LibC::Int
  fun menu_link_iter_get_value = g_menu_link_iter_get_value(this : MenuLinkIter*) : Pointer(LibGio::MenuModel)
  fun menu_link_iter_next = g_menu_link_iter_next(this : MenuLinkIter*) : LibC::Int

  struct MenuModel # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::MenuModelPrivate)
    # Signal items-changed
    # Virtual function get_item_attribute_value
    # Virtual function get_item_attributes
    # Virtual function get_item_link
    # Virtual function get_item_links
    # Virtual function get_n_items
    # Virtual function is_mutable
    # Virtual function iterate_item_attributes
    # Virtual function iterate_item_links
  end

  fun _g_menu_model_get_type = g_menu_model_get_type : UInt64
  fun menu_model_get_item_attribute_value = g_menu_model_get_item_attribute_value(this : MenuModel*, item_index : Int32, attribute : Pointer(UInt8), expected_type : Pointer(LibGLib::VariantType)) : Pointer(LibGLib::Variant)
  fun menu_model_get_item_link = g_menu_model_get_item_link(this : MenuModel*, item_index : Int32, link : Pointer(UInt8)) : Pointer(LibGio::MenuModel)
  fun menu_model_get_n_items = g_menu_model_get_n_items(this : MenuModel*) : Int32
  fun menu_model_is_mutable = g_menu_model_is_mutable(this : MenuModel*) : LibC::Int
  fun menu_model_items_changed = g_menu_model_items_changed(this : MenuModel*, position : Int32, removed : Int32, added : Int32) : Void
  fun menu_model_iterate_item_attributes = g_menu_model_iterate_item_attributes(this : MenuModel*, item_index : Int32) : Pointer(LibGio::MenuAttributeIter)
  fun menu_model_iterate_item_links = g_menu_model_iterate_item_links(this : MenuModel*, item_index : Int32) : Pointer(LibGio::MenuLinkIter)

  struct MountOperation # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::MountOperationPrivate)
    # Signal aborted
    # Signal ask-password
    # Signal ask-question
    # Signal reply
    # Signal show-processes
    # Signal show-unmount-progress
    # Virtual function aborted
    # Virtual function ask_password
    # Virtual function ask_question
    # Virtual function reply
    # Virtual function show_processes
    # Virtual function show_unmount_progress
    # Property anonymous : LibC::Int
    # Property choice : Int32
    # Property domain : Pointer(UInt8)
    # Property is-tcrypt-hidden-volume : LibC::Int
    # Property is-tcrypt-system-volume : LibC::Int
    # Property password : Pointer(UInt8)
    # Property password-save : LibGio::PasswordSave
    # Property pim : UInt32
    # Property username : Pointer(UInt8)
  end

  fun _g_mount_operation_get_type = g_mount_operation_get_type : UInt64
  fun mount_operation_new = g_mount_operation_new : Pointer(LibGio::MountOperation)
  fun mount_operation_get_anonymous = g_mount_operation_get_anonymous(this : MountOperation*) : LibC::Int
  fun mount_operation_get_choice = g_mount_operation_get_choice(this : MountOperation*) : Int32
  fun mount_operation_get_domain = g_mount_operation_get_domain(this : MountOperation*) : Pointer(UInt8)
  fun mount_operation_get_is_tcrypt_hidden_volume = g_mount_operation_get_is_tcrypt_hidden_volume(this : MountOperation*) : LibC::Int
  fun mount_operation_get_is_tcrypt_system_volume = g_mount_operation_get_is_tcrypt_system_volume(this : MountOperation*) : LibC::Int
  fun mount_operation_get_password = g_mount_operation_get_password(this : MountOperation*) : Pointer(UInt8)
  fun mount_operation_get_password_save = g_mount_operation_get_password_save(this : MountOperation*) : LibGio::PasswordSave
  fun mount_operation_get_pim = g_mount_operation_get_pim(this : MountOperation*) : UInt32
  fun mount_operation_get_username = g_mount_operation_get_username(this : MountOperation*) : Pointer(UInt8)
  fun mount_operation_reply = g_mount_operation_reply(this : MountOperation*, result : LibGio::MountOperationResult) : Void
  fun mount_operation_set_anonymous = g_mount_operation_set_anonymous(this : MountOperation*, anonymous : LibC::Int) : Void
  fun mount_operation_set_choice = g_mount_operation_set_choice(this : MountOperation*, choice : Int32) : Void
  fun mount_operation_set_domain = g_mount_operation_set_domain(this : MountOperation*, domain : Pointer(UInt8)) : Void
  fun mount_operation_set_is_tcrypt_hidden_volume = g_mount_operation_set_is_tcrypt_hidden_volume(this : MountOperation*, hidden_volume : LibC::Int) : Void
  fun mount_operation_set_is_tcrypt_system_volume = g_mount_operation_set_is_tcrypt_system_volume(this : MountOperation*, system_volume : LibC::Int) : Void
  fun mount_operation_set_password = g_mount_operation_set_password(this : MountOperation*, password : Pointer(UInt8)) : Void
  fun mount_operation_set_password_save = g_mount_operation_set_password_save(this : MountOperation*, save : LibGio::PasswordSave) : Void
  fun mount_operation_set_pim = g_mount_operation_set_pim(this : MountOperation*, pim : UInt32) : Void
  fun mount_operation_set_username = g_mount_operation_set_username(this : MountOperation*, username : Pointer(UInt8)) : Void

  struct NativeSocketAddress # object
    parent_instance : LibGio::SocketAddress
    priv : Pointer(LibGio::NativeSocketAddressPrivate)
  end

  fun _g_native_socket_address_get_type = g_native_socket_address_get_type : UInt64
  fun native_socket_address_new = g_native_socket_address_new(native : Pointer(Void), len : UInt64) : Pointer(LibGio::SocketAddress)

  struct NativeVolumeMonitor # object
    parent_instance : LibGio::VolumeMonitor
  end

  fun _g_native_volume_monitor_get_type = g_native_volume_monitor_get_type : UInt64

  struct NetworkAddress # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::NetworkAddressPrivate)
    # Property hostname : Pointer(UInt8)
    # Property port : UInt32
    # Property scheme : Pointer(UInt8)
  end

  fun _g_network_address_get_type = g_network_address_get_type : UInt64
  fun network_address_new = g_network_address_new(hostname : Pointer(UInt8), port : UInt16) : Pointer(LibGio::NetworkAddress)
  fun network_address_new_loopback = g_network_address_new_loopback(port : UInt16) : Pointer(LibGio::NetworkAddress)
  fun network_address_parse = g_network_address_parse(host_and_port : Pointer(UInt8), default_port : UInt16, error : LibGLib::Error**) : Pointer(LibGio::NetworkAddress)
  fun network_address_parse_uri = g_network_address_parse_uri(uri : Pointer(UInt8), default_port : UInt16, error : LibGLib::Error**) : Pointer(LibGio::NetworkAddress)
  fun network_address_get_hostname = g_network_address_get_hostname(this : NetworkAddress*) : Pointer(UInt8)
  fun network_address_get_port = g_network_address_get_port(this : NetworkAddress*) : UInt16
  fun network_address_get_scheme = g_network_address_get_scheme(this : NetworkAddress*) : Pointer(UInt8)

  struct NetworkService # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::NetworkServicePrivate)
    # Property domain : Pointer(UInt8)
    # Property protocol : Pointer(UInt8)
    # Property scheme : Pointer(UInt8)
    # Property service : Pointer(UInt8)
  end

  fun _g_network_service_get_type = g_network_service_get_type : UInt64
  fun network_service_new = g_network_service_new(service : Pointer(UInt8), protocol : Pointer(UInt8), domain : Pointer(UInt8)) : Pointer(LibGio::NetworkService)
  fun network_service_get_domain = g_network_service_get_domain(this : NetworkService*) : Pointer(UInt8)
  fun network_service_get_protocol = g_network_service_get_protocol(this : NetworkService*) : Pointer(UInt8)
  fun network_service_get_scheme = g_network_service_get_scheme(this : NetworkService*) : Pointer(UInt8)
  fun network_service_get_service = g_network_service_get_service(this : NetworkService*) : Pointer(UInt8)
  fun network_service_set_scheme = g_network_service_set_scheme(this : NetworkService*, scheme : Pointer(UInt8)) : Void

  struct Notification # object
    _data : UInt8[0]
  end

  fun _g_notification_get_type = g_notification_get_type : UInt64
  fun notification_new = g_notification_new(title : Pointer(UInt8)) : Pointer(LibGio::Notification)
  fun notification_add_button = g_notification_add_button(this : Notification*, label : Pointer(UInt8), detailed_action : Pointer(UInt8)) : Void
  fun notification_add_button_with_target = g_notification_add_button_with_target_value(this : Notification*, label : Pointer(UInt8), action : Pointer(UInt8), target : Pointer(LibGLib::Variant)) : Void
  fun notification_set_body = g_notification_set_body(this : Notification*, body : Pointer(UInt8)) : Void
  fun notification_set_default_action = g_notification_set_default_action(this : Notification*, detailed_action : Pointer(UInt8)) : Void
  fun notification_set_default_action_and_target = g_notification_set_default_action_and_target_value(this : Notification*, action : Pointer(UInt8), target : Pointer(LibGLib::Variant)) : Void
  fun notification_set_icon = g_notification_set_icon(this : Notification*, icon : Pointer(LibGio::Icon)) : Void
  fun notification_set_priority = g_notification_set_priority(this : Notification*, priority : LibGio::NotificationPriority) : Void
  fun notification_set_title = g_notification_set_title(this : Notification*, title : Pointer(UInt8)) : Void
  fun notification_set_urgent = g_notification_set_urgent(this : Notification*, urgent : LibC::Int) : Void

  struct OutputStream # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::OutputStreamPrivate)
    # Virtual function close_async
    # Virtual function close_finish
    # Virtual function close_fn
    # Virtual function flush
    # Virtual function flush_async
    # Virtual function flush_finish
    # Virtual function splice
    # Virtual function splice_async
    # Virtual function splice_finish
    # Virtual function write_async
    # Virtual function write_finish
    # Virtual function write_fn
    # Virtual function writev_async
    # Virtual function writev_finish
    # Virtual function writev_fn
  end

  fun _g_output_stream_get_type = g_output_stream_get_type : UInt64
  fun output_stream_clear_pending = g_output_stream_clear_pending(this : OutputStream*) : Void
  fun output_stream_close = g_output_stream_close(this : OutputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun output_stream_close_async = g_output_stream_close_async(this : OutputStream*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_close_finish = g_output_stream_close_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun output_stream_flush = g_output_stream_flush(this : OutputStream*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun output_stream_flush_async = g_output_stream_flush_async(this : OutputStream*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_flush_finish = g_output_stream_flush_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun output_stream_has_pending = g_output_stream_has_pending(this : OutputStream*) : LibC::Int
  fun output_stream_is_closed = g_output_stream_is_closed(this : OutputStream*) : LibC::Int
  fun output_stream_is_closing = g_output_stream_is_closing(this : OutputStream*) : LibC::Int
  fun output_stream_set_pending = g_output_stream_set_pending(this : OutputStream*, error : LibGLib::Error**) : LibC::Int
  fun output_stream_splice = g_output_stream_splice(this : OutputStream*, source : Pointer(LibGio::InputStream), flags : LibGio::OutputStreamSpliceFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun output_stream_splice_async = g_output_stream_splice_async(this : OutputStream*, source : Pointer(LibGio::InputStream), flags : LibGio::OutputStreamSpliceFlags, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_splice_finish = g_output_stream_splice_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64
  fun output_stream_write = g_output_stream_write(this : OutputStream*, buffer : Pointer(UInt8), count : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun output_stream_write_all = g_output_stream_write_all(this : OutputStream*, buffer : Pointer(UInt8), count : UInt64, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun output_stream_write_all_async = g_output_stream_write_all_async(this : OutputStream*, buffer : Pointer(UInt8), count : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_write_all_finish = g_output_stream_write_all_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), bytes_written : UInt64*, error : LibGLib::Error**) : LibC::Int
  fun output_stream_write_async = g_output_stream_write_async(this : OutputStream*, buffer : Pointer(UInt8), count : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_write_bytes = g_output_stream_write_bytes(this : OutputStream*, bytes : Pointer(LibGLib::Bytes), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun output_stream_write_bytes_async = g_output_stream_write_bytes_async(this : OutputStream*, bytes : Pointer(LibGLib::Bytes), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_write_bytes_finish = g_output_stream_write_bytes_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64
  fun output_stream_write_finish = g_output_stream_write_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Int64
  fun output_stream_writev = g_output_stream_writev(this : OutputStream*, vectors : Pointer(LibGio::OutputVector), n_vectors : UInt64, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun output_stream_writev_all = g_output_stream_writev_all(this : OutputStream*, vectors : Pointer(LibGio::OutputVector), n_vectors : UInt64, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun output_stream_writev_all_async = g_output_stream_writev_all_async(this : OutputStream*, vectors : Pointer(LibGio::OutputVector), n_vectors : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_writev_all_finish = g_output_stream_writev_all_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), bytes_written : UInt64*, error : LibGLib::Error**) : LibC::Int
  fun output_stream_writev_async = g_output_stream_writev_async(this : OutputStream*, vectors : Pointer(LibGio::OutputVector), n_vectors : UInt64, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun output_stream_writev_finish = g_output_stream_writev_finish(this : OutputStream*, result : Pointer(LibGio::AsyncResult), bytes_written : UInt64*, error : LibGLib::Error**) : LibC::Int

  struct Permission # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::PermissionPrivate)
    # Virtual function acquire
    # Virtual function acquire_async
    # Virtual function acquire_finish
    # Virtual function release
    # Virtual function release_async
    # Virtual function release_finish
    # Property allowed : LibC::Int
    # Property can-acquire : LibC::Int
    # Property can-release : LibC::Int
  end

  fun _g_permission_get_type = g_permission_get_type : UInt64
  fun permission_acquire = g_permission_acquire(this : Permission*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun permission_acquire_async = g_permission_acquire_async(this : Permission*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun permission_acquire_finish = g_permission_acquire_finish(this : Permission*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun permission_get_allowed = g_permission_get_allowed(this : Permission*) : LibC::Int
  fun permission_get_can_acquire = g_permission_get_can_acquire(this : Permission*) : LibC::Int
  fun permission_get_can_release = g_permission_get_can_release(this : Permission*) : LibC::Int
  fun permission_impl_update = g_permission_impl_update(this : Permission*, allowed : LibC::Int, can_acquire : LibC::Int, can_release : LibC::Int) : Void
  fun permission_release = g_permission_release(this : Permission*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun permission_release_async = g_permission_release_async(this : Permission*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun permission_release_finish = g_permission_release_finish(this : Permission*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int

  struct PropertyAction # object
    _data : UInt8[0]
    # Property enabled : LibC::Int
    # Property invert-boolean : LibC::Int
    # Property name : Pointer(UInt8)
    # Property object : LibGObject::Object
    # Property parameter-type : LibGLib::VariantType
    # Property property-name : Pointer(UInt8)
    # Property state : LibGLib::Variant
    # Property state-type : LibGLib::VariantType
  end

  fun _g_property_action_get_type = g_property_action_get_type : UInt64
  fun property_action_new = g_property_action_new(name : Pointer(UInt8), object : Pointer(LibGObject::Object), property_name : Pointer(UInt8)) : Pointer(LibGio::PropertyAction)

  struct ProxyAddress # object
    parent_instance : LibGio::InetSocketAddress
    priv : Pointer(LibGio::ProxyAddressPrivate)
    # Property destination-hostname : Pointer(UInt8)
    # Property destination-port : UInt32
    # Property destination-protocol : Pointer(UInt8)
    # Property password : Pointer(UInt8)
    # Property protocol : Pointer(UInt8)
    # Property uri : Pointer(UInt8)
    # Property username : Pointer(UInt8)
  end

  fun _g_proxy_address_get_type = g_proxy_address_get_type : UInt64
  fun proxy_address_new = g_proxy_address_new(inetaddr : Pointer(LibGio::InetAddress), port : UInt16, protocol : Pointer(UInt8), dest_hostname : Pointer(UInt8), dest_port : UInt16, username : Pointer(UInt8), password : Pointer(UInt8)) : Pointer(LibGio::SocketAddress)
  fun proxy_address_get_destination_hostname = g_proxy_address_get_destination_hostname(this : ProxyAddress*) : Pointer(UInt8)
  fun proxy_address_get_destination_port = g_proxy_address_get_destination_port(this : ProxyAddress*) : UInt16
  fun proxy_address_get_destination_protocol = g_proxy_address_get_destination_protocol(this : ProxyAddress*) : Pointer(UInt8)
  fun proxy_address_get_password = g_proxy_address_get_password(this : ProxyAddress*) : Pointer(UInt8)
  fun proxy_address_get_protocol = g_proxy_address_get_protocol(this : ProxyAddress*) : Pointer(UInt8)
  fun proxy_address_get_uri = g_proxy_address_get_uri(this : ProxyAddress*) : Pointer(UInt8)
  fun proxy_address_get_username = g_proxy_address_get_username(this : ProxyAddress*) : Pointer(UInt8)

  struct ProxyAddressEnumerator # object
    parent_instance : LibGio::SocketAddressEnumerator
    priv : Pointer(LibGio::ProxyAddressEnumeratorPrivate)
    # Property connectable : LibGio::SocketConnectable
    # Property default-port : UInt32
    # Property proxy-resolver : LibGio::ProxyResolver
    # Property uri : Pointer(UInt8)
  end

  fun _g_proxy_address_enumerator_get_type = g_proxy_address_enumerator_get_type : UInt64

  struct Resolver # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::ResolverPrivate)
    # Signal reload
    # Virtual function lookup_by_address
    # Virtual function lookup_by_address_async
    # Virtual function lookup_by_address_finish
    # Virtual function lookup_by_name
    # Virtual function lookup_by_name_async
    # Virtual function lookup_by_name_finish
    # Virtual function lookup_by_name_with_flags
    # Virtual function lookup_by_name_with_flags_async
    # Virtual function lookup_by_name_with_flags_finish
    # Virtual function lookup_records
    # Virtual function lookup_records_async
    # Virtual function lookup_records_finish
    # Virtual function lookup_service_async
    # Virtual function lookup_service_finish
    # Virtual function reload
  end

  fun _g_resolver_get_type = g_resolver_get_type : UInt64
  fun resolver_get_default = g_resolver_get_default : Pointer(LibGio::Resolver)
  fun resolver_lookup_by_address = g_resolver_lookup_by_address(this : Resolver*, address : Pointer(LibGio::InetAddress), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun resolver_lookup_by_address_async = g_resolver_lookup_by_address_async(this : Resolver*, address : Pointer(LibGio::InetAddress), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun resolver_lookup_by_address_finish = g_resolver_lookup_by_address_finish(this : Resolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(UInt8)
  fun resolver_lookup_by_name = g_resolver_lookup_by_name(this : Resolver*, hostname : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_by_name_async = g_resolver_lookup_by_name_async(this : Resolver*, hostname : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun resolver_lookup_by_name_finish = g_resolver_lookup_by_name_finish(this : Resolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_by_name_with_flags = g_resolver_lookup_by_name_with_flags(this : Resolver*, hostname : Pointer(UInt8), flags : LibGio::ResolverNameLookupFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_by_name_with_flags_async = g_resolver_lookup_by_name_with_flags_async(this : Resolver*, hostname : Pointer(UInt8), flags : LibGio::ResolverNameLookupFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun resolver_lookup_by_name_with_flags_finish = g_resolver_lookup_by_name_with_flags_finish(this : Resolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_records = g_resolver_lookup_records(this : Resolver*, rrname : Pointer(UInt8), record_type : LibGio::ResolverRecordType, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_records_async = g_resolver_lookup_records_async(this : Resolver*, rrname : Pointer(UInt8), record_type : LibGio::ResolverRecordType, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun resolver_lookup_records_finish = g_resolver_lookup_records_finish(this : Resolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_service = g_resolver_lookup_service(this : Resolver*, service : Pointer(UInt8), protocol : Pointer(UInt8), domain : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_lookup_service_async = g_resolver_lookup_service_async(this : Resolver*, service : Pointer(UInt8), protocol : Pointer(UInt8), domain : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun resolver_lookup_service_finish = g_resolver_lookup_service_finish(this : Resolver*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun resolver_set_default = g_resolver_set_default(this : Resolver*) : Void

  struct Settings # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SettingsPrivate)
    # Signal change-event
    # Signal changed
    # Signal writable-change-event
    # Signal writable-changed
    # Virtual function change_event
    # Virtual function changed
    # Virtual function writable_change_event
    # Virtual function writable_changed
    # Property backend : LibGio::SettingsBackend
    # Property delay-apply : LibC::Int
    # Property has-unapplied : LibC::Int
    # Property path : Pointer(UInt8)
    # Property schema : Pointer(UInt8)
    # Property schema-id : Pointer(UInt8)
    # Property settings-schema : LibGio::SettingsSchema
  end

  fun _g_settings_get_type = g_settings_get_type : UInt64
  fun settings_new = g_settings_new(schema_id : Pointer(UInt8)) : Pointer(LibGio::Settings)
  fun settings_new_full = g_settings_new_full(schema : Pointer(LibGio::SettingsSchema), backend : Pointer(LibGio::SettingsBackend), path : Pointer(UInt8)) : Pointer(LibGio::Settings)
  fun settings_new_with_backend = g_settings_new_with_backend(schema_id : Pointer(UInt8), backend : Pointer(LibGio::SettingsBackend)) : Pointer(LibGio::Settings)
  fun settings_new_with_backend_and_path = g_settings_new_with_backend_and_path(schema_id : Pointer(UInt8), backend : Pointer(LibGio::SettingsBackend), path : Pointer(UInt8)) : Pointer(LibGio::Settings)
  fun settings_new_with_path = g_settings_new_with_path(schema_id : Pointer(UInt8), path : Pointer(UInt8)) : Pointer(LibGio::Settings)
  fun settings_list_relocatable_schemas = g_settings_list_relocatable_schemas : Pointer(Pointer(UInt8))
  fun settings_list_schemas = g_settings_list_schemas : Pointer(Pointer(UInt8))
  fun settings_sync = g_settings_sync : Void
  fun settings_unbind = g_settings_unbind(object : Pointer(LibGObject::Object), property : Pointer(UInt8)) : Void
  fun settings_apply = g_settings_apply(this : Settings*) : Void
  fun settings_bind = g_settings_bind(this : Settings*, key : Pointer(UInt8), object : Pointer(LibGObject::Object), property : Pointer(UInt8), flags : LibGio::SettingsBindFlags) : Void
  fun settings_bind_writable = g_settings_bind_writable(this : Settings*, key : Pointer(UInt8), object : Pointer(LibGObject::Object), property : Pointer(UInt8), inverted : LibC::Int) : Void
  fun settings_create_action = g_settings_create_action(this : Settings*, key : Pointer(UInt8)) : Pointer(LibGio::Action)
  fun settings_delay = g_settings_delay(this : Settings*) : Void
  fun settings_get_boolean = g_settings_get_boolean(this : Settings*, key : Pointer(UInt8)) : LibC::Int
  fun settings_get_child = g_settings_get_child(this : Settings*, name : Pointer(UInt8)) : Pointer(LibGio::Settings)
  fun settings_get_default_value = g_settings_get_default_value(this : Settings*, key : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun settings_get_double = g_settings_get_double(this : Settings*, key : Pointer(UInt8)) : Float64
  fun settings_get_enum = g_settings_get_enum(this : Settings*, key : Pointer(UInt8)) : Int32
  fun settings_get_flags = g_settings_get_flags(this : Settings*, key : Pointer(UInt8)) : UInt32
  fun settings_get_has_unapplied = g_settings_get_has_unapplied(this : Settings*) : LibC::Int
  fun settings_get_int = g_settings_get_int(this : Settings*, key : Pointer(UInt8)) : Int32
  fun settings_get_int64 = g_settings_get_int64(this : Settings*, key : Pointer(UInt8)) : Int64
  fun settings_get_mapped = g_settings_get_mapped(this : Settings*, key : Pointer(UInt8), mapping : LibGio::SettingsGetMapping, user_data : Pointer(Void)) : Pointer(Void)
  fun settings_get_range = g_settings_get_range(this : Settings*, key : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun settings_get_string = g_settings_get_string(this : Settings*, key : Pointer(UInt8)) : Pointer(UInt8)
  fun settings_get_strv = g_settings_get_strv(this : Settings*, key : Pointer(UInt8)) : Pointer(Pointer(UInt8))
  fun settings_get_uint = g_settings_get_uint(this : Settings*, key : Pointer(UInt8)) : UInt32
  fun settings_get_uint64 = g_settings_get_uint64(this : Settings*, key : Pointer(UInt8)) : UInt64
  fun settings_get_user_value = g_settings_get_user_value(this : Settings*, key : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun settings_get_value = g_settings_get_value(this : Settings*, key : Pointer(UInt8)) : Pointer(LibGLib::Variant)
  fun settings_is_writable = g_settings_is_writable(this : Settings*, name : Pointer(UInt8)) : LibC::Int
  fun settings_list_children = g_settings_list_children(this : Settings*) : Pointer(Pointer(UInt8))
  fun settings_list_keys = g_settings_list_keys(this : Settings*) : Pointer(Pointer(UInt8))
  fun settings_range_check = g_settings_range_check(this : Settings*, key : Pointer(UInt8), value : Pointer(LibGLib::Variant)) : LibC::Int
  fun settings_reset = g_settings_reset(this : Settings*, key : Pointer(UInt8)) : Void
  fun settings_revert = g_settings_revert(this : Settings*) : Void
  fun settings_set_boolean = g_settings_set_boolean(this : Settings*, key : Pointer(UInt8), value : LibC::Int) : LibC::Int
  fun settings_set_double = g_settings_set_double(this : Settings*, key : Pointer(UInt8), value : Float64) : LibC::Int
  fun settings_set_enum = g_settings_set_enum(this : Settings*, key : Pointer(UInt8), value : Int32) : LibC::Int
  fun settings_set_flags = g_settings_set_flags(this : Settings*, key : Pointer(UInt8), value : UInt32) : LibC::Int
  fun settings_set_int = g_settings_set_int(this : Settings*, key : Pointer(UInt8), value : Int32) : LibC::Int
  fun settings_set_int64 = g_settings_set_int64(this : Settings*, key : Pointer(UInt8), value : Int64) : LibC::Int
  fun settings_set_string = g_settings_set_string(this : Settings*, key : Pointer(UInt8), value : Pointer(UInt8)) : LibC::Int
  fun settings_set_strv = g_settings_set_strv(this : Settings*, key : Pointer(UInt8), value : Pointer(Pointer(UInt8))) : LibC::Int
  fun settings_set_uint = g_settings_set_uint(this : Settings*, key : Pointer(UInt8), value : UInt32) : LibC::Int
  fun settings_set_uint64 = g_settings_set_uint64(this : Settings*, key : Pointer(UInt8), value : UInt64) : LibC::Int
  fun settings_set_value = g_settings_set_value(this : Settings*, key : Pointer(UInt8), value : Pointer(LibGLib::Variant)) : LibC::Int

  struct SettingsBackend # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SettingsBackendPrivate)
    # Virtual function get_writable
    # Virtual function read
    # Virtual function read_user_value
    # Virtual function reset
    # Virtual function subscribe
    # Virtual function sync
    # Virtual function unsubscribe
    # Virtual function write
    # Virtual function write_tree
  end

  fun _g_settings_backend_get_type = g_settings_backend_get_type : UInt64
  fun settings_backend_flatten_tree = g_settings_backend_flatten_tree(tree : Pointer(LibGLib::Tree), path : Pointer(UInt8)*, keys : Pointer(Pointer(UInt8))*, values : Pointer(Pointer(LibGLib::Variant))*) : Void
  fun settings_backend_get_default = g_settings_backend_get_default : Pointer(LibGio::SettingsBackend)
  fun settings_backend_changed = g_settings_backend_changed(this : SettingsBackend*, key : Pointer(UInt8), origin_tag : Pointer(Void)) : Void
  fun settings_backend_changed_tree = g_settings_backend_changed_tree(this : SettingsBackend*, tree : Pointer(LibGLib::Tree), origin_tag : Pointer(Void)) : Void
  fun settings_backend_keys_changed = g_settings_backend_keys_changed(this : SettingsBackend*, path : Pointer(UInt8), items : Pointer(Pointer(UInt8)), origin_tag : Pointer(Void)) : Void
  fun settings_backend_path_changed = g_settings_backend_path_changed(this : SettingsBackend*, path : Pointer(UInt8), origin_tag : Pointer(Void)) : Void
  fun settings_backend_path_writable_changed = g_settings_backend_path_writable_changed(this : SettingsBackend*, path : Pointer(UInt8)) : Void
  fun settings_backend_writable_changed = g_settings_backend_writable_changed(this : SettingsBackend*, key : Pointer(UInt8)) : Void

  struct SimpleAction # object
    _data : UInt8[0]
    # Signal activate
    # Signal change-state
    # Property enabled : LibC::Int
    # Property name : Pointer(UInt8)
    # Property parameter-type : LibGLib::VariantType
    # Property state : LibGLib::Variant
    # Property state-type : LibGLib::VariantType
  end

  fun _g_simple_action_get_type = g_simple_action_get_type : UInt64
  fun simple_action_new = g_simple_action_new(name : Pointer(UInt8), parameter_type : Pointer(LibGLib::VariantType)) : Pointer(LibGio::SimpleAction)
  fun simple_action_new_stateful = g_simple_action_new_stateful(name : Pointer(UInt8), parameter_type : Pointer(LibGLib::VariantType), state : Pointer(LibGLib::Variant)) : Pointer(LibGio::SimpleAction)
  fun simple_action_set_enabled = g_simple_action_set_enabled(this : SimpleAction*, enabled : LibC::Int) : Void
  fun simple_action_set_state = g_simple_action_set_state(this : SimpleAction*, value : Pointer(LibGLib::Variant)) : Void
  fun simple_action_set_state_hint = g_simple_action_set_state_hint(this : SimpleAction*, state_hint : Pointer(LibGLib::Variant)) : Void

  struct SimpleActionGroup # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SimpleActionGroupPrivate)
  end

  fun _g_simple_action_group_get_type = g_simple_action_group_get_type : UInt64
  fun simple_action_group_new = g_simple_action_group_new : Pointer(LibGio::SimpleActionGroup)
  fun simple_action_group_add_entries = g_simple_action_group_add_entries(this : SimpleActionGroup*, entries : Pointer(LibGio::ActionEntry), n_entries : Int32, user_data : Pointer(Void)) : Void
  fun simple_action_group_insert = g_simple_action_group_insert(this : SimpleActionGroup*, action : Pointer(LibGio::Action)) : Void
  fun simple_action_group_lookup = g_simple_action_group_lookup(this : SimpleActionGroup*, action_name : Pointer(UInt8)) : Pointer(LibGio::Action)
  fun simple_action_group_remove = g_simple_action_group_remove(this : SimpleActionGroup*, action_name : Pointer(UInt8)) : Void

  struct SimpleAsyncResult # object
    _data : UInt8[0]
  end

  fun _g_simple_async_result_get_type = g_simple_async_result_get_type : UInt64
  fun simple_async_result_new = g_simple_async_result_new(source_object : Pointer(LibGObject::Object), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void), source_tag : Pointer(Void)) : Pointer(LibGio::SimpleAsyncResult)
  fun simple_async_result_new_from_error = g_simple_async_result_new_from_error(source_object : Pointer(LibGObject::Object), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void), error : Pointer(LibGLib::Error*)) : Pointer(LibGio::SimpleAsyncResult)
  fun simple_async_result_is_valid = g_simple_async_result_is_valid(result : Pointer(LibGio::AsyncResult), source : Pointer(LibGObject::Object), source_tag : Pointer(Void)) : LibC::Int
  fun simple_async_result_complete = g_simple_async_result_complete(this : SimpleAsyncResult*) : Void
  fun simple_async_result_complete_in_idle = g_simple_async_result_complete_in_idle(this : SimpleAsyncResult*) : Void
  fun simple_async_result_get_op_res_gboolean = g_simple_async_result_get_op_res_gboolean(this : SimpleAsyncResult*) : LibC::Int
  fun simple_async_result_get_op_res_gssize = g_simple_async_result_get_op_res_gssize(this : SimpleAsyncResult*) : Int64
  fun simple_async_result_propagate_error = g_simple_async_result_propagate_error(this : SimpleAsyncResult*, error : LibGLib::Error**) : LibC::Int
  fun simple_async_result_set_check_cancellable = g_simple_async_result_set_check_cancellable(this : SimpleAsyncResult*, check_cancellable : Pointer(LibGio::Cancellable)) : Void
  fun simple_async_result_set_from_error = g_simple_async_result_set_from_error(this : SimpleAsyncResult*, error : Pointer(LibGLib::Error*)) : Void
  fun simple_async_result_set_handle_cancellation = g_simple_async_result_set_handle_cancellation(this : SimpleAsyncResult*, handle_cancellation : LibC::Int) : Void
  fun simple_async_result_set_op_res_gboolean = g_simple_async_result_set_op_res_gboolean(this : SimpleAsyncResult*, op_res : LibC::Int) : Void
  fun simple_async_result_set_op_res_gssize = g_simple_async_result_set_op_res_gssize(this : SimpleAsyncResult*, op_res : Int64) : Void

  struct SimpleIOStream # object
    _data : UInt8[0]
    # Property input-stream : LibGio::InputStream
    # Property output-stream : LibGio::OutputStream
  end

  fun _g_simple_io_stream_get_type = g_simple_io_stream_get_type : UInt64
  fun simple_i_o_stream_new = g_simple_io_stream_new(input_stream : Pointer(LibGio::InputStream), output_stream : Pointer(LibGio::OutputStream)) : Pointer(LibGio::IOStream)

  struct SimplePermission # object
    _data : UInt8[0]
  end

  fun _g_simple_permission_get_type = g_simple_permission_get_type : UInt64
  fun simple_permission_new = g_simple_permission_new(allowed : LibC::Int) : Pointer(LibGio::Permission)

  struct SimpleProxyResolver # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SimpleProxyResolverPrivate)
    # Property default-proxy : Pointer(UInt8)
    # Property ignore-hosts : Pointer(Pointer(UInt8))
  end

  fun _g_simple_proxy_resolver_get_type = g_simple_proxy_resolver_get_type : UInt64
  fun simple_proxy_resolver_new = g_simple_proxy_resolver_new(default_proxy : Pointer(UInt8), ignore_hosts : Pointer(UInt8)) : Pointer(LibGio::ProxyResolver)
  fun simple_proxy_resolver_set_default_proxy = g_simple_proxy_resolver_set_default_proxy(this : SimpleProxyResolver*, default_proxy : Pointer(UInt8)) : Void
  fun simple_proxy_resolver_set_ignore_hosts = g_simple_proxy_resolver_set_ignore_hosts(this : SimpleProxyResolver*, ignore_hosts : Pointer(UInt8)) : Void
  fun simple_proxy_resolver_set_uri_proxy = g_simple_proxy_resolver_set_uri_proxy(this : SimpleProxyResolver*, uri_scheme : Pointer(UInt8), proxy : Pointer(UInt8)) : Void

  struct Socket # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SocketPrivate)
    # Property blocking : LibC::Int
    # Property broadcast : LibC::Int
    # Property family : LibGio::SocketFamily
    # Property fd : Int32
    # Property keepalive : LibC::Int
    # Property listen-backlog : Int32
    # Property local-address : LibGio::SocketAddress
    # Property multicast-loopback : LibC::Int
    # Property multicast-ttl : UInt32
    # Property protocol : LibGio::SocketProtocol
    # Property remote-address : LibGio::SocketAddress
    # Property timeout : UInt32
    # Property ttl : UInt32
    # Property type : LibGio::SocketType
  end

  fun _g_socket_get_type = g_socket_get_type : UInt64
  fun socket_new = g_socket_new(family : LibGio::SocketFamily, type : LibGio::SocketType, protocol : LibGio::SocketProtocol, error : LibGLib::Error**) : Pointer(LibGio::Socket)
  fun socket_new_from_fd = g_socket_new_from_fd(fd : Int32, error : LibGLib::Error**) : Pointer(LibGio::Socket)
  fun socket_accept = g_socket_accept(this : Socket*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::Socket)
  fun socket_bind = g_socket_bind(this : Socket*, address : Pointer(LibGio::SocketAddress), allow_reuse : LibC::Int, error : LibGLib::Error**) : LibC::Int
  fun socket_check_connect_result = g_socket_check_connect_result(this : Socket*, error : LibGLib::Error**) : LibC::Int
  fun socket_close = g_socket_close(this : Socket*, error : LibGLib::Error**) : LibC::Int
  fun socket_condition_check = g_socket_condition_check(this : Socket*, condition : LibGLib::IOCondition) : LibGLib::IOCondition
  fun socket_condition_timed_wait = g_socket_condition_timed_wait(this : Socket*, condition : LibGLib::IOCondition, timeout_us : Int64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun socket_condition_wait = g_socket_condition_wait(this : Socket*, condition : LibGLib::IOCondition, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun socket_connect = g_socket_connect(this : Socket*, address : Pointer(LibGio::SocketAddress), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun socket_connection_factory_create_connection = g_socket_connection_factory_create_connection(this : Socket*) : Pointer(LibGio::SocketConnection)
  fun socket_get_available_bytes = g_socket_get_available_bytes(this : Socket*) : Int64
  fun socket_get_blocking = g_socket_get_blocking(this : Socket*) : LibC::Int
  fun socket_get_broadcast = g_socket_get_broadcast(this : Socket*) : LibC::Int
  fun socket_get_credentials = g_socket_get_credentials(this : Socket*, error : LibGLib::Error**) : Pointer(LibGio::Credentials)
  fun socket_get_family = g_socket_get_family(this : Socket*) : LibGio::SocketFamily
  fun socket_get_fd = g_socket_get_fd(this : Socket*) : Int32
  fun socket_get_keepalive = g_socket_get_keepalive(this : Socket*) : LibC::Int
  fun socket_get_listen_backlog = g_socket_get_listen_backlog(this : Socket*) : Int32
  fun socket_get_local_address = g_socket_get_local_address(this : Socket*, error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)
  fun socket_get_multicast_loopback = g_socket_get_multicast_loopback(this : Socket*) : LibC::Int
  fun socket_get_multicast_ttl = g_socket_get_multicast_ttl(this : Socket*) : UInt32
  fun socket_get_option = g_socket_get_option(this : Socket*, level : Int32, optname : Int32, value : Int32*, error : LibGLib::Error**) : LibC::Int
  fun socket_get_protocol = g_socket_get_protocol(this : Socket*) : LibGio::SocketProtocol
  fun socket_get_remote_address = g_socket_get_remote_address(this : Socket*, error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)
  fun socket_get_socket_type = g_socket_get_socket_type(this : Socket*) : LibGio::SocketType
  fun socket_get_timeout = g_socket_get_timeout(this : Socket*) : UInt32
  fun socket_get_ttl = g_socket_get_ttl(this : Socket*) : UInt32
  fun socket_is_closed = g_socket_is_closed(this : Socket*) : LibC::Int
  fun socket_is_connected = g_socket_is_connected(this : Socket*) : LibC::Int
  fun socket_join_multicast_group = g_socket_join_multicast_group(this : Socket*, group : Pointer(LibGio::InetAddress), source_specific : LibC::Int, iface : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun socket_join_multicast_group_ssm = g_socket_join_multicast_group_ssm(this : Socket*, group : Pointer(LibGio::InetAddress), source_specific : Pointer(LibGio::InetAddress), iface : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun socket_leave_multicast_group = g_socket_leave_multicast_group(this : Socket*, group : Pointer(LibGio::InetAddress), source_specific : LibC::Int, iface : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun socket_leave_multicast_group_ssm = g_socket_leave_multicast_group_ssm(this : Socket*, group : Pointer(LibGio::InetAddress), source_specific : Pointer(LibGio::InetAddress), iface : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun socket_listen = g_socket_listen(this : Socket*, error : LibGLib::Error**) : LibC::Int
  fun socket_receive = g_socket_receive(this : Socket*, buffer : Pointer(UInt8), size : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_receive_from = g_socket_receive_from(this : Socket*, address : Pointer(LibGio::SocketAddress)*, buffer : Pointer(UInt8), size : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_receive_message = g_socket_receive_message(this : Socket*, address : Pointer(LibGio::SocketAddress)*, vectors : Pointer(LibGio::InputVector), num_vectors : Int32, messages : Pointer(Pointer(LibGio::SocketControlMessage))*, num_messages : Int32*, flags : Int32*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_receive_messages = g_socket_receive_messages(this : Socket*, messages : Pointer(LibGio::InputMessage), num_messages : UInt32, flags : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun socket_receive_with_blocking = g_socket_receive_with_blocking(this : Socket*, buffer : Pointer(UInt8), size : UInt64, blocking : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_send = g_socket_send(this : Socket*, buffer : Pointer(UInt8), size : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_send_message = g_socket_send_message(this : Socket*, address : Pointer(LibGio::SocketAddress), vectors : Pointer(LibGio::OutputVector), num_vectors : Int32, messages : Pointer(Pointer(LibGio::SocketControlMessage)), num_messages : Int32, flags : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_send_message_with_timeout = g_socket_send_message_with_timeout(this : Socket*, address : Pointer(LibGio::SocketAddress), vectors : Pointer(LibGio::OutputVector), num_vectors : Int32, messages : Pointer(Pointer(LibGio::SocketControlMessage)), num_messages : Int32, flags : Int32, timeout_us : Int64, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::PollableReturn
  fun socket_send_messages = g_socket_send_messages(this : Socket*, messages : Pointer(LibGio::OutputMessage), num_messages : UInt32, flags : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun socket_send_to = g_socket_send_to(this : Socket*, address : Pointer(LibGio::SocketAddress), buffer : Pointer(UInt8), size : UInt64, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_send_with_blocking = g_socket_send_with_blocking(this : Socket*, buffer : Pointer(UInt8), size : UInt64, blocking : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun socket_set_blocking = g_socket_set_blocking(this : Socket*, blocking : LibC::Int) : Void
  fun socket_set_broadcast = g_socket_set_broadcast(this : Socket*, broadcast : LibC::Int) : Void
  fun socket_set_keepalive = g_socket_set_keepalive(this : Socket*, keepalive : LibC::Int) : Void
  fun socket_set_listen_backlog = g_socket_set_listen_backlog(this : Socket*, backlog : Int32) : Void
  fun socket_set_multicast_loopback = g_socket_set_multicast_loopback(this : Socket*, loopback : LibC::Int) : Void
  fun socket_set_multicast_ttl = g_socket_set_multicast_ttl(this : Socket*, ttl : UInt32) : Void
  fun socket_set_option = g_socket_set_option(this : Socket*, level : Int32, optname : Int32, value : Int32, error : LibGLib::Error**) : LibC::Int
  fun socket_set_timeout = g_socket_set_timeout(this : Socket*, timeout : UInt32) : Void
  fun socket_set_ttl = g_socket_set_ttl(this : Socket*, ttl : UInt32) : Void
  fun socket_shutdown = g_socket_shutdown(this : Socket*, shutdown_read : LibC::Int, shutdown_write : LibC::Int, error : LibGLib::Error**) : LibC::Int
  fun socket_speaks_ipv4 = g_socket_speaks_ipv4(this : Socket*) : LibC::Int

  struct SocketAddress # object
    parent_instance : LibGObject::Object
    # Virtual function get_family
    # Virtual function get_native_size
    # Virtual function to_native
    # Property family : LibGio::SocketFamily
  end

  fun _g_socket_address_get_type = g_socket_address_get_type : UInt64
  fun socket_address_new_from_native = g_socket_address_new_from_native(native : Pointer(Void), len : UInt64) : Pointer(LibGio::SocketAddress)
  fun socket_address_get_family = g_socket_address_get_family(this : SocketAddress*) : LibGio::SocketFamily
  fun socket_address_get_native_size = g_socket_address_get_native_size(this : SocketAddress*) : Int64
  fun socket_address_to_native = g_socket_address_to_native(this : SocketAddress*, dest : Pointer(Void), destlen : UInt64, error : LibGLib::Error**) : LibC::Int

  struct SocketAddressEnumerator # object
    parent_instance : LibGObject::Object
    # Virtual function next
    # Virtual function next_async
    # Virtual function next_finish
  end

  fun _g_socket_address_enumerator_get_type = g_socket_address_enumerator_get_type : UInt64
  fun socket_address_enumerator_next = g_socket_address_enumerator_next(this : SocketAddressEnumerator*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)
  fun socket_address_enumerator_next_async = g_socket_address_enumerator_next_async(this : SocketAddressEnumerator*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_address_enumerator_next_finish = g_socket_address_enumerator_next_finish(this : SocketAddressEnumerator*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)

  struct SocketClient # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SocketClientPrivate)
    # Signal event
    # Virtual function event
    # Property enable-proxy : LibC::Int
    # Property family : LibGio::SocketFamily
    # Property local-address : LibGio::SocketAddress
    # Property protocol : LibGio::SocketProtocol
    # Property proxy-resolver : LibGio::ProxyResolver
    # Property timeout : UInt32
    # Property tls : LibC::Int
    # Property tls-validation-flags : LibGio::TlsCertificateFlags
    # Property type : LibGio::SocketType
  end

  fun _g_socket_client_get_type = g_socket_client_get_type : UInt64
  fun socket_client_new = g_socket_client_new : Pointer(LibGio::SocketClient)
  fun socket_client_add_application_proxy = g_socket_client_add_application_proxy(this : SocketClient*, protocol : Pointer(UInt8)) : Void
  fun socket_client_connect = g_socket_client_connect(this : SocketClient*, connectable : Pointer(LibGio::SocketConnectable), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_async = g_socket_client_connect_async(this : SocketClient*, connectable : Pointer(LibGio::SocketConnectable), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_client_connect_finish = g_socket_client_connect_finish(this : SocketClient*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_host = g_socket_client_connect_to_host(this : SocketClient*, host_and_port : Pointer(UInt8), default_port : UInt16, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_host_async = g_socket_client_connect_to_host_async(this : SocketClient*, host_and_port : Pointer(UInt8), default_port : UInt16, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_client_connect_to_host_finish = g_socket_client_connect_to_host_finish(this : SocketClient*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_service = g_socket_client_connect_to_service(this : SocketClient*, domain : Pointer(UInt8), service : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_service_async = g_socket_client_connect_to_service_async(this : SocketClient*, domain : Pointer(UInt8), service : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_client_connect_to_service_finish = g_socket_client_connect_to_service_finish(this : SocketClient*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_uri = g_socket_client_connect_to_uri(this : SocketClient*, uri : Pointer(UInt8), default_port : UInt16, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_connect_to_uri_async = g_socket_client_connect_to_uri_async(this : SocketClient*, uri : Pointer(UInt8), default_port : UInt16, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_client_connect_to_uri_finish = g_socket_client_connect_to_uri_finish(this : SocketClient*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_client_get_enable_proxy = g_socket_client_get_enable_proxy(this : SocketClient*) : LibC::Int
  fun socket_client_get_family = g_socket_client_get_family(this : SocketClient*) : LibGio::SocketFamily
  fun socket_client_get_local_address = g_socket_client_get_local_address(this : SocketClient*) : Pointer(LibGio::SocketAddress)
  fun socket_client_get_protocol = g_socket_client_get_protocol(this : SocketClient*) : LibGio::SocketProtocol
  fun socket_client_get_proxy_resolver = g_socket_client_get_proxy_resolver(this : SocketClient*) : Pointer(LibGio::ProxyResolver)
  fun socket_client_get_socket_type = g_socket_client_get_socket_type(this : SocketClient*) : LibGio::SocketType
  fun socket_client_get_timeout = g_socket_client_get_timeout(this : SocketClient*) : UInt32
  fun socket_client_get_tls = g_socket_client_get_tls(this : SocketClient*) : LibC::Int
  fun socket_client_get_tls_validation_flags = g_socket_client_get_tls_validation_flags(this : SocketClient*) : LibGio::TlsCertificateFlags
  fun socket_client_set_enable_proxy = g_socket_client_set_enable_proxy(this : SocketClient*, enable : LibC::Int) : Void
  fun socket_client_set_family = g_socket_client_set_family(this : SocketClient*, family : LibGio::SocketFamily) : Void
  fun socket_client_set_local_address = g_socket_client_set_local_address(this : SocketClient*, address : Pointer(LibGio::SocketAddress)) : Void
  fun socket_client_set_protocol = g_socket_client_set_protocol(this : SocketClient*, protocol : LibGio::SocketProtocol) : Void
  fun socket_client_set_proxy_resolver = g_socket_client_set_proxy_resolver(this : SocketClient*, proxy_resolver : Pointer(LibGio::ProxyResolver)) : Void
  fun socket_client_set_socket_type = g_socket_client_set_socket_type(this : SocketClient*, type : LibGio::SocketType) : Void
  fun socket_client_set_timeout = g_socket_client_set_timeout(this : SocketClient*, timeout : UInt32) : Void
  fun socket_client_set_tls = g_socket_client_set_tls(this : SocketClient*, tls : LibC::Int) : Void
  fun socket_client_set_tls_validation_flags = g_socket_client_set_tls_validation_flags(this : SocketClient*, flags : LibGio::TlsCertificateFlags) : Void

  struct SocketConnection # object
    parent_instance : LibGio::IOStream
    priv : Pointer(LibGio::SocketConnectionPrivate)
    # Property socket : LibGio::Socket
  end

  fun _g_socket_connection_get_type = g_socket_connection_get_type : UInt64
  fun socket_connection_factory_lookup_type = g_socket_connection_factory_lookup_type(family : LibGio::SocketFamily, type : LibGio::SocketType, protocol_id : Int32) : UInt64
  fun socket_connection_factory_register_type = g_socket_connection_factory_register_type(g_type : UInt64, family : LibGio::SocketFamily, type : LibGio::SocketType, protocol : Int32) : Void
  fun socket_connection_connect = g_socket_connection_connect(this : SocketConnection*, address : Pointer(LibGio::SocketAddress), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun socket_connection_connect_async = g_socket_connection_connect_async(this : SocketConnection*, address : Pointer(LibGio::SocketAddress), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_connection_connect_finish = g_socket_connection_connect_finish(this : SocketConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun socket_connection_get_local_address = g_socket_connection_get_local_address(this : SocketConnection*, error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)
  fun socket_connection_get_remote_address = g_socket_connection_get_remote_address(this : SocketConnection*, error : LibGLib::Error**) : Pointer(LibGio::SocketAddress)
  fun socket_connection_get_socket = g_socket_connection_get_socket(this : SocketConnection*) : Pointer(LibGio::Socket)
  fun socket_connection_is_connected = g_socket_connection_is_connected(this : SocketConnection*) : LibC::Int

  struct SocketControlMessage # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SocketControlMessagePrivate)
    # Virtual function get_level
    # Virtual function get_size
    # Virtual function get_type
    # Virtual function serialize
  end

  fun _g_socket_control_message_get_type = g_socket_control_message_get_type : UInt64
  fun socket_control_message_deserialize = g_socket_control_message_deserialize(level : Int32, type : Int32, size : UInt64, data : Pointer(UInt8)) : Pointer(LibGio::SocketControlMessage)
  fun socket_control_message_get_level = g_socket_control_message_get_level(this : SocketControlMessage*) : Int32
  fun socket_control_message_get_msg_type = g_socket_control_message_get_msg_type(this : SocketControlMessage*) : Int32
  fun socket_control_message_get_size = g_socket_control_message_get_size(this : SocketControlMessage*) : UInt64
  fun socket_control_message_serialize = g_socket_control_message_serialize(this : SocketControlMessage*, data : Pointer(Void)) : Void

  struct SocketListener # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::SocketListenerPrivate)
    # Signal event
    # Virtual function changed
    # Virtual function event
    # Property listen-backlog : Int32
  end

  fun _g_socket_listener_get_type = g_socket_listener_get_type : UInt64
  fun socket_listener_new = g_socket_listener_new : Pointer(LibGio::SocketListener)
  fun socket_listener_accept = g_socket_listener_accept(this : SocketListener*, source_object : Pointer(LibGObject::Object)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_listener_accept_async = g_socket_listener_accept_async(this : SocketListener*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_listener_accept_finish = g_socket_listener_accept_finish(this : SocketListener*, result : Pointer(LibGio::AsyncResult), source_object : Pointer(LibGObject::Object)*, error : LibGLib::Error**) : Pointer(LibGio::SocketConnection)
  fun socket_listener_accept_socket = g_socket_listener_accept_socket(this : SocketListener*, source_object : Pointer(LibGObject::Object)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::Socket)
  fun socket_listener_accept_socket_async = g_socket_listener_accept_socket_async(this : SocketListener*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun socket_listener_accept_socket_finish = g_socket_listener_accept_socket_finish(this : SocketListener*, result : Pointer(LibGio::AsyncResult), source_object : Pointer(LibGObject::Object)*, error : LibGLib::Error**) : Pointer(LibGio::Socket)
  fun socket_listener_add_address = g_socket_listener_add_address(this : SocketListener*, address : Pointer(LibGio::SocketAddress), type : LibGio::SocketType, protocol : LibGio::SocketProtocol, source_object : Pointer(LibGObject::Object), effective_address : Pointer(LibGio::SocketAddress)*, error : LibGLib::Error**) : LibC::Int
  fun socket_listener_add_any_inet_port = g_socket_listener_add_any_inet_port(this : SocketListener*, source_object : Pointer(LibGObject::Object), error : LibGLib::Error**) : UInt16
  fun socket_listener_add_inet_port = g_socket_listener_add_inet_port(this : SocketListener*, port : UInt16, source_object : Pointer(LibGObject::Object), error : LibGLib::Error**) : LibC::Int
  fun socket_listener_add_socket = g_socket_listener_add_socket(this : SocketListener*, socket : Pointer(LibGio::Socket), source_object : Pointer(LibGObject::Object), error : LibGLib::Error**) : LibC::Int
  fun socket_listener_close = g_socket_listener_close(this : SocketListener*) : Void
  fun socket_listener_set_backlog = g_socket_listener_set_backlog(this : SocketListener*, listen_backlog : Int32) : Void

  struct SocketService # object
    parent_instance : LibGio::SocketListener
    priv : Pointer(LibGio::SocketServicePrivate)
    # Signal incoming
    # Virtual function incoming
    # Property active : LibC::Int
  end

  fun _g_socket_service_get_type = g_socket_service_get_type : UInt64
  fun socket_service_new = g_socket_service_new : Pointer(LibGio::SocketService)
  fun socket_service_is_active = g_socket_service_is_active(this : SocketService*) : LibC::Int
  fun socket_service_start = g_socket_service_start(this : SocketService*) : Void
  fun socket_service_stop = g_socket_service_stop(this : SocketService*) : Void

  struct Subprocess # object
    _data : UInt8[0]
    # Property argv : Pointer(Pointer(UInt8))
    # Property flags : LibGio::SubprocessFlags
  end

  fun _g_subprocess_get_type = g_subprocess_get_type : UInt64
  fun subprocess_new = g_subprocess_newv(argv : Pointer(Pointer(UInt8)), flags : LibGio::SubprocessFlags, error : LibGLib::Error**) : Pointer(LibGio::Subprocess)
  fun subprocess_communicate = g_subprocess_communicate(this : Subprocess*, stdin_buf : Pointer(LibGLib::Bytes), cancellable : Pointer(LibGio::Cancellable), stdout_buf : Pointer(LibGLib::Bytes)*, stderr_buf : Pointer(LibGLib::Bytes)*, error : LibGLib::Error**) : LibC::Int
  fun subprocess_communicate_async = g_subprocess_communicate_async(this : Subprocess*, stdin_buf : Pointer(LibGLib::Bytes), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun subprocess_communicate_finish = g_subprocess_communicate_finish(this : Subprocess*, result : Pointer(LibGio::AsyncResult), stdout_buf : Pointer(LibGLib::Bytes)*, stderr_buf : Pointer(LibGLib::Bytes)*, error : LibGLib::Error**) : LibC::Int
  fun subprocess_communicate_utf8 = g_subprocess_communicate_utf8(this : Subprocess*, stdin_buf : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), stdout_buf : Pointer(UInt8)*, stderr_buf : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun subprocess_communicate_utf8_async = g_subprocess_communicate_utf8_async(this : Subprocess*, stdin_buf : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun subprocess_communicate_utf8_finish = g_subprocess_communicate_utf8_finish(this : Subprocess*, result : Pointer(LibGio::AsyncResult), stdout_buf : Pointer(UInt8)*, stderr_buf : Pointer(UInt8)*, error : LibGLib::Error**) : LibC::Int
  fun subprocess_force_exit = g_subprocess_force_exit(this : Subprocess*) : Void
  fun subprocess_get_exit_status = g_subprocess_get_exit_status(this : Subprocess*) : Int32
  fun subprocess_get_identifier = g_subprocess_get_identifier(this : Subprocess*) : Pointer(UInt8)
  fun subprocess_get_if_exited = g_subprocess_get_if_exited(this : Subprocess*) : LibC::Int
  fun subprocess_get_if_signaled = g_subprocess_get_if_signaled(this : Subprocess*) : LibC::Int
  fun subprocess_get_status = g_subprocess_get_status(this : Subprocess*) : Int32
  fun subprocess_get_stderr_pipe = g_subprocess_get_stderr_pipe(this : Subprocess*) : Pointer(LibGio::InputStream)
  fun subprocess_get_stdin_pipe = g_subprocess_get_stdin_pipe(this : Subprocess*) : Pointer(LibGio::OutputStream)
  fun subprocess_get_stdout_pipe = g_subprocess_get_stdout_pipe(this : Subprocess*) : Pointer(LibGio::InputStream)
  fun subprocess_get_successful = g_subprocess_get_successful(this : Subprocess*) : LibC::Int
  fun subprocess_get_term_sig = g_subprocess_get_term_sig(this : Subprocess*) : Int32
  fun subprocess_send_signal = g_subprocess_send_signal(this : Subprocess*, signal_num : Int32) : Void
  fun subprocess_wait = g_subprocess_wait(this : Subprocess*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun subprocess_wait_async = g_subprocess_wait_async(this : Subprocess*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun subprocess_wait_check = g_subprocess_wait_check(this : Subprocess*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun subprocess_wait_check_async = g_subprocess_wait_check_async(this : Subprocess*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun subprocess_wait_check_finish = g_subprocess_wait_check_finish(this : Subprocess*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun subprocess_wait_finish = g_subprocess_wait_finish(this : Subprocess*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int

  struct SubprocessLauncher # object
    _data : UInt8[0]
    # Property flags : LibGio::SubprocessFlags
  end

  fun _g_subprocess_launcher_get_type = g_subprocess_launcher_get_type : UInt64
  fun subprocess_launcher_new = g_subprocess_launcher_new(flags : LibGio::SubprocessFlags) : Pointer(LibGio::SubprocessLauncher)
  fun subprocess_launcher_getenv = g_subprocess_launcher_getenv(this : SubprocessLauncher*, variable : Pointer(UInt8)) : Pointer(UInt8)
  fun subprocess_launcher_set_cwd = g_subprocess_launcher_set_cwd(this : SubprocessLauncher*, cwd : Pointer(UInt8)) : Void
  fun subprocess_launcher_set_environ = g_subprocess_launcher_set_environ(this : SubprocessLauncher*, env : Pointer(Pointer(UInt8))) : Void
  fun subprocess_launcher_set_flags = g_subprocess_launcher_set_flags(this : SubprocessLauncher*, flags : LibGio::SubprocessFlags) : Void
  fun subprocess_launcher_set_stderr_file_path = g_subprocess_launcher_set_stderr_file_path(this : SubprocessLauncher*, path : Pointer(UInt8)) : Void
  fun subprocess_launcher_set_stdin_file_path = g_subprocess_launcher_set_stdin_file_path(this : SubprocessLauncher*, path : Pointer(UInt8)) : Void
  fun subprocess_launcher_set_stdout_file_path = g_subprocess_launcher_set_stdout_file_path(this : SubprocessLauncher*, path : Pointer(UInt8)) : Void
  fun subprocess_launcher_setenv = g_subprocess_launcher_setenv(this : SubprocessLauncher*, variable : Pointer(UInt8), value : Pointer(UInt8), overwrite : LibC::Int) : Void
  fun subprocess_launcher_spawnv = g_subprocess_launcher_spawnv(this : SubprocessLauncher*, argv : Pointer(Pointer(UInt8)), error : LibGLib::Error**) : Pointer(LibGio::Subprocess)
  fun subprocess_launcher_take_fd = g_subprocess_launcher_take_fd(this : SubprocessLauncher*, source_fd : Int32, target_fd : Int32) : Void
  fun subprocess_launcher_take_stderr_fd = g_subprocess_launcher_take_stderr_fd(this : SubprocessLauncher*, fd : Int32) : Void
  fun subprocess_launcher_take_stdin_fd = g_subprocess_launcher_take_stdin_fd(this : SubprocessLauncher*, fd : Int32) : Void
  fun subprocess_launcher_take_stdout_fd = g_subprocess_launcher_take_stdout_fd(this : SubprocessLauncher*, fd : Int32) : Void
  fun subprocess_launcher_unsetenv = g_subprocess_launcher_unsetenv(this : SubprocessLauncher*, variable : Pointer(UInt8)) : Void

  struct Task # object
    _data : UInt8[0]
    # Property completed : LibC::Int
  end

  fun _g_task_get_type = g_task_get_type : UInt64
  fun task_new = g_task_new(source_object : Pointer(LibGObject::Object), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, callback_data : Pointer(Void)) : Pointer(LibGio::Task)
  fun task_is_valid = g_task_is_valid(result : Pointer(LibGio::AsyncResult), source_object : Pointer(LibGObject::Object)) : LibC::Int
  fun task_report_error = g_task_report_error(source_object : Pointer(LibGObject::Object), callback : LibGio::AsyncReadyCallback, callback_data : Pointer(Void), source_tag : Pointer(Void), error : Pointer(LibGLib::Error*)) : Void
  fun task_get_cancellable = g_task_get_cancellable(this : Task*) : Pointer(LibGio::Cancellable)
  fun task_get_check_cancellable = g_task_get_check_cancellable(this : Task*) : LibC::Int
  fun task_get_completed = g_task_get_completed(this : Task*) : LibC::Int
  fun task_get_context = g_task_get_context(this : Task*) : Pointer(LibGLib::MainContext)
  fun task_get_name = g_task_get_name(this : Task*) : Pointer(UInt8)
  fun task_get_priority = g_task_get_priority(this : Task*) : Int32
  fun task_get_return_on_cancel = g_task_get_return_on_cancel(this : Task*) : LibC::Int
  fun task_get_source_object = g_task_get_source_object(this : Task*) : Pointer(LibGObject::Object)
  fun task_get_source_tag = g_task_get_source_tag(this : Task*) : Pointer(Void)
  fun task_get_task_data = g_task_get_task_data(this : Task*) : Pointer(Void)
  fun task_had_error = g_task_had_error(this : Task*) : LibC::Int
  fun task_propagate_boolean = g_task_propagate_boolean(this : Task*, error : LibGLib::Error**) : LibC::Int
  fun task_propagate_int = g_task_propagate_int(this : Task*, error : LibGLib::Error**) : Int64
  fun task_propagate_pointer = g_task_propagate_pointer(this : Task*, error : LibGLib::Error**) : Pointer(Void)
  fun task_propagate_value = g_task_propagate_value(this : Task*, value : LibGObject::Value*, error : LibGLib::Error**) : LibC::Int
  fun task_return_boolean = g_task_return_boolean(this : Task*, result : LibC::Int) : Void
  fun task_return_error = g_task_return_error(this : Task*, error : Pointer(LibGLib::Error*)) : Void
  fun task_return_error_if_cancelled = g_task_return_error_if_cancelled(this : Task*) : LibC::Int
  fun task_return_int = g_task_return_int(this : Task*, result : Int64) : Void
  fun task_return_pointer = g_task_return_pointer(this : Task*, result : Pointer(Void), result_destroy : LibGLib::DestroyNotify) : Void
  fun task_return_value = g_task_return_value(this : Task*, result : Pointer(LibGObject::Value)) : Void
  fun task_run_in_thread = g_task_run_in_thread(this : Task*, task_func : LibGio::TaskThreadFunc) : Void
  fun task_run_in_thread_sync = g_task_run_in_thread_sync(this : Task*, task_func : LibGio::TaskThreadFunc) : Void
  fun task_set_check_cancellable = g_task_set_check_cancellable(this : Task*, check_cancellable : LibC::Int) : Void
  fun task_set_name = g_task_set_name(this : Task*, name : Pointer(UInt8)) : Void
  fun task_set_priority = g_task_set_priority(this : Task*, priority : Int32) : Void
  fun task_set_return_on_cancel = g_task_set_return_on_cancel(this : Task*, return_on_cancel : LibC::Int) : LibC::Int
  fun task_set_source_tag = g_task_set_source_tag(this : Task*, source_tag : Pointer(Void)) : Void
  fun task_set_task_data = g_task_set_task_data(this : Task*, task_data : Pointer(Void), task_data_destroy : LibGLib::DestroyNotify) : Void

  struct TcpConnection # object
    parent_instance : LibGio::SocketConnection
    priv : Pointer(LibGio::TcpConnectionPrivate)
    # Property graceful-disconnect : LibC::Int
  end

  fun _g_tcp_connection_get_type = g_tcp_connection_get_type : UInt64
  fun tcp_connection_get_graceful_disconnect = g_tcp_connection_get_graceful_disconnect(this : TcpConnection*) : LibC::Int
  fun tcp_connection_set_graceful_disconnect = g_tcp_connection_set_graceful_disconnect(this : TcpConnection*, graceful_disconnect : LibC::Int) : Void

  struct TcpWrapperConnection # object
    parent_instance : LibGio::TcpConnection
    priv : Pointer(LibGio::TcpWrapperConnectionPrivate)
    # Property base-io-stream : LibGio::IOStream
  end

  fun _g_tcp_wrapper_connection_get_type = g_tcp_wrapper_connection_get_type : UInt64
  fun tcp_wrapper_connection_new = g_tcp_wrapper_connection_new(base_io_stream : Pointer(LibGio::IOStream), socket : Pointer(LibGio::Socket)) : Pointer(LibGio::SocketConnection)
  fun tcp_wrapper_connection_get_base_io_stream = g_tcp_wrapper_connection_get_base_io_stream(this : TcpWrapperConnection*) : Pointer(LibGio::IOStream)

  struct TestDBus # object
    _data : UInt8[0]
    # Property flags : LibGio::TestDBusFlags
  end

  fun _g_test_dbus_get_type = g_test_dbus_get_type : UInt64
  fun test_d_bus_new = g_test_dbus_new(flags : LibGio::TestDBusFlags) : Pointer(LibGio::TestDBus)
  fun test_d_bus_unset = g_test_dbus_unset : Void
  fun test_d_bus_add_service_dir = g_test_dbus_add_service_dir(this : TestDBus*, path : Pointer(UInt8)) : Void
  fun test_d_bus_down = g_test_dbus_down(this : TestDBus*) : Void
  fun test_d_bus_get_bus_address = g_test_dbus_get_bus_address(this : TestDBus*) : Pointer(UInt8)
  fun test_d_bus_get_flags = g_test_dbus_get_flags(this : TestDBus*) : LibGio::TestDBusFlags
  fun test_d_bus_stop = g_test_dbus_stop(this : TestDBus*) : Void
  fun test_d_bus_up = g_test_dbus_up(this : TestDBus*) : Void

  struct ThemedIcon # object
    _data : UInt8[0]
    # Property name : Pointer(UInt8)
    # Property names : Pointer(Pointer(UInt8))
    # Property use-default-fallbacks : LibC::Int
  end

  fun _g_themed_icon_get_type = g_themed_icon_get_type : UInt64
  fun themed_icon_new = g_themed_icon_new(iconname : Pointer(UInt8)) : Pointer(LibGio::ThemedIcon)
  fun themed_icon_new_from_names = g_themed_icon_new_from_names(iconnames : Pointer(Pointer(UInt8)), len : Int32) : Pointer(LibGio::ThemedIcon)
  fun themed_icon_new_with_default_fallbacks = g_themed_icon_new_with_default_fallbacks(iconname : Pointer(UInt8)) : Pointer(LibGio::ThemedIcon)
  fun themed_icon_append_name = g_themed_icon_append_name(this : ThemedIcon*, iconname : Pointer(UInt8)) : Void
  fun themed_icon_get_names = g_themed_icon_get_names(this : ThemedIcon*) : Pointer(Pointer(UInt8))
  fun themed_icon_prepend_name = g_themed_icon_prepend_name(this : ThemedIcon*, iconname : Pointer(UInt8)) : Void

  struct ThreadedSocketService # object
    parent_instance : LibGio::SocketService
    priv : Pointer(LibGio::ThreadedSocketServicePrivate)
    # Signal run
    # Virtual function run
    # Property max-threads : Int32
  end

  fun _g_threaded_socket_service_get_type = g_threaded_socket_service_get_type : UInt64
  fun threaded_socket_service_new = g_threaded_socket_service_new(max_threads : Int32) : Pointer(LibGio::SocketService)

  struct TlsCertificate # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::TlsCertificatePrivate)
    # Virtual function verify
    # Property certificate : Pointer(Void)
    # Property certificate-pem : Pointer(UInt8)
    # Property issuer : LibGio::TlsCertificate
    # Property private-key : Pointer(Void)
    # Property private-key-pem : Pointer(UInt8)
  end

  fun _g_tls_certificate_get_type = g_tls_certificate_get_type : UInt64
  fun tls_certificate_new_from_file = g_tls_certificate_new_from_file(file : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_certificate_new_from_files = g_tls_certificate_new_from_files(cert_file : Pointer(UInt8), key_file : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_certificate_new_from_pem = g_tls_certificate_new_from_pem(data : Pointer(UInt8), length : Int64, error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_certificate_list_new_from_file = g_tls_certificate_list_new_from_file(file : Pointer(UInt8), error : LibGLib::Error**) : Pointer(Void*)
  fun tls_certificate_get_issuer = g_tls_certificate_get_issuer(this : TlsCertificate*) : Pointer(LibGio::TlsCertificate)
  fun tls_certificate_is_same = g_tls_certificate_is_same(this : TlsCertificate*, cert_two : Pointer(LibGio::TlsCertificate)) : LibC::Int
  fun tls_certificate_verify = g_tls_certificate_verify(this : TlsCertificate*, identity : Pointer(LibGio::SocketConnectable), trusted_ca : Pointer(LibGio::TlsCertificate)) : LibGio::TlsCertificateFlags

  struct TlsConnection # object
    parent_instance : LibGio::IOStream
    priv : Pointer(LibGio::TlsConnectionPrivate)
    # Signal accept-certificate
    # Virtual function accept_certificate
    # Virtual function handshake
    # Virtual function handshake_async
    # Virtual function handshake_finish
    # Property advertised-protocols : Pointer(Pointer(UInt8))
    # Property base-io-stream : LibGio::IOStream
    # Property certificate : LibGio::TlsCertificate
    # Property database : LibGio::TlsDatabase
    # Property interaction : LibGio::TlsInteraction
    # Property negotiated-protocol : Pointer(UInt8)
    # Property peer-certificate : LibGio::TlsCertificate
    # Property peer-certificate-errors : LibGio::TlsCertificateFlags
    # Property rehandshake-mode : LibGio::TlsRehandshakeMode
    # Property require-close-notify : LibC::Int
    # Property use-system-certdb : LibC::Int
  end

  fun _g_tls_connection_get_type = g_tls_connection_get_type : UInt64
  fun tls_connection_emit_accept_certificate = g_tls_connection_emit_accept_certificate(this : TlsConnection*, peer_cert : Pointer(LibGio::TlsCertificate), errors : LibGio::TlsCertificateFlags) : LibC::Int
  fun tls_connection_get_certificate = g_tls_connection_get_certificate(this : TlsConnection*) : Pointer(LibGio::TlsCertificate)
  fun tls_connection_get_database = g_tls_connection_get_database(this : TlsConnection*) : Pointer(LibGio::TlsDatabase)
  fun tls_connection_get_interaction = g_tls_connection_get_interaction(this : TlsConnection*) : Pointer(LibGio::TlsInteraction)
  fun tls_connection_get_negotiated_protocol = g_tls_connection_get_negotiated_protocol(this : TlsConnection*) : Pointer(UInt8)
  fun tls_connection_get_peer_certificate = g_tls_connection_get_peer_certificate(this : TlsConnection*) : Pointer(LibGio::TlsCertificate)
  fun tls_connection_get_peer_certificate_errors = g_tls_connection_get_peer_certificate_errors(this : TlsConnection*) : LibGio::TlsCertificateFlags
  fun tls_connection_get_rehandshake_mode = g_tls_connection_get_rehandshake_mode(this : TlsConnection*) : LibGio::TlsRehandshakeMode
  fun tls_connection_get_require_close_notify = g_tls_connection_get_require_close_notify(this : TlsConnection*) : LibC::Int
  fun tls_connection_get_use_system_certdb = g_tls_connection_get_use_system_certdb(this : TlsConnection*) : LibC::Int
  fun tls_connection_handshake = g_tls_connection_handshake(this : TlsConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun tls_connection_handshake_async = g_tls_connection_handshake_async(this : TlsConnection*, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_connection_handshake_finish = g_tls_connection_handshake_finish(this : TlsConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun tls_connection_set_advertised_protocols = g_tls_connection_set_advertised_protocols(this : TlsConnection*, protocols : Pointer(Pointer(UInt8))) : Void
  fun tls_connection_set_certificate = g_tls_connection_set_certificate(this : TlsConnection*, certificate : Pointer(LibGio::TlsCertificate)) : Void
  fun tls_connection_set_database = g_tls_connection_set_database(this : TlsConnection*, database : Pointer(LibGio::TlsDatabase)) : Void
  fun tls_connection_set_interaction = g_tls_connection_set_interaction(this : TlsConnection*, interaction : Pointer(LibGio::TlsInteraction)) : Void
  fun tls_connection_set_rehandshake_mode = g_tls_connection_set_rehandshake_mode(this : TlsConnection*, mode : LibGio::TlsRehandshakeMode) : Void
  fun tls_connection_set_require_close_notify = g_tls_connection_set_require_close_notify(this : TlsConnection*, require_close_notify : LibC::Int) : Void
  fun tls_connection_set_use_system_certdb = g_tls_connection_set_use_system_certdb(this : TlsConnection*, use_system_certdb : LibC::Int) : Void

  struct TlsDatabase # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::TlsDatabasePrivate)
    # Virtual function create_certificate_handle
    # Virtual function lookup_certificate_for_handle
    # Virtual function lookup_certificate_for_handle_async
    # Virtual function lookup_certificate_for_handle_finish
    # Virtual function lookup_certificate_issuer
    # Virtual function lookup_certificate_issuer_async
    # Virtual function lookup_certificate_issuer_finish
    # Virtual function lookup_certificates_issued_by
    # Virtual function lookup_certificates_issued_by_async
    # Virtual function lookup_certificates_issued_by_finish
    # Virtual function verify_chain
    # Virtual function verify_chain_async
    # Virtual function verify_chain_finish
  end

  fun _g_tls_database_get_type = g_tls_database_get_type : UInt64
  fun tls_database_create_certificate_handle = g_tls_database_create_certificate_handle(this : TlsDatabase*, certificate : Pointer(LibGio::TlsCertificate)) : Pointer(UInt8)
  fun tls_database_lookup_certificate_for_handle = g_tls_database_lookup_certificate_for_handle(this : TlsDatabase*, handle : Pointer(UInt8), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_database_lookup_certificate_for_handle_async = g_tls_database_lookup_certificate_for_handle_async(this : TlsDatabase*, handle : Pointer(UInt8), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_database_lookup_certificate_for_handle_finish = g_tls_database_lookup_certificate_for_handle_finish(this : TlsDatabase*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_database_lookup_certificate_issuer = g_tls_database_lookup_certificate_issuer(this : TlsDatabase*, certificate : Pointer(LibGio::TlsCertificate), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_database_lookup_certificate_issuer_async = g_tls_database_lookup_certificate_issuer_async(this : TlsDatabase*, certificate : Pointer(LibGio::TlsCertificate), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_database_lookup_certificate_issuer_finish = g_tls_database_lookup_certificate_issuer_finish(this : TlsDatabase*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::TlsCertificate)
  fun tls_database_lookup_certificates_issued_by = g_tls_database_lookup_certificates_issued_by(this : TlsDatabase*, issuer_raw_dn : Pointer(Void), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(Void*)
  fun tls_database_lookup_certificates_issued_by_async = g_tls_database_lookup_certificates_issued_by_async(this : TlsDatabase*, issuer_raw_dn : Pointer(Void), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseLookupFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_database_lookup_certificates_issued_by_finish = g_tls_database_lookup_certificates_issued_by_finish(this : TlsDatabase*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(Void*)
  fun tls_database_verify_chain = g_tls_database_verify_chain(this : TlsDatabase*, chain : Pointer(LibGio::TlsCertificate), purpose : Pointer(UInt8), identity : Pointer(LibGio::SocketConnectable), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseVerifyFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::TlsCertificateFlags
  fun tls_database_verify_chain_async = g_tls_database_verify_chain_async(this : TlsDatabase*, chain : Pointer(LibGio::TlsCertificate), purpose : Pointer(UInt8), identity : Pointer(LibGio::SocketConnectable), interaction : Pointer(LibGio::TlsInteraction), flags : LibGio::TlsDatabaseVerifyFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_database_verify_chain_finish = g_tls_database_verify_chain_finish(this : TlsDatabase*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibGio::TlsCertificateFlags

  struct TlsInteraction # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::TlsInteractionPrivate)
    # Virtual function ask_password
    # Virtual function ask_password_async
    # Virtual function ask_password_finish
    # Virtual function request_certificate
    # Virtual function request_certificate_async
    # Virtual function request_certificate_finish
  end

  fun _g_tls_interaction_get_type = g_tls_interaction_get_type : UInt64
  fun tls_interaction_ask_password = g_tls_interaction_ask_password(this : TlsInteraction*, password : Pointer(LibGio::TlsPassword), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::TlsInteractionResult
  fun tls_interaction_ask_password_async = g_tls_interaction_ask_password_async(this : TlsInteraction*, password : Pointer(LibGio::TlsPassword), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_interaction_ask_password_finish = g_tls_interaction_ask_password_finish(this : TlsInteraction*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibGio::TlsInteractionResult
  fun tls_interaction_invoke_ask_password = g_tls_interaction_invoke_ask_password(this : TlsInteraction*, password : Pointer(LibGio::TlsPassword), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::TlsInteractionResult
  fun tls_interaction_invoke_request_certificate = g_tls_interaction_invoke_request_certificate(this : TlsInteraction*, connection : Pointer(LibGio::TlsConnection), flags : LibGio::TlsCertificateRequestFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::TlsInteractionResult
  fun tls_interaction_request_certificate = g_tls_interaction_request_certificate(this : TlsInteraction*, connection : Pointer(LibGio::TlsConnection), flags : LibGio::TlsCertificateRequestFlags, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibGio::TlsInteractionResult
  fun tls_interaction_request_certificate_async = g_tls_interaction_request_certificate_async(this : TlsInteraction*, connection : Pointer(LibGio::TlsConnection), flags : LibGio::TlsCertificateRequestFlags, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun tls_interaction_request_certificate_finish = g_tls_interaction_request_certificate_finish(this : TlsInteraction*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibGio::TlsInteractionResult

  struct TlsPassword # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::TlsPasswordPrivate)
    # Virtual function get_default_warning
    # Virtual function get_value
    # Virtual function set_value
    # Property description : Pointer(UInt8)
    # Property flags : LibGio::TlsPasswordFlags
    # Property warning : Pointer(UInt8)
  end

  fun _g_tls_password_get_type = g_tls_password_get_type : UInt64
  fun tls_password_new = g_tls_password_new(flags : LibGio::TlsPasswordFlags, description : Pointer(UInt8)) : Pointer(LibGio::TlsPassword)
  fun tls_password_get_description = g_tls_password_get_description(this : TlsPassword*) : Pointer(UInt8)
  fun tls_password_get_flags = g_tls_password_get_flags(this : TlsPassword*) : LibGio::TlsPasswordFlags
  fun tls_password_get_value = g_tls_password_get_value(this : TlsPassword*, length : Pointer(UInt64)) : Pointer(UInt8)
  fun tls_password_get_warning = g_tls_password_get_warning(this : TlsPassword*) : Pointer(UInt8)
  fun tls_password_set_description = g_tls_password_set_description(this : TlsPassword*, description : Pointer(UInt8)) : Void
  fun tls_password_set_flags = g_tls_password_set_flags(this : TlsPassword*, flags : LibGio::TlsPasswordFlags) : Void
  fun tls_password_set_value = g_tls_password_set_value(this : TlsPassword*, value : Pointer(UInt8), length : Int64) : Void
  fun tls_password_set_value_full = g_tls_password_set_value_full(this : TlsPassword*, value : Pointer(UInt8), length : Int64, destroy : LibGLib::DestroyNotify) : Void
  fun tls_password_set_warning = g_tls_password_set_warning(this : TlsPassword*, warning : Pointer(UInt8)) : Void

  struct UnixConnection # object
    parent_instance : LibGio::SocketConnection
    priv : Pointer(LibGio::UnixConnectionPrivate)
  end

  fun _g_unix_connection_get_type = g_unix_connection_get_type : UInt64
  fun unix_connection_receive_credentials = g_unix_connection_receive_credentials(this : UnixConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::Credentials)
  fun unix_connection_receive_credentials_async = g_unix_connection_receive_credentials_async(this : UnixConnection*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun unix_connection_receive_credentials_finish = g_unix_connection_receive_credentials_finish(this : UnixConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::Credentials)
  fun unix_connection_receive_fd = g_unix_connection_receive_fd(this : UnixConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int32
  fun unix_connection_send_credentials = g_unix_connection_send_credentials(this : UnixConnection*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun unix_connection_send_credentials_async = g_unix_connection_send_credentials_async(this : UnixConnection*, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun unix_connection_send_credentials_finish = g_unix_connection_send_credentials_finish(this : UnixConnection*, result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun unix_connection_send_fd = g_unix_connection_send_fd(this : UnixConnection*, fd : Int32, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int

  struct UnixCredentialsMessage # object
    parent_instance : LibGio::SocketControlMessage
    priv : Pointer(LibGio::UnixCredentialsMessagePrivate)
    # Property credentials : LibGio::Credentials
  end

  fun _g_unix_credentials_message_get_type = g_unix_credentials_message_get_type : UInt64
  fun unix_credentials_message_new = g_unix_credentials_message_new : Pointer(LibGio::SocketControlMessage)
  fun unix_credentials_message_new_with_credentials = g_unix_credentials_message_new_with_credentials(credentials : Pointer(LibGio::Credentials)) : Pointer(LibGio::SocketControlMessage)
  fun unix_credentials_message_is_supported = g_unix_credentials_message_is_supported : LibC::Int
  fun unix_credentials_message_get_credentials = g_unix_credentials_message_get_credentials(this : UnixCredentialsMessage*) : Pointer(LibGio::Credentials)

  struct UnixFDList # object
    parent_instance : LibGObject::Object
    priv : Pointer(LibGio::UnixFDListPrivate)
  end

  fun _g_unix_fd_list_get_type = g_unix_fd_list_get_type : UInt64
  fun unix_f_d_list_new = g_unix_fd_list_new : Pointer(LibGio::UnixFDList)
  fun unix_f_d_list_new_from_array = g_unix_fd_list_new_from_array(fds : Pointer(Int32), n_fds : Int32) : Pointer(LibGio::UnixFDList)
  fun unix_f_d_list_append = g_unix_fd_list_append(this : UnixFDList*, fd : Int32, error : LibGLib::Error**) : Int32
  fun unix_f_d_list_get = g_unix_fd_list_get(this : UnixFDList*, index_ : Int32, error : LibGLib::Error**) : Int32
  fun unix_f_d_list_get_length = g_unix_fd_list_get_length(this : UnixFDList*) : Int32
  fun unix_f_d_list_peek_fds = g_unix_fd_list_peek_fds(this : UnixFDList*, length : Int32*) : Pointer(Int32)
  fun unix_f_d_list_steal_fds = g_unix_fd_list_steal_fds(this : UnixFDList*, length : Int32*) : Pointer(Int32)

  struct UnixFDMessage # object
    parent_instance : LibGio::SocketControlMessage
    priv : Pointer(LibGio::UnixFDMessagePrivate)
    # Property fd-list : LibGio::UnixFDList
  end

  fun _g_unix_fd_message_get_type = g_unix_fd_message_get_type : UInt64
  fun unix_f_d_message_new = g_unix_fd_message_new : Pointer(LibGio::SocketControlMessage)
  fun unix_f_d_message_new_with_fd_list = g_unix_fd_message_new_with_fd_list(fd_list : Pointer(LibGio::UnixFDList)) : Pointer(LibGio::SocketControlMessage)
  fun unix_f_d_message_append_fd = g_unix_fd_message_append_fd(this : UnixFDMessage*, fd : Int32, error : LibGLib::Error**) : LibC::Int
  fun unix_f_d_message_get_fd_list = g_unix_fd_message_get_fd_list(this : UnixFDMessage*) : Pointer(LibGio::UnixFDList)
  fun unix_f_d_message_steal_fds = g_unix_fd_message_steal_fds(this : UnixFDMessage*, length : Int32*) : Pointer(Int32)

  struct UnixInputStream # object
    parent_instance : LibGio::InputStream
    priv : Pointer(LibGio::UnixInputStreamPrivate)
    # Property close-fd : LibC::Int
    # Property fd : Int32
  end

  fun _g_unix_input_stream_get_type = g_unix_input_stream_get_type : UInt64
  fun unix_input_stream_new = g_unix_input_stream_new(fd : Int32, close_fd : LibC::Int) : Pointer(LibGio::InputStream)
  fun unix_input_stream_get_close_fd = g_unix_input_stream_get_close_fd(this : UnixInputStream*) : LibC::Int
  fun unix_input_stream_get_fd = g_unix_input_stream_get_fd(this : UnixInputStream*) : Int32
  fun unix_input_stream_set_close_fd = g_unix_input_stream_set_close_fd(this : UnixInputStream*, close_fd : LibC::Int) : Void

  struct UnixMountMonitor # object
    _data : UInt8[0]
    # Signal mountpoints-changed
    # Signal mounts-changed
  end

  fun _g_unix_mount_monitor_get_type = g_unix_mount_monitor_get_type : UInt64
  fun unix_mount_monitor_new = g_unix_mount_monitor_new : Pointer(LibGio::UnixMountMonitor)
  fun unix_mount_monitor_get = g_unix_mount_monitor_get : Pointer(LibGio::UnixMountMonitor)
  fun unix_mount_monitor_set_rate_limit = g_unix_mount_monitor_set_rate_limit(this : UnixMountMonitor*, limit_msec : Int32) : Void

  struct UnixOutputStream # object
    parent_instance : LibGio::OutputStream
    priv : Pointer(LibGio::UnixOutputStreamPrivate)
    # Property close-fd : LibC::Int
    # Property fd : Int32
  end

  fun _g_unix_output_stream_get_type = g_unix_output_stream_get_type : UInt64
  fun unix_output_stream_new = g_unix_output_stream_new(fd : Int32, close_fd : LibC::Int) : Pointer(LibGio::OutputStream)
  fun unix_output_stream_get_close_fd = g_unix_output_stream_get_close_fd(this : UnixOutputStream*) : LibC::Int
  fun unix_output_stream_get_fd = g_unix_output_stream_get_fd(this : UnixOutputStream*) : Int32
  fun unix_output_stream_set_close_fd = g_unix_output_stream_set_close_fd(this : UnixOutputStream*, close_fd : LibC::Int) : Void

  struct UnixSocketAddress # object
    parent_instance : LibGio::SocketAddress
    priv : Pointer(LibGio::UnixSocketAddressPrivate)
    # Property abstract : LibC::Int
    # Property address-type : LibGio::UnixSocketAddressType
    # Property path : Pointer(UInt8)
    # Property path-as-array : Pointer(Void)
  end

  fun _g_unix_socket_address_get_type = g_unix_socket_address_get_type : UInt64
  fun unix_socket_address_new = g_unix_socket_address_new(path : Pointer(UInt8)) : Pointer(LibGio::SocketAddress)
  fun unix_socket_address_new_abstract = g_unix_socket_address_new_abstract(path : Pointer(Int8), path_len : Int32) : Pointer(LibGio::SocketAddress)
  fun unix_socket_address_new_with_type = g_unix_socket_address_new_with_type(path : Pointer(Int8), path_len : Int32, type : LibGio::UnixSocketAddressType) : Pointer(LibGio::SocketAddress)
  fun unix_socket_address_abstract_names_supported = g_unix_socket_address_abstract_names_supported : LibC::Int
  fun unix_socket_address_get_address_type = g_unix_socket_address_get_address_type(this : UnixSocketAddress*) : LibGio::UnixSocketAddressType
  fun unix_socket_address_get_is_abstract = g_unix_socket_address_get_is_abstract(this : UnixSocketAddress*) : LibC::Int
  fun unix_socket_address_get_path = g_unix_socket_address_get_path(this : UnixSocketAddress*) : Pointer(UInt8)
  fun unix_socket_address_get_path_len = g_unix_socket_address_get_path_len(this : UnixSocketAddress*) : UInt64

  struct Vfs # object
    parent_instance : LibGObject::Object
    # Virtual function add_writable_namespaces
    # Virtual function get_file_for_path
    # Virtual function get_file_for_uri
    # Virtual function get_supported_uri_schemes
    # Virtual function is_active
    # Virtual function local_file_add_info
    # Virtual function local_file_moved
    # Virtual function local_file_removed
    # Virtual function local_file_set_attributes
    # Virtual function parse_name
  end

  fun _g_vfs_get_type = g_vfs_get_type : UInt64
  fun vfs_get_default = g_vfs_get_default : Pointer(LibGio::Vfs)
  fun vfs_get_local = g_vfs_get_local : Pointer(LibGio::Vfs)
  fun vfs_get_file_for_path = g_vfs_get_file_for_path(this : Vfs*, path : Pointer(UInt8)) : Pointer(LibGio::File)
  fun vfs_get_file_for_uri = g_vfs_get_file_for_uri(this : Vfs*, uri : Pointer(UInt8)) : Pointer(LibGio::File)
  fun vfs_get_supported_uri_schemes = g_vfs_get_supported_uri_schemes(this : Vfs*) : Pointer(Pointer(UInt8))
  fun vfs_is_active = g_vfs_is_active(this : Vfs*) : LibC::Int
  fun vfs_parse_name = g_vfs_parse_name(this : Vfs*, parse_name : Pointer(UInt8)) : Pointer(LibGio::File)
  fun vfs_register_uri_scheme = g_vfs_register_uri_scheme(this : Vfs*, scheme : Pointer(UInt8), uri_func : LibGio::VfsFileLookupFunc, uri_data : Pointer(Void), uri_destroy : LibGLib::DestroyNotify, parse_name_func : LibGio::VfsFileLookupFunc, parse_name_data : Pointer(Void), parse_name_destroy : LibGLib::DestroyNotify) : LibC::Int
  fun vfs_unregister_uri_scheme = g_vfs_unregister_uri_scheme(this : Vfs*, scheme : Pointer(UInt8)) : LibC::Int

  struct VolumeMonitor # object
    parent_instance : LibGObject::Object
    priv : Pointer(Void)
    # Signal drive-changed
    # Signal drive-connected
    # Signal drive-disconnected
    # Signal drive-eject-button
    # Signal drive-stop-button
    # Signal mount-added
    # Signal mount-changed
    # Signal mount-pre-unmount
    # Signal mount-removed
    # Signal volume-added
    # Signal volume-changed
    # Signal volume-removed
    # Virtual function drive_changed
    # Virtual function drive_connected
    # Virtual function drive_disconnected
    # Virtual function drive_eject_button
    # Virtual function drive_stop_button
    # Virtual function get_connected_drives
    # Virtual function get_mount_for_uuid
    # Virtual function get_mounts
    # Virtual function get_volume_for_uuid
    # Virtual function get_volumes
    # Virtual function mount_added
    # Virtual function mount_changed
    # Virtual function mount_pre_unmount
    # Virtual function mount_removed
    # Virtual function volume_added
    # Virtual function volume_changed
    # Virtual function volume_removed
  end

  fun _g_volume_monitor_get_type = g_volume_monitor_get_type : UInt64
  fun volume_monitor_adopt_orphan_mount = g_volume_monitor_adopt_orphan_mount(mount : Pointer(LibGio::Mount)) : Pointer(LibGio::Volume)
  fun volume_monitor_get = g_volume_monitor_get : Pointer(LibGio::VolumeMonitor)
  fun volume_monitor_get_connected_drives = g_volume_monitor_get_connected_drives(this : VolumeMonitor*) : Pointer(Void*)
  fun volume_monitor_get_mount_for_uuid = g_volume_monitor_get_mount_for_uuid(this : VolumeMonitor*, uuid : Pointer(UInt8)) : Pointer(LibGio::Mount)
  fun volume_monitor_get_mounts = g_volume_monitor_get_mounts(this : VolumeMonitor*) : Pointer(Void*)
  fun volume_monitor_get_volume_for_uuid = g_volume_monitor_get_volume_for_uuid(this : VolumeMonitor*, uuid : Pointer(UInt8)) : Pointer(LibGio::Volume)
  fun volume_monitor_get_volumes = g_volume_monitor_get_volumes(this : VolumeMonitor*) : Pointer(Void*)

  struct ZlibCompressor # object
    _data : UInt8[0]
    # Property file-info : LibGio::FileInfo
    # Property format : LibGio::ZlibCompressorFormat
    # Property level : Int32
  end

  fun _g_zlib_compressor_get_type = g_zlib_compressor_get_type : UInt64
  fun zlib_compressor_new = g_zlib_compressor_new(format : LibGio::ZlibCompressorFormat, level : Int32) : Pointer(LibGio::ZlibCompressor)
  fun zlib_compressor_get_file_info = g_zlib_compressor_get_file_info(this : ZlibCompressor*) : Pointer(LibGio::FileInfo)
  fun zlib_compressor_set_file_info = g_zlib_compressor_set_file_info(this : ZlibCompressor*, file_info : Pointer(LibGio::FileInfo)) : Void

  struct ZlibDecompressor # object
    _data : UInt8[0]
    # Property file-info : LibGio::FileInfo
    # Property format : LibGio::ZlibCompressorFormat
  end

  fun _g_zlib_decompressor_get_type = g_zlib_decompressor_get_type : UInt64
  fun zlib_decompressor_new = g_zlib_decompressor_new(format : LibGio::ZlibCompressorFormat) : Pointer(LibGio::ZlibDecompressor)
  fun zlib_decompressor_get_file_info = g_zlib_decompressor_get_file_info(this : ZlibDecompressor*) : Pointer(LibGio::FileInfo)

  ###########################################
  # #    Enums
  ###########################################

  alias BusType = Int32

  alias ConverterResult = UInt32

  alias CredentialsType = UInt32

  alias DBusError = UInt32
  fun d_bus_error_encode_gerror = g_dbus_error_encode_gerror(error : Pointer(LibGLib::Error*)) : Pointer(UInt8)
  fun d_bus_error_get_remote_error = g_dbus_error_get_remote_error(error : Pointer(LibGLib::Error*)) : Pointer(UInt8)
  fun d_bus_error_is_remote_error = g_dbus_error_is_remote_error(error : Pointer(LibGLib::Error*)) : LibC::Int
  fun d_bus_error_new_for_dbus_error = g_dbus_error_new_for_dbus_error(dbus_error_name : Pointer(UInt8), dbus_error_message : Pointer(UInt8)) : Pointer(LibGLib::Error*)
  fun d_bus_error_quark = g_dbus_error_quark : UInt32
  fun d_bus_error_register_error = g_dbus_error_register_error(error_domain : UInt32, error_code : Int32, dbus_error_name : Pointer(UInt8)) : LibC::Int
  fun d_bus_error_register_error_domain = g_dbus_error_register_error_domain(error_domain_quark_name : Pointer(UInt8), quark_volatile : Pointer(UInt64), entries : Pointer(LibGio::DBusErrorEntry), num_entries : UInt32) : Void
  fun d_bus_error_strip_remote_error = g_dbus_error_strip_remote_error(error : Pointer(LibGLib::Error*)) : LibC::Int
  fun d_bus_error_unregister_error = g_dbus_error_unregister_error(error_domain : UInt32, error_code : Int32, dbus_error_name : Pointer(UInt8)) : LibC::Int

  alias DBusMessageByteOrder = UInt32

  alias DBusMessageHeaderField = UInt32

  alias DBusMessageType = UInt32

  alias DataStreamByteOrder = UInt32

  alias DataStreamNewlineType = UInt32

  alias DriveStartStopType = UInt32

  alias EmblemOrigin = UInt32

  alias FileAttributeStatus = UInt32

  alias FileAttributeType = UInt32

  alias FileMonitorEvent = UInt32

  alias FileType = UInt32

  alias FilesystemPreviewType = UInt32

  alias IOErrorEnum = UInt32

  alias IOModuleScopeFlags = UInt32

  alias MemoryMonitorWarningLevel = UInt32

  alias MountOperationResult = UInt32

  alias NetworkConnectivity = UInt32

  alias NotificationPriority = UInt32

  alias PasswordSave = UInt32

  alias PollableReturn = Int32

  alias ResolverError = UInt32
  fun resolver_error_quark = g_resolver_error_quark : UInt32

  alias ResolverRecordType = UInt32

  alias ResourceError = UInt32
  fun resource_error_quark = g_resource_error_quark : UInt32

  alias SocketClientEvent = UInt32

  alias SocketFamily = UInt32

  alias SocketListenerEvent = UInt32

  alias SocketProtocol = Int32

  alias SocketType = UInt32

  alias TlsAuthenticationMode = UInt32

  alias TlsCertificateRequestFlags = UInt32

  alias TlsDatabaseLookupFlags = UInt32

  alias TlsError = UInt32
  fun tls_error_quark = g_tls_error_quark : UInt32

  alias TlsInteractionResult = UInt32

  alias TlsRehandshakeMode = UInt32

  alias UnixSocketAddressType = UInt32

  alias ZlibCompressorFormat = UInt32

  ###########################################
  # #    Constants
  ###########################################
  DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME      = "gio-desktop-app-info-lookup"         # : Pointer(UInt8)
  DRIVE_IDENTIFIER_KIND_UNIX_DEVICE                 = "unix-device"                         # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_DELETE                  = "access::can-delete"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE                 = "access::can-execute"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_READ                    = "access::can-read"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_RENAME                  = "access::can-rename"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_TRASH                   = "access::can-trash"                   # : Pointer(UInt8)
  FILE_ATTRIBUTE_ACCESS_CAN_WRITE                   = "access::can-write"                   # : Pointer(UInt8)
  FILE_ATTRIBUTE_DOS_IS_ARCHIVE                     = "dos::is-archive"                     # : Pointer(UInt8)
  FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT                  = "dos::is-mountpoint"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_DOS_IS_SYSTEM                      = "dos::is-system"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG              = "dos::reparse-point-tag"              # : Pointer(UInt8)
  FILE_ATTRIBUTE_ETAG_VALUE                         = "etag::value"                         # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_FREE                    = "filesystem::free"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_READONLY                = "filesystem::readonly"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_REMOTE                  = "filesystem::remote"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_SIZE                    = "filesystem::size"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_TYPE                    = "filesystem::type"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_USED                    = "filesystem::used"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW             = "filesystem::use-preview"             # : Pointer(UInt8)
  FILE_ATTRIBUTE_GVFS_BACKEND                       = "gvfs::backend"                       # : Pointer(UInt8)
  FILE_ATTRIBUTE_ID_FILE                            = "id::file"                            # : Pointer(UInt8)
  FILE_ATTRIBUTE_ID_FILESYSTEM                      = "id::filesystem"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT                = "mountable::can-eject"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT                = "mountable::can-mount"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL                 = "mountable::can-poll"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_START                = "mountable::can-start"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED       = "mountable::can-start-degraded"       # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP                 = "mountable::can-stop"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT              = "mountable::can-unmount"              # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI                  = "mountable::hal-udi"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic" # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE          = "mountable::start-stop-type"          # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE              = "mountable::unix-device"              # : Pointer(UInt8)
  FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE         = "mountable::unix-device-file"         # : Pointer(UInt8)
  FILE_ATTRIBUTE_OWNER_GROUP                        = "owner::group"                        # : Pointer(UInt8)
  FILE_ATTRIBUTE_OWNER_USER                         = "owner::user"                         # : Pointer(UInt8)
  FILE_ATTRIBUTE_OWNER_USER_REAL                    = "owner::user-real"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_PREVIEW_ICON                       = "preview::icon"                       # : Pointer(UInt8)
  FILE_ATTRIBUTE_RECENT_MODIFIED                    = "recent::modified"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_SELINUX_CONTEXT                    = "selinux::context"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE            = "standard::allocated-size"            # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE              = "standard::content-type"              # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_COPY_NAME                 = "standard::copy-name"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_DESCRIPTION               = "standard::description"               # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME              = "standard::display-name"              # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_EDIT_NAME                 = "standard::edit-name"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE         = "standard::fast-content-type"         # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_ICON                      = "standard::icon"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_IS_BACKUP                 = "standard::is-backup"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_IS_HIDDEN                 = "standard::is-hidden"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_IS_SYMLINK                = "standard::is-symlink"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL                = "standard::is-virtual"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_IS_VOLATILE               = "standard::is-volatile"               # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_NAME                      = "standard::name"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_SIZE                      = "standard::size"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_SORT_ORDER                = "standard::sort-order"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON             = "standard::symbolic-icon"             # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET            = "standard::symlink-target"            # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_TARGET_URI                = "standard::target-uri"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_STANDARD_TYPE                      = "standard::type"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_THUMBNAILING_FAILED                = "thumbnail::failed"                   # : Pointer(UInt8)
  FILE_ATTRIBUTE_THUMBNAIL_IS_VALID                 = "thumbnail::is-valid"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_THUMBNAIL_PATH                     = "thumbnail::path"                     # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_ACCESS                        = "time::access"                        # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_ACCESS_USEC                   = "time::access-usec"                   # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_CHANGED                       = "time::changed"                       # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_CHANGED_USEC                  = "time::changed-usec"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_CREATED                       = "time::created"                       # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_CREATED_USEC                  = "time::created-usec"                  # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_MODIFIED                      = "time::modified"                      # : Pointer(UInt8)
  FILE_ATTRIBUTE_TIME_MODIFIED_USEC                 = "time::modified-usec"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_TRASH_DELETION_DATE                = "trash::deletion-date"                # : Pointer(UInt8)
  FILE_ATTRIBUTE_TRASH_ITEM_COUNT                   = "trash::item-count"                   # : Pointer(UInt8)
  FILE_ATTRIBUTE_TRASH_ORIG_PATH                    = "trash::orig-path"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_BLOCKS                        = "unix::blocks"                        # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_BLOCK_SIZE                    = "unix::block-size"                    # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_DEVICE                        = "unix::device"                        # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_GID                           = "unix::gid"                           # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_INODE                         = "unix::inode"                         # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT                 = "unix::is-mountpoint"                 # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_MODE                          = "unix::mode"                          # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_NLINK                         = "unix::nlink"                         # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_RDEV                          = "unix::rdev"                          # : Pointer(UInt8)
  FILE_ATTRIBUTE_UNIX_UID                           = "unix::uid"                           # : Pointer(UInt8)
  MEMORY_MONITOR_EXTENSION_POINT_NAME               = "gio-memory-monitor"                  # : Pointer(UInt8)
  MENU_ATTRIBUTE_ACTION                             = "action"                              # : Pointer(UInt8)
  MENU_ATTRIBUTE_ACTION_NAMESPACE                   = "action-namespace"                    # : Pointer(UInt8)
  MENU_ATTRIBUTE_ICON                               = "icon"                                # : Pointer(UInt8)
  MENU_ATTRIBUTE_LABEL                              = "label"                               # : Pointer(UInt8)
  MENU_ATTRIBUTE_TARGET                             = "target"                              # : Pointer(UInt8)
  MENU_LINK_SECTION                                 = "section"                             # : Pointer(UInt8)
  MENU_LINK_SUBMENU                                 = "submenu"                             # : Pointer(UInt8)
  NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME        = "gio-native-volume-monitor"           # : Pointer(UInt8)
  NETWORK_MONITOR_EXTENSION_POINT_NAME              = "gio-network-monitor"                 # : Pointer(UInt8)
  PROXY_EXTENSION_POINT_NAME                        = "gio-proxy"                           # : Pointer(UInt8)
  PROXY_RESOLVER_EXTENSION_POINT_NAME               = "gio-proxy-resolver"                  # : Pointer(UInt8)
  SETTINGS_BACKEND_EXTENSION_POINT_NAME             = "gsettings-backend"                   # : Pointer(UInt8)
  TLS_BACKEND_EXTENSION_POINT_NAME                  = "gio-tls-backend"                     # : Pointer(UInt8)
  TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT          = "1.3.6.1.5.5.7.3.2"                   # : Pointer(UInt8)
  TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER          = "1.3.6.1.5.5.7.3.1"                   # : Pointer(UInt8)
  VFS_EXTENSION_POINT_NAME                          = "gio-vfs"                             # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_CLASS                      = "class"                               # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_HAL_UDI                    = "hal-udi"                             # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_LABEL                      = "label"                               # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_NFS_MOUNT                  = "nfs-mount"                           # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_UNIX_DEVICE                = "unix-device"                         # : Pointer(UInt8)
  VOLUME_IDENTIFIER_KIND_UUID                       = "uuid"                                # : Pointer(UInt8)
  VOLUME_MONITOR_EXTENSION_POINT_NAME               = "gio-volume-monitor"                  # : Pointer(UInt8)

  ###########################################
  # #    Functions
  ###########################################
  fun action_name_is_valid = g_action_name_is_valid(action_name : Pointer(UInt8)) : LibC::Int
  fun action_parse_detailed_name = g_action_parse_detailed_name(detailed_name : Pointer(UInt8), action_name : Pointer(UInt8)*, target_value : Pointer(LibGLib::Variant)*, error : LibGLib::Error**) : LibC::Int
  fun action_print_detailed_name = g_action_print_detailed_name(action_name : Pointer(UInt8), target_value : Pointer(LibGLib::Variant)) : Pointer(UInt8)
  fun app_info_create_from_commandline = g_app_info_create_from_commandline(commandline : Pointer(UInt8), application_name : Pointer(UInt8), flags : LibGio::AppInfoCreateFlags, error : LibGLib::Error**) : Pointer(LibGio::AppInfo)
  fun app_info_get_all = g_app_info_get_all : Pointer(Void*)
  fun app_info_get_all_for_type = g_app_info_get_all_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_get_default_for_type = g_app_info_get_default_for_type(content_type : Pointer(UInt8), must_support_uris : LibC::Int) : Pointer(LibGio::AppInfo)
  fun app_info_get_default_for_uri_scheme = g_app_info_get_default_for_uri_scheme(uri_scheme : Pointer(UInt8)) : Pointer(LibGio::AppInfo)
  fun app_info_get_fallback_for_type = g_app_info_get_fallback_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_get_recommended_for_type = g_app_info_get_recommended_for_type(content_type : Pointer(UInt8)) : Pointer(Void*)
  fun app_info_launch_default_for_uri = g_app_info_launch_default_for_uri(uri : Pointer(UInt8), context : Pointer(LibGio::AppLaunchContext), error : LibGLib::Error**) : LibC::Int
  fun app_info_launch_default_for_uri_async = g_app_info_launch_default_for_uri_async(uri : Pointer(UInt8), context : Pointer(LibGio::AppLaunchContext), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun app_info_launch_default_for_uri_finish = g_app_info_launch_default_for_uri_finish(result : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : LibC::Int
  fun app_info_reset_type_associations = g_app_info_reset_type_associations(content_type : Pointer(UInt8)) : Void
  fun async_initable_newv_async = g_async_initable_newv_async(object_type : UInt64, n_parameters : UInt32, parameters : Pointer(LibGObject::Parameter), io_priority : Int32, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun bus_get = g_bus_get(bus_type : LibGio::BusType, cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun bus_get_finish = g_bus_get_finish(res : Pointer(LibGio::AsyncResult), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun bus_get_sync = g_bus_get_sync(bus_type : LibGio::BusType, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::DBusConnection)
  fun bus_own_name_on_connection = g_bus_own_name_on_connection_with_closures(connection : Pointer(LibGio::DBusConnection), name : Pointer(UInt8), flags : LibGio::BusNameOwnerFlags, name_acquired_closure : Pointer(LibGObject::Closure), name_lost_closure : Pointer(LibGObject::Closure)) : UInt32
  fun bus_own_name = g_bus_own_name_with_closures(bus_type : LibGio::BusType, name : Pointer(UInt8), flags : LibGio::BusNameOwnerFlags, bus_acquired_closure : Pointer(LibGObject::Closure), name_acquired_closure : Pointer(LibGObject::Closure), name_lost_closure : Pointer(LibGObject::Closure)) : UInt32
  fun bus_unown_name = g_bus_unown_name(owner_id : UInt32) : Void
  fun bus_unwatch_name = g_bus_unwatch_name(watcher_id : UInt32) : Void
  fun bus_watch_name_on_connection = g_bus_watch_name_on_connection_with_closures(connection : Pointer(LibGio::DBusConnection), name : Pointer(UInt8), flags : LibGio::BusNameWatcherFlags, name_appeared_closure : Pointer(LibGObject::Closure), name_vanished_closure : Pointer(LibGObject::Closure)) : UInt32
  fun bus_watch_name = g_bus_watch_name_with_closures(bus_type : LibGio::BusType, name : Pointer(UInt8), flags : LibGio::BusNameWatcherFlags, name_appeared_closure : Pointer(LibGObject::Closure), name_vanished_closure : Pointer(LibGObject::Closure)) : UInt32
  fun content_type_can_be_executable = g_content_type_can_be_executable(type : Pointer(UInt8)) : LibC::Int
  fun content_type_equals = g_content_type_equals(type1 : Pointer(UInt8), type2 : Pointer(UInt8)) : LibC::Int
  fun content_type_from_mime_type = g_content_type_from_mime_type(mime_type : Pointer(UInt8)) : Pointer(UInt8)
  fun content_type_get_description = g_content_type_get_description(type : Pointer(UInt8)) : Pointer(UInt8)
  fun content_type_get_generic_icon_name = g_content_type_get_generic_icon_name(type : Pointer(UInt8)) : Pointer(UInt8)
  fun content_type_get_icon = g_content_type_get_icon(type : Pointer(UInt8)) : Pointer(LibGio::Icon)
  fun content_type_get_mime_dirs = g_content_type_get_mime_dirs : Pointer(Pointer(UInt8))
  fun content_type_get_mime_type = g_content_type_get_mime_type(type : Pointer(UInt8)) : Pointer(UInt8)
  fun content_type_get_symbolic_icon = g_content_type_get_symbolic_icon(type : Pointer(UInt8)) : Pointer(LibGio::Icon)
  fun content_type_guess = g_content_type_guess(filename : Pointer(UInt8), data : Pointer(UInt8), data_size : UInt64, result_uncertain : LibC::Int*) : Pointer(UInt8)
  fun content_type_guess_for_tree = g_content_type_guess_for_tree(root : Pointer(LibGio::File)) : Pointer(Pointer(UInt8))
  fun content_type_is_a = g_content_type_is_a(type : Pointer(UInt8), supertype : Pointer(UInt8)) : LibC::Int
  fun content_type_is_mime_type = g_content_type_is_mime_type(type : Pointer(UInt8), mime_type : Pointer(UInt8)) : LibC::Int
  fun content_type_is_unknown = g_content_type_is_unknown(type : Pointer(UInt8)) : LibC::Int
  fun content_type_set_mime_dirs = g_content_type_set_mime_dirs(dirs : Pointer(Pointer(UInt8))) : Void
  fun content_types_get_registered = g_content_types_get_registered : Pointer(Void*)
  fun dbus_address_escape_value = g_dbus_address_escape_value(string : Pointer(UInt8)) : Pointer(UInt8)
  fun dbus_address_get_for_bus_sync = g_dbus_address_get_for_bus_sync(bus_type : LibGio::BusType, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(UInt8)
  fun dbus_address_get_stream = g_dbus_address_get_stream(address : Pointer(UInt8), cancellable : Pointer(LibGio::Cancellable), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void)) : Void
  fun dbus_address_get_stream_finish = g_dbus_address_get_stream_finish(res : Pointer(LibGio::AsyncResult), out_guid : Pointer(UInt8)*, error : LibGLib::Error**) : Pointer(LibGio::IOStream)
  fun dbus_address_get_stream_sync = g_dbus_address_get_stream_sync(address : Pointer(UInt8), out_guid : Pointer(UInt8)*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGio::IOStream)
  fun dbus_annotation_info_lookup = g_dbus_annotation_info_lookup(annotations : Pointer(Pointer(LibGio::DBusAnnotationInfo)), name : Pointer(UInt8)) : Pointer(UInt8)
  fun dbus_error_encode_gerror = g_dbus_error_encode_gerror(error : Pointer(LibGLib::Error*)) : Pointer(UInt8)
  fun dbus_error_get_remote_error = g_dbus_error_get_remote_error(error : Pointer(LibGLib::Error*)) : Pointer(UInt8)
  fun dbus_error_is_remote_error = g_dbus_error_is_remote_error(error : Pointer(LibGLib::Error*)) : LibC::Int
  fun dbus_error_new_for_dbus_error = g_dbus_error_new_for_dbus_error(dbus_error_name : Pointer(UInt8), dbus_error_message : Pointer(UInt8)) : Pointer(LibGLib::Error*)
  fun dbus_error_quark = g_dbus_error_quark : UInt32
  fun dbus_error_register_error = g_dbus_error_register_error(error_domain : UInt32, error_code : Int32, dbus_error_name : Pointer(UInt8)) : LibC::Int
  fun dbus_error_register_error_domain = g_dbus_error_register_error_domain(error_domain_quark_name : Pointer(UInt8), quark_volatile : Pointer(UInt64), entries : Pointer(LibGio::DBusErrorEntry), num_entries : UInt32) : Void
  fun dbus_error_strip_remote_error = g_dbus_error_strip_remote_error(error : Pointer(LibGLib::Error*)) : LibC::Int
  fun dbus_error_unregister_error = g_dbus_error_unregister_error(error_domain : UInt32, error_code : Int32, dbus_error_name : Pointer(UInt8)) : LibC::Int
  fun dbus_generate_guid = g_dbus_generate_guid : Pointer(UInt8)
  fun dbus_gvalue_to_gvariant = g_dbus_gvalue_to_gvariant(gvalue : Pointer(LibGObject::Value), type : Pointer(LibGLib::VariantType)) : Pointer(LibGLib::Variant)
  fun dbus_gvariant_to_gvalue = g_dbus_gvariant_to_gvalue(value : Pointer(LibGLib::Variant), out_gvalue : LibGObject::Value*) : Void
  fun dbus_is_address = g_dbus_is_address(string : Pointer(UInt8)) : LibC::Int
  fun dbus_is_guid = g_dbus_is_guid(string : Pointer(UInt8)) : LibC::Int
  fun dbus_is_interface_name = g_dbus_is_interface_name(string : Pointer(UInt8)) : LibC::Int
  fun dbus_is_member_name = g_dbus_is_member_name(string : Pointer(UInt8)) : LibC::Int
  fun dbus_is_name = g_dbus_is_name(string : Pointer(UInt8)) : LibC::Int
  fun dbus_is_supported_address = g_dbus_is_supported_address(string : Pointer(UInt8), error : LibGLib::Error**) : LibC::Int
  fun dbus_is_unique_name = g_dbus_is_unique_name(string : Pointer(UInt8)) : LibC::Int
  fun dtls_client_connection_new = g_dtls_client_connection_new(base_socket : Pointer(LibGio::DatagramBased), server_identity : Pointer(LibGio::SocketConnectable), error : LibGLib::Error**) : Pointer(LibGio::DtlsClientConnection)
  fun dtls_server_connection_new = g_dtls_server_connection_new(base_socket : Pointer(LibGio::DatagramBased), certificate : Pointer(LibGio::TlsCertificate), error : LibGLib::Error**) : Pointer(LibGio::DtlsServerConnection)
  fun file_new_for_commandline_arg = g_file_new_for_commandline_arg(arg : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_commandline_arg_and_cwd = g_file_new_for_commandline_arg_and_cwd(arg : Pointer(UInt8), cwd : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_path = g_file_new_for_path(path : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_for_uri = g_file_new_for_uri(uri : Pointer(UInt8)) : Pointer(LibGio::File)
  fun file_new_tmp = g_file_new_tmp(tmpl : Pointer(UInt8), iostream : Pointer(LibGio::FileIOStream)*, error : LibGLib::Error**) : Pointer(LibGio::File)
  fun file_parse_name = g_file_parse_name(parse_name : Pointer(UInt8)) : Pointer(LibGio::File)
  fun icon_deserialize = g_icon_deserialize(value : Pointer(LibGLib::Variant)) : Pointer(LibGio::Icon)
  fun icon_hash = g_icon_hash(icon : Pointer(Void)) : UInt32
  fun icon_new_for_string = g_icon_new_for_string(str : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::Icon)
  fun initable_newv = g_initable_newv(object_type : UInt64, n_parameters : UInt32, parameters : Pointer(LibGObject::Parameter), cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Pointer(LibGObject::Object)
  fun io_error_from_errno = g_io_error_from_errno(err_no : Int32) : LibGio::IOErrorEnum
  fun io_error_quark = g_io_error_quark : UInt32
  fun io_extension_point_implement = g_io_extension_point_implement(extension_point_name : Pointer(UInt8), type : UInt64, extension_name : Pointer(UInt8), priority : Int32) : Pointer(LibGio::IOExtension)
  fun io_extension_point_lookup = g_io_extension_point_lookup(name : Pointer(UInt8)) : Pointer(LibGio::IOExtensionPoint)
  fun io_extension_point_register = g_io_extension_point_register(name : Pointer(UInt8)) : Pointer(LibGio::IOExtensionPoint)
  fun io_modules_load_all_in_directory = g_io_modules_load_all_in_directory(dirname : Pointer(UInt8)) : Pointer(Void*)
  fun io_modules_load_all_in_directory_with_scope = g_io_modules_load_all_in_directory_with_scope(dirname : Pointer(UInt8), scope : Pointer(LibGio::IOModuleScope)) : Pointer(Void*)
  fun io_modules_scan_all_in_directory = g_io_modules_scan_all_in_directory(dirname : Pointer(UInt8)) : Void
  fun io_modules_scan_all_in_directory_with_scope = g_io_modules_scan_all_in_directory_with_scope(dirname : Pointer(UInt8), scope : Pointer(LibGio::IOModuleScope)) : Void
  fun io_scheduler_cancel_all_jobs = g_io_scheduler_cancel_all_jobs : Void
  fun io_scheduler_push_job = g_io_scheduler_push_job(job_func : LibGio::IOSchedulerJobFunc, user_data : Pointer(Void), notify : LibGLib::DestroyNotify, io_priority : Int32, cancellable : Pointer(LibGio::Cancellable)) : Void
  fun keyfile_settings_backend_new = g_keyfile_settings_backend_new(filename : Pointer(UInt8), root_path : Pointer(UInt8), root_group : Pointer(UInt8)) : Pointer(LibGio::SettingsBackend)
  fun memory_monitor_dup_default = g_memory_monitor_dup_default : Pointer(LibGio::MemoryMonitor)
  fun memory_settings_backend_new = g_memory_settings_backend_new : Pointer(LibGio::SettingsBackend)
  fun network_monitor_get_default = g_network_monitor_get_default : Pointer(LibGio::NetworkMonitor)
  fun networking_init = g_networking_init : Void
  fun null_settings_backend_new = g_null_settings_backend_new : Pointer(LibGio::SettingsBackend)
  fun pollable_source_new = g_pollable_source_new(pollable_stream : Pointer(LibGObject::Object)) : Pointer(LibGLib::Source)
  fun pollable_source_new_full = g_pollable_source_new_full(pollable_stream : Pointer(LibGObject::Object), child_source : Pointer(LibGLib::Source), cancellable : Pointer(LibGio::Cancellable)) : Pointer(LibGLib::Source)
  fun pollable_stream_read = g_pollable_stream_read(stream : Pointer(LibGio::InputStream), buffer : Pointer(UInt8), count : UInt64, blocking : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun pollable_stream_write = g_pollable_stream_write(stream : Pointer(LibGio::OutputStream), buffer : Pointer(UInt8), count : UInt64, blocking : LibC::Int, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : Int64
  fun pollable_stream_write_all = g_pollable_stream_write_all(stream : Pointer(LibGio::OutputStream), buffer : Pointer(UInt8), count : UInt64, blocking : LibC::Int, bytes_written : UInt64*, cancellable : Pointer(LibGio::Cancellable), error : LibGLib::Error**) : LibC::Int
  fun proxy_get_default_for_protocol = g_proxy_get_default_for_protocol(protocol : Pointer(UInt8)) : Pointer(LibGio::Proxy)
  fun proxy_resolver_get_default = g_proxy_resolver_get_default : Pointer(LibGio::ProxyResolver)
  fun resolver_error_quark = g_resolver_error_quark : UInt32
  fun resource_error_quark = g_resource_error_quark : UInt32
  fun resource_load = g_resource_load(filename : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::Resource)
  fun resources_enumerate_children = g_resources_enumerate_children(path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(Pointer(UInt8))
  fun resources_get_info = g_resources_get_info(path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, size : UInt64*, flags : UInt32*, error : LibGLib::Error**) : LibC::Int
  fun resources_lookup_data = g_resources_lookup_data(path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(LibGLib::Bytes)
  fun resources_open_stream = g_resources_open_stream(path : Pointer(UInt8), lookup_flags : LibGio::ResourceLookupFlags, error : LibGLib::Error**) : Pointer(LibGio::InputStream)
  fun resources_register = g_resources_register(resource : Pointer(LibGio::Resource)) : Void
  fun resources_unregister = g_resources_unregister(resource : Pointer(LibGio::Resource)) : Void
  fun settings_schema_source_get_default = g_settings_schema_source_get_default : Pointer(LibGio::SettingsSchemaSource)
  fun simple_async_report_gerror_in_idle = g_simple_async_report_gerror_in_idle(object : Pointer(LibGObject::Object), callback : LibGio::AsyncReadyCallback, user_data : Pointer(Void), error : Pointer(LibGLib::Error*)) : Void
  fun tls_backend_get_default = g_tls_backend_get_default : Pointer(LibGio::TlsBackend)
  fun tls_client_connection_new = g_tls_client_connection_new(base_io_stream : Pointer(LibGio::IOStream), server_identity : Pointer(LibGio::SocketConnectable), error : LibGLib::Error**) : Pointer(LibGio::TlsClientConnection)
  fun tls_error_quark = g_tls_error_quark : UInt32
  fun tls_file_database_new = g_tls_file_database_new(anchors : Pointer(UInt8), error : LibGLib::Error**) : Pointer(LibGio::TlsFileDatabase)
  fun tls_server_connection_new = g_tls_server_connection_new(base_io_stream : Pointer(LibGio::IOStream), certificate : Pointer(LibGio::TlsCertificate), error : LibGLib::Error**) : Pointer(LibGio::TlsServerConnection)
  fun unix_is_mount_path_system_internal = g_unix_is_mount_path_system_internal(mount_path : Pointer(UInt8)) : LibC::Int
  fun unix_is_system_device_path = g_unix_is_system_device_path(device_path : Pointer(UInt8)) : LibC::Int
  fun unix_is_system_fs_type = g_unix_is_system_fs_type(fs_type : Pointer(UInt8)) : LibC::Int
  fun unix_mount_at = g_unix_mount_at(mount_path : Pointer(UInt8), time_read : UInt64*) : Pointer(LibGio::UnixMountEntry)
  fun unix_mount_compare = g_unix_mount_compare(mount1 : Pointer(LibGio::UnixMountEntry), mount2 : Pointer(LibGio::UnixMountEntry)) : Int32
  fun unix_mount_copy = g_unix_mount_copy(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(LibGio::UnixMountEntry)
  fun unix_mount_for = g_unix_mount_for(file_path : Pointer(UInt8), time_read : UInt64*) : Pointer(LibGio::UnixMountEntry)
  fun unix_mount_free = g_unix_mount_free(mount_entry : Pointer(LibGio::UnixMountEntry)) : Void
  fun unix_mount_get_device_path = g_unix_mount_get_device_path(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_get_fs_type = g_unix_mount_get_fs_type(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_get_mount_path = g_unix_mount_get_mount_path(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_get_options = g_unix_mount_get_options(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_get_root_path = g_unix_mount_get_root_path(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_guess_can_eject = g_unix_mount_guess_can_eject(mount_entry : Pointer(LibGio::UnixMountEntry)) : LibC::Int
  fun unix_mount_guess_icon = g_unix_mount_guess_icon(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(LibGio::Icon)
  fun unix_mount_guess_name = g_unix_mount_guess_name(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(UInt8)
  fun unix_mount_guess_should_display = g_unix_mount_guess_should_display(mount_entry : Pointer(LibGio::UnixMountEntry)) : LibC::Int
  fun unix_mount_guess_symbolic_icon = g_unix_mount_guess_symbolic_icon(mount_entry : Pointer(LibGio::UnixMountEntry)) : Pointer(LibGio::Icon)
  fun unix_mount_is_readonly = g_unix_mount_is_readonly(mount_entry : Pointer(LibGio::UnixMountEntry)) : LibC::Int
  fun unix_mount_is_system_internal = g_unix_mount_is_system_internal(mount_entry : Pointer(LibGio::UnixMountEntry)) : LibC::Int
  fun unix_mount_points_changed_since = g_unix_mount_points_changed_since(time : UInt64) : LibC::Int
  fun unix_mount_points_get = g_unix_mount_points_get(time_read : UInt64*) : Pointer(Void*)
  fun unix_mounts_changed_since = g_unix_mounts_changed_since(time : UInt64) : LibC::Int
  fun unix_mounts_get = g_unix_mounts_get(time_read : UInt64*) : Pointer(Void*)

  ###########################################
  # #    Callbacks
  ###########################################
  alias AsyncReadyCallback = Pointer(LibGObject::Object), Pointer(LibGio::AsyncResult), Pointer(Void) -> Void
  alias BusAcquiredCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(Void) -> Void
  alias BusNameAcquiredCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(Void) -> Void
  alias BusNameAppearedCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(Void) -> Void
  alias BusNameLostCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(Void) -> Void
  alias BusNameVanishedCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(Void) -> Void
  alias CancellableSourceFunc = Pointer(LibGio::Cancellable), Pointer(Void) -> LibC::Int
  alias DBusInterfaceGetPropertyFunc = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Error*), Pointer(Void) -> Pointer(LibGLib::Variant)
  alias DBusInterfaceMethodCallFunc = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGio::DBusMethodInvocation), Pointer(Void) -> Void
  alias DBusInterfaceSetPropertyFunc = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(LibGLib::Error*), Pointer(Void) -> LibC::Int
  alias DBusMessageFilterFunction = Pointer(LibGio::DBusConnection), Pointer(LibGio::DBusMessage), LibC::Int, Pointer(Void) -> Pointer(LibGio::DBusMessage)
  alias DBusProxyTypeFunc = Pointer(LibGio::DBusObjectManagerClient), Pointer(UInt8), Pointer(UInt8), Pointer(Void) -> UInt64
  alias DBusSignalCallback = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(LibGLib::Variant), Pointer(Void) -> Void
  alias DBusSubtreeDispatchFunc = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(Void), Pointer(Void) -> Pointer(LibGio::DBusInterfaceVTable)
  alias DBusSubtreeIntrospectFunc = Pointer(LibGio::DBusConnection), Pointer(UInt8), Pointer(UInt8), Pointer(UInt8), Pointer(Void) -> Pointer(LibGio::DBusInterfaceInfo)
  alias DatagramBasedSourceFunc = Pointer(LibGio::DatagramBased), LibGLib::IOCondition, Pointer(Void) -> LibC::Int
  alias DesktopAppLaunchCallback = Pointer(LibGio::DesktopAppInfo), Int32, Pointer(Void) -> Void
  alias FileMeasureProgressCallback = LibC::Int, UInt64, UInt64, UInt64, Pointer(Void) -> Void
  alias FileProgressCallback = Int64, Int64, Pointer(Void) -> Void
  alias FileReadMoreCallback = Pointer(UInt8), Int64, Pointer(Void) -> LibC::Int
  alias IOSchedulerJobFunc = Pointer(LibGio::IOSchedulerJob), Pointer(LibGio::Cancellable), Pointer(Void) -> LibC::Int
  alias PollableSourceFunc = Pointer(LibGObject::Object), Pointer(Void) -> LibC::Int
  alias ReallocFunc = Pointer(Void), UInt64 -> Pointer(Void)
  alias SettingsBindGetMapping = Pointer(LibGObject::Value), Pointer(LibGLib::Variant), Pointer(Void) -> LibC::Int
  alias SettingsBindSetMapping = Pointer(LibGObject::Value), Pointer(LibGLib::VariantType), Pointer(Void) -> Pointer(LibGLib::Variant)
  alias SettingsGetMapping = Pointer(LibGLib::Variant), Pointer(Void), Pointer(Void) -> LibC::Int
  alias SimpleAsyncThreadFunc = Pointer(LibGio::SimpleAsyncResult), Pointer(LibGObject::Object), Pointer(LibGio::Cancellable) -> Void
  alias SocketSourceFunc = Pointer(LibGio::Socket), LibGLib::IOCondition, Pointer(Void) -> LibC::Int
  alias TaskThreadFunc = Pointer(LibGio::Task), Pointer(LibGObject::Object), Pointer(Void), Pointer(LibGio::Cancellable) -> Void
  alias VfsFileLookupFunc = Pointer(LibGio::Vfs), Pointer(UInt8), Pointer(Void) -> Pointer(LibGio::File)
end

module Gio
  DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME      = LibGio::DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME
  DRIVE_IDENTIFIER_KIND_UNIX_DEVICE                 = LibGio::DRIVE_IDENTIFIER_KIND_UNIX_DEVICE
  FILE_ATTRIBUTE_ACCESS_CAN_DELETE                  = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_DELETE
  FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE                 = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE
  FILE_ATTRIBUTE_ACCESS_CAN_READ                    = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_READ
  FILE_ATTRIBUTE_ACCESS_CAN_RENAME                  = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_RENAME
  FILE_ATTRIBUTE_ACCESS_CAN_TRASH                   = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_TRASH
  FILE_ATTRIBUTE_ACCESS_CAN_WRITE                   = LibGio::FILE_ATTRIBUTE_ACCESS_CAN_WRITE
  FILE_ATTRIBUTE_DOS_IS_ARCHIVE                     = LibGio::FILE_ATTRIBUTE_DOS_IS_ARCHIVE
  FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT                  = LibGio::FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT
  FILE_ATTRIBUTE_DOS_IS_SYSTEM                      = LibGio::FILE_ATTRIBUTE_DOS_IS_SYSTEM
  FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG              = LibGio::FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG
  FILE_ATTRIBUTE_ETAG_VALUE                         = LibGio::FILE_ATTRIBUTE_ETAG_VALUE
  FILE_ATTRIBUTE_FILESYSTEM_FREE                    = LibGio::FILE_ATTRIBUTE_FILESYSTEM_FREE
  FILE_ATTRIBUTE_FILESYSTEM_READONLY                = LibGio::FILE_ATTRIBUTE_FILESYSTEM_READONLY
  FILE_ATTRIBUTE_FILESYSTEM_REMOTE                  = LibGio::FILE_ATTRIBUTE_FILESYSTEM_REMOTE
  FILE_ATTRIBUTE_FILESYSTEM_SIZE                    = LibGio::FILE_ATTRIBUTE_FILESYSTEM_SIZE
  FILE_ATTRIBUTE_FILESYSTEM_TYPE                    = LibGio::FILE_ATTRIBUTE_FILESYSTEM_TYPE
  FILE_ATTRIBUTE_FILESYSTEM_USED                    = LibGio::FILE_ATTRIBUTE_FILESYSTEM_USED
  FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW             = LibGio::FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW
  FILE_ATTRIBUTE_GVFS_BACKEND                       = LibGio::FILE_ATTRIBUTE_GVFS_BACKEND
  FILE_ATTRIBUTE_ID_FILE                            = LibGio::FILE_ATTRIBUTE_ID_FILE
  FILE_ATTRIBUTE_ID_FILESYSTEM                      = LibGio::FILE_ATTRIBUTE_ID_FILESYSTEM
  FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT                = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT
  FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT                = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT
  FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL                 = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL
  FILE_ATTRIBUTE_MOUNTABLE_CAN_START                = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_START
  FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED       = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED
  FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP                 = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP
  FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT              = LibGio::FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT
  FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI                  = LibGio::FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI
  FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = LibGio::FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC
  FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE          = LibGio::FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE
  FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE              = LibGio::FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE
  FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE         = LibGio::FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE
  FILE_ATTRIBUTE_OWNER_GROUP                        = LibGio::FILE_ATTRIBUTE_OWNER_GROUP
  FILE_ATTRIBUTE_OWNER_USER                         = LibGio::FILE_ATTRIBUTE_OWNER_USER
  FILE_ATTRIBUTE_OWNER_USER_REAL                    = LibGio::FILE_ATTRIBUTE_OWNER_USER_REAL
  FILE_ATTRIBUTE_PREVIEW_ICON                       = LibGio::FILE_ATTRIBUTE_PREVIEW_ICON
  FILE_ATTRIBUTE_RECENT_MODIFIED                    = LibGio::FILE_ATTRIBUTE_RECENT_MODIFIED
  FILE_ATTRIBUTE_SELINUX_CONTEXT                    = LibGio::FILE_ATTRIBUTE_SELINUX_CONTEXT
  FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE            = LibGio::FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE
  FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE              = LibGio::FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE
  FILE_ATTRIBUTE_STANDARD_COPY_NAME                 = LibGio::FILE_ATTRIBUTE_STANDARD_COPY_NAME
  FILE_ATTRIBUTE_STANDARD_DESCRIPTION               = LibGio::FILE_ATTRIBUTE_STANDARD_DESCRIPTION
  FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME              = LibGio::FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
  FILE_ATTRIBUTE_STANDARD_EDIT_NAME                 = LibGio::FILE_ATTRIBUTE_STANDARD_EDIT_NAME
  FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE         = LibGio::FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE
  FILE_ATTRIBUTE_STANDARD_ICON                      = LibGio::FILE_ATTRIBUTE_STANDARD_ICON
  FILE_ATTRIBUTE_STANDARD_IS_BACKUP                 = LibGio::FILE_ATTRIBUTE_STANDARD_IS_BACKUP
  FILE_ATTRIBUTE_STANDARD_IS_HIDDEN                 = LibGio::FILE_ATTRIBUTE_STANDARD_IS_HIDDEN
  FILE_ATTRIBUTE_STANDARD_IS_SYMLINK                = LibGio::FILE_ATTRIBUTE_STANDARD_IS_SYMLINK
  FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL                = LibGio::FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL
  FILE_ATTRIBUTE_STANDARD_IS_VOLATILE               = LibGio::FILE_ATTRIBUTE_STANDARD_IS_VOLATILE
  FILE_ATTRIBUTE_STANDARD_NAME                      = LibGio::FILE_ATTRIBUTE_STANDARD_NAME
  FILE_ATTRIBUTE_STANDARD_SIZE                      = LibGio::FILE_ATTRIBUTE_STANDARD_SIZE
  FILE_ATTRIBUTE_STANDARD_SORT_ORDER                = LibGio::FILE_ATTRIBUTE_STANDARD_SORT_ORDER
  FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON             = LibGio::FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON
  FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET            = LibGio::FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
  FILE_ATTRIBUTE_STANDARD_TARGET_URI                = LibGio::FILE_ATTRIBUTE_STANDARD_TARGET_URI
  FILE_ATTRIBUTE_STANDARD_TYPE                      = LibGio::FILE_ATTRIBUTE_STANDARD_TYPE
  FILE_ATTRIBUTE_THUMBNAILING_FAILED                = LibGio::FILE_ATTRIBUTE_THUMBNAILING_FAILED
  FILE_ATTRIBUTE_THUMBNAIL_IS_VALID                 = LibGio::FILE_ATTRIBUTE_THUMBNAIL_IS_VALID
  FILE_ATTRIBUTE_THUMBNAIL_PATH                     = LibGio::FILE_ATTRIBUTE_THUMBNAIL_PATH
  FILE_ATTRIBUTE_TIME_ACCESS                        = LibGio::FILE_ATTRIBUTE_TIME_ACCESS
  FILE_ATTRIBUTE_TIME_ACCESS_USEC                   = LibGio::FILE_ATTRIBUTE_TIME_ACCESS_USEC
  FILE_ATTRIBUTE_TIME_CHANGED                       = LibGio::FILE_ATTRIBUTE_TIME_CHANGED
  FILE_ATTRIBUTE_TIME_CHANGED_USEC                  = LibGio::FILE_ATTRIBUTE_TIME_CHANGED_USEC
  FILE_ATTRIBUTE_TIME_CREATED                       = LibGio::FILE_ATTRIBUTE_TIME_CREATED
  FILE_ATTRIBUTE_TIME_CREATED_USEC                  = LibGio::FILE_ATTRIBUTE_TIME_CREATED_USEC
  FILE_ATTRIBUTE_TIME_MODIFIED                      = LibGio::FILE_ATTRIBUTE_TIME_MODIFIED
  FILE_ATTRIBUTE_TIME_MODIFIED_USEC                 = LibGio::FILE_ATTRIBUTE_TIME_MODIFIED_USEC
  FILE_ATTRIBUTE_TRASH_DELETION_DATE                = LibGio::FILE_ATTRIBUTE_TRASH_DELETION_DATE
  FILE_ATTRIBUTE_TRASH_ITEM_COUNT                   = LibGio::FILE_ATTRIBUTE_TRASH_ITEM_COUNT
  FILE_ATTRIBUTE_TRASH_ORIG_PATH                    = LibGio::FILE_ATTRIBUTE_TRASH_ORIG_PATH
  FILE_ATTRIBUTE_UNIX_BLOCKS                        = LibGio::FILE_ATTRIBUTE_UNIX_BLOCKS
  FILE_ATTRIBUTE_UNIX_BLOCK_SIZE                    = LibGio::FILE_ATTRIBUTE_UNIX_BLOCK_SIZE
  FILE_ATTRIBUTE_UNIX_DEVICE                        = LibGio::FILE_ATTRIBUTE_UNIX_DEVICE
  FILE_ATTRIBUTE_UNIX_GID                           = LibGio::FILE_ATTRIBUTE_UNIX_GID
  FILE_ATTRIBUTE_UNIX_INODE                         = LibGio::FILE_ATTRIBUTE_UNIX_INODE
  FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT                 = LibGio::FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT
  FILE_ATTRIBUTE_UNIX_MODE                          = LibGio::FILE_ATTRIBUTE_UNIX_MODE
  FILE_ATTRIBUTE_UNIX_NLINK                         = LibGio::FILE_ATTRIBUTE_UNIX_NLINK
  FILE_ATTRIBUTE_UNIX_RDEV                          = LibGio::FILE_ATTRIBUTE_UNIX_RDEV
  FILE_ATTRIBUTE_UNIX_UID                           = LibGio::FILE_ATTRIBUTE_UNIX_UID
  MEMORY_MONITOR_EXTENSION_POINT_NAME               = LibGio::MEMORY_MONITOR_EXTENSION_POINT_NAME
  MENU_ATTRIBUTE_ACTION                             = LibGio::MENU_ATTRIBUTE_ACTION
  MENU_ATTRIBUTE_ACTION_NAMESPACE                   = LibGio::MENU_ATTRIBUTE_ACTION_NAMESPACE
  MENU_ATTRIBUTE_ICON                               = LibGio::MENU_ATTRIBUTE_ICON
  MENU_ATTRIBUTE_LABEL                              = LibGio::MENU_ATTRIBUTE_LABEL
  MENU_ATTRIBUTE_TARGET                             = LibGio::MENU_ATTRIBUTE_TARGET
  MENU_LINK_SECTION                                 = LibGio::MENU_LINK_SECTION
  MENU_LINK_SUBMENU                                 = LibGio::MENU_LINK_SUBMENU
  NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME        = LibGio::NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME
  NETWORK_MONITOR_EXTENSION_POINT_NAME              = LibGio::NETWORK_MONITOR_EXTENSION_POINT_NAME
  PROXY_EXTENSION_POINT_NAME                        = LibGio::PROXY_EXTENSION_POINT_NAME
  PROXY_RESOLVER_EXTENSION_POINT_NAME               = LibGio::PROXY_RESOLVER_EXTENSION_POINT_NAME
  SETTINGS_BACKEND_EXTENSION_POINT_NAME             = LibGio::SETTINGS_BACKEND_EXTENSION_POINT_NAME
  TLS_BACKEND_EXTENSION_POINT_NAME                  = LibGio::TLS_BACKEND_EXTENSION_POINT_NAME
  TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT          = LibGio::TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT
  TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER          = LibGio::TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
  VFS_EXTENSION_POINT_NAME                          = LibGio::VFS_EXTENSION_POINT_NAME
  VOLUME_IDENTIFIER_KIND_CLASS                      = LibGio::VOLUME_IDENTIFIER_KIND_CLASS
  VOLUME_IDENTIFIER_KIND_HAL_UDI                    = LibGio::VOLUME_IDENTIFIER_KIND_HAL_UDI
  VOLUME_IDENTIFIER_KIND_LABEL                      = LibGio::VOLUME_IDENTIFIER_KIND_LABEL
  VOLUME_IDENTIFIER_KIND_NFS_MOUNT                  = LibGio::VOLUME_IDENTIFIER_KIND_NFS_MOUNT
  VOLUME_IDENTIFIER_KIND_UNIX_DEVICE                = LibGio::VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
  VOLUME_IDENTIFIER_KIND_UUID                       = LibGio::VOLUME_IDENTIFIER_KIND_UUID
  VOLUME_MONITOR_EXTENSION_POINT_NAME               = LibGio::VOLUME_MONITOR_EXTENSION_POINT_NAME

  def self.action_name_is_valid(action_name : ::String)
    __var0 = LibGio.action_name_is_valid(action_name.to_unsafe)
    (__var0 == 1)
  end

  def self.action_parse_detailed_name(detailed_name : ::String, target_value : GLib::Variant)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.action_parse_detailed_name(detailed_name.to_unsafe, out action_name, target_value, pointerof(__var0))
    GLib::Error.assert(__var0)
    {(__var1 == 1), ::String.new(action_name)}
  end

  def self.action_print_detailed_name(action_name : ::String, target_value : GLib::Variant?)
    __var0 = LibGio.action_print_detailed_name(action_name.to_unsafe, target_value ? target_value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
    GObject.raise_unexpected_null("g_action_print_detailed_name") if __var0.null?
    ::String.new(__var0)
  end

  def self.app_info_create_from_commandline(commandline : ::String, application_name : ::String?, flags : Gio::AppInfoCreateFlags)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.app_info_create_from_commandline(commandline.to_unsafe, application_name ? application_name.to_unsafe : Pointer(UInt8).null, flags, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_app_info_create_from_commandline") if __var1.null?
    Gio::AppInfo::Wrapper.new(__var1)
  end

  def self.app_info_get_all
    __var0 = LibGio.app_info_get_all
    GObject.raise_unexpected_null("g_app_info_get_all") if __var0.null?
    GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.app_info_get_all_for_type(content_type : ::String)
    __var0 = LibGio.app_info_get_all_for_type(content_type.to_unsafe)
    GObject.raise_unexpected_null("g_app_info_get_all_for_type") if __var0.null?
    GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.app_info_get_default_for_type(content_type : ::String, must_support_uris : ::Bool)
    __var0 = LibGio.app_info_get_default_for_type(content_type.to_unsafe, LibC::Int.new(must_support_uris ? 1 : 0))
    GObject.raise_unexpected_null("g_app_info_get_default_for_type") if __var0.null?
    Gio::AppInfo::Wrapper.new(__var0)
  end

  def self.app_info_get_default_for_uri_scheme(uri_scheme : ::String)
    __var0 = LibGio.app_info_get_default_for_uri_scheme(uri_scheme.to_unsafe)
    GObject.raise_unexpected_null("g_app_info_get_default_for_uri_scheme") if __var0.null?
    Gio::AppInfo::Wrapper.new(__var0)
  end

  def self.app_info_get_fallback_for_type(content_type : ::String)
    __var0 = LibGio.app_info_get_fallback_for_type(content_type.to_unsafe)
    GObject.raise_unexpected_null("g_app_info_get_fallback_for_type") if __var0.null?
    GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.app_info_get_recommended_for_type(content_type : ::String)
    __var0 = LibGio.app_info_get_recommended_for_type(content_type.to_unsafe)
    GObject.raise_unexpected_null("g_app_info_get_recommended_for_type") if __var0.null?
    GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.app_info_launch_default_for_uri(uri : ::String, context : Gio::AppLaunchContext?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.app_info_launch_default_for_uri(uri.to_unsafe, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    (__var1 == 1)
  end

  def self.app_info_launch_default_for_uri_async(uri : ::String, context : Gio::AppLaunchContext?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
    LibGio.app_info_launch_default_for_uri_async(uri.to_unsafe, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
    nil
  end

  def self.app_info_launch_default_for_uri_finish(result : Gio::AsyncResult)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.app_info_launch_default_for_uri_finish(result.to_unsafe_asyncresult, pointerof(__var0))
    GLib::Error.assert(__var0)
    (__var1 == 1)
  end

  def self.app_info_reset_type_associations(content_type : ::String)
    LibGio.app_info_reset_type_associations(content_type.to_unsafe)
    nil
  end

  def self.async_initable_newv_async(object_type : UInt64, parameters : GObject::Parameter, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
    __parameters = parameters.to_unsafe.as(LibGObject::Parameter*)
    n_parameters = __parameters_ary.size
    LibGio.async_initable_newv_async(UInt64.new(object_type), UInt32.new(n_parameters), __parameters, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
    nil
  end

  def self.bus_get(bus_type : Gio::BusType, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
    LibGio.bus_get(bus_type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
    nil
  end

  def self.bus_get_finish(res : Gio::AsyncResult)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.bus_get_finish(res.to_unsafe_asyncresult, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_bus_get_finish") if __var1.null?
    Gio::DBusConnection.new(__var1)
  end

  def self.bus_get_sync(bus_type : Gio::BusType, cancellable : Gio::Cancellable?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.bus_get_sync(bus_type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_bus_get_sync") if __var1.null?
    Gio::DBusConnection.new(__var1)
  end

  def self.bus_own_name_on_connection(connection : Gio::DBusConnection, name : ::String, flags : Gio::BusNameOwnerFlags, name_acquired_closure : GObject::Closure?, name_lost_closure : GObject::Closure?)
    __var0 = LibGio.bus_own_name_on_connection(connection.to_unsafe_dbusconnection, name.to_unsafe, flags, name_acquired_closure ? name_acquired_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, name_lost_closure ? name_lost_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null)
    __var0
  end

  def self.bus_own_name(bus_type : Gio::BusType, name : ::String, flags : Gio::BusNameOwnerFlags, bus_acquired_closure : GObject::Closure?, name_acquired_closure : GObject::Closure?, name_lost_closure : GObject::Closure?)
    __var0 = LibGio.bus_own_name(bus_type, name.to_unsafe, flags, bus_acquired_closure ? bus_acquired_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, name_acquired_closure ? name_acquired_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, name_lost_closure ? name_lost_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null)
    __var0
  end

  def self.bus_unown_name(owner_id : ::Int)
    LibGio.bus_unown_name(UInt32.new(owner_id))
    nil
  end

  def self.bus_unwatch_name(watcher_id : ::Int)
    LibGio.bus_unwatch_name(UInt32.new(watcher_id))
    nil
  end

  def self.bus_watch_name_on_connection(connection : Gio::DBusConnection, name : ::String, flags : Gio::BusNameWatcherFlags, name_appeared_closure : GObject::Closure?, name_vanished_closure : GObject::Closure?)
    __var0 = LibGio.bus_watch_name_on_connection(connection.to_unsafe_dbusconnection, name.to_unsafe, flags, name_appeared_closure ? name_appeared_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, name_vanished_closure ? name_vanished_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null)
    __var0
  end

  def self.bus_watch_name(bus_type : Gio::BusType, name : ::String, flags : Gio::BusNameWatcherFlags, name_appeared_closure : GObject::Closure?, name_vanished_closure : GObject::Closure?)
    __var0 = LibGio.bus_watch_name(bus_type, name.to_unsafe, flags, name_appeared_closure ? name_appeared_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, name_vanished_closure ? name_vanished_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null)
    __var0
  end

  def self.content_type_can_be_executable(type : ::String)
    __var0 = LibGio.content_type_can_be_executable(type.to_unsafe)
    (__var0 == 1)
  end

  def self.content_type_equals(type1 : ::String, type2 : ::String)
    __var0 = LibGio.content_type_equals(type1.to_unsafe, type2.to_unsafe)
    (__var0 == 1)
  end

  def self.content_type_from_mime_type(mime_type : ::String)
    __var0 = LibGio.content_type_from_mime_type(mime_type.to_unsafe)
    __var1 = ::String.new(__var0) if __var0
    __var1
  end

  def self.content_type_get_description(type : ::String)
    __var0 = LibGio.content_type_get_description(type.to_unsafe)
    GObject.raise_unexpected_null("g_content_type_get_description") if __var0.null?
    ::String.new(__var0)
  end

  def self.content_type_get_generic_icon_name(type : ::String)
    __var0 = LibGio.content_type_get_generic_icon_name(type.to_unsafe)
    __var1 = ::String.new(__var0) if __var0
    __var1
  end

  def self.content_type_get_icon(type : ::String)
    __var0 = LibGio.content_type_get_icon(type.to_unsafe)
    GObject.raise_unexpected_null("g_content_type_get_icon") if __var0.null?
    Gio::Icon::Wrapper.new(__var0)
  end

  def self.content_type_get_mime_dirs
    __var0 = LibGio.content_type_get_mime_dirs
    GObject.raise_unexpected_null("g_content_type_get_mime_dirs") if __var0.null?
    GObject::PointerIterator.new(__var0) { |__var1|
      ::String.new(__var1)
    }
  end

  def self.content_type_get_mime_type(type : ::String)
    __var0 = LibGio.content_type_get_mime_type(type.to_unsafe)
    __var1 = ::String.new(__var0) if __var0
    __var1
  end

  def self.content_type_get_symbolic_icon(type : ::String)
    __var0 = LibGio.content_type_get_symbolic_icon(type.to_unsafe)
    GObject.raise_unexpected_null("g_content_type_get_symbolic_icon") if __var0.null?
    Gio::Icon::Wrapper.new(__var0)
  end

  def self.content_type_guess(filename : ::String?, data : ::Bytes?)
    data_size = data ? data.size : 0
    __var0 = LibGio.content_type_guess(filename ? filename.to_unsafe : Pointer(UInt8).null, data ? data.to_unsafe : Pointer(UInt8).null, UInt64.new(data_size), out result_uncertain)
    GObject.raise_unexpected_null("g_content_type_guess") if __var0.null?
    {::String.new(__var0), (result_uncertain == 1)}
  end

  def self.content_type_guess_for_tree(root : Gio::File)
    __var0 = LibGio.content_type_guess_for_tree(root.to_unsafe_file)
    GObject.raise_unexpected_null("g_content_type_guess_for_tree") if __var0.null?
    GObject::PointerIterator.new(__var0) { |__var1|
      ::String.new(__var1)
    }
  end

  def self.content_type_is_a(type : ::String, supertype : ::String)
    __var0 = LibGio.content_type_is_a(type.to_unsafe, supertype.to_unsafe)
    (__var0 == 1)
  end

  def self.content_type_is_mime_type(type : ::String, mime_type : ::String)
    __var0 = LibGio.content_type_is_mime_type(type.to_unsafe, mime_type.to_unsafe)
    (__var0 == 1)
  end

  def self.content_type_is_unknown(type : ::String)
    __var0 = LibGio.content_type_is_unknown(type.to_unsafe)
    (__var0 == 1)
  end

  def self.content_type_set_mime_dirs(dirs : ::Enumerable?)
    LibGio.content_type_set_mime_dirs(dirs ? (__dirs_ary = dirs.map { |__item| __item.to_unsafe }.to_a).to_unsafe : Pointer(Pointer(UInt8)).null)
    nil
  end

  def self.content_types_get_registered
    __var0 = LibGio.content_types_get_registered
    GObject.raise_unexpected_null("g_content_types_get_registered") if __var0.null?
    GLib::ListIterator(::String, Pointer(UInt8)*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.dbus_address_escape_value(string : ::String)
    __var0 = LibGio.dbus_address_escape_value(string.to_unsafe)
    GObject.raise_unexpected_null("g_dbus_address_escape_value") if __var0.null?
    ::String.new(__var0)
  end

  def self.dbus_address_get_for_bus_sync(bus_type : Gio::BusType, cancellable : Gio::Cancellable?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dbus_address_get_for_bus_sync(bus_type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_dbus_address_get_for_bus_sync") if __var1.null?
    ::String.new(__var1)
  end

  def self.dbus_address_get_stream(address : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
    LibGio.dbus_address_get_stream(address.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
    nil
  end

  def self.dbus_address_get_stream_finish(res : Gio::AsyncResult)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dbus_address_get_stream_finish(res.to_unsafe_asyncresult, out out_guid, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_dbus_address_get_stream_finish") if __var1.null?
    {Gio::IOStream.new(__var1), ::String.new(out_guid)}
  end

  def self.dbus_address_get_stream_sync(address : ::String, cancellable : Gio::Cancellable?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dbus_address_get_stream_sync(address.to_unsafe, out out_guid, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_dbus_address_get_stream_sync") if __var1.null?
    {Gio::IOStream.new(__var1), ::String.new(out_guid)}
  end

  def self.dbus_annotation_info_lookup(annotations : ::Enumerable?, name : ::String)
    __var0 = LibGio.dbus_annotation_info_lookup(annotations ? (__annotations_ary = annotations.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe : Pointer(Pointer(LibGio::DBusAnnotationInfo)).null, name.to_unsafe)
    GObject.raise_unexpected_null("g_dbus_annotation_info_lookup") if __var0.null?
    ::String.new(__var0)
  end

  def self.dbus_error_encode_gerror(error : LibGLib::Error*)
    __var0 = LibGio.dbus_error_encode_gerror(error)
    GObject.raise_unexpected_null("g_dbus_error_encode_gerror") if __var0.null?
    ::String.new(__var0)
  end

  def self.dbus_error_get_remote_error(error : LibGLib::Error*)
    __var0 = LibGio.dbus_error_get_remote_error(error)
    GObject.raise_unexpected_null("g_dbus_error_get_remote_error") if __var0.null?
    ::String.new(__var0)
  end

  def self.dbus_error_is_remote_error(error : LibGLib::Error*)
    __var0 = LibGio.dbus_error_is_remote_error(error)
    (__var0 == 1)
  end

  def self.dbus_error_new_for_dbus_error(dbus_error_name : ::String, dbus_error_message : ::String)
    __var0 = LibGio.dbus_error_new_for_dbus_error(dbus_error_name.to_unsafe, dbus_error_message.to_unsafe)
    GObject.raise_unexpected_null("g_dbus_error_new_for_dbus_error") if __var0.null?
    __var0
  end

  def self.dbus_error_quark
    __var0 = LibGio.dbus_error_quark
    __var0
  end

  def self.dbus_error_register_error(error_domain : ::Int, error_code : ::Int, dbus_error_name : ::String)
    __var0 = LibGio.dbus_error_register_error(UInt32.new(error_domain), Int32.new(error_code), dbus_error_name.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_error_register_error_domain(error_domain_quark_name : ::String, quark_volatile : ::Int, entries : ::Enumerable)
    num_entries = entries.size
    LibGio.dbus_error_register_error_domain(error_domain_quark_name.to_unsafe, quark_volatile, (__entries_ary = entries.map { |__item| __item }.to_a).to_unsafe, UInt32.new(num_entries))
    nil
  end

  def self.dbus_error_strip_remote_error(error : LibGLib::Error*)
    __var0 = LibGio.dbus_error_strip_remote_error(error)
    (__var0 == 1)
  end

  def self.dbus_error_unregister_error(error_domain : ::Int, error_code : ::Int, dbus_error_name : ::String)
    __var0 = LibGio.dbus_error_unregister_error(UInt32.new(error_domain), Int32.new(error_code), dbus_error_name.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_generate_guid
    __var0 = LibGio.dbus_generate_guid
    GObject.raise_unexpected_null("g_dbus_generate_guid") if __var0.null?
    ::String.new(__var0)
  end

  def self.dbus_gvalue_to_gvariant(gvalue, type : GLib::VariantType)
    __var0 = LibGio.dbus_gvalue_to_gvariant(gvalue.to_gvalue.to_unsafe, type.to_unsafe.as(LibGLib::VariantType*))
    GObject.raise_unexpected_null("g_dbus_gvalue_to_gvariant") if __var0.null?
    GLib::Variant.new(__var0)
  end

  def self.dbus_gvariant_to_gvalue(value : GLib::Variant) : GObject::Value
    out_gvalue = GObject::Value.new
    LibGio.dbus_gvariant_to_gvalue(value.to_unsafe.as(LibGLib::Variant*), out_gvalue)
    out_gvalue
  end

  def self.dbus_is_address(string : ::String)
    __var0 = LibGio.dbus_is_address(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_is_guid(string : ::String)
    __var0 = LibGio.dbus_is_guid(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_is_interface_name(string : ::String)
    __var0 = LibGio.dbus_is_interface_name(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_is_member_name(string : ::String)
    __var0 = LibGio.dbus_is_member_name(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_is_name(string : ::String)
    __var0 = LibGio.dbus_is_name(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dbus_is_supported_address(string : ::String)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dbus_is_supported_address(string.to_unsafe, pointerof(__var0))
    GLib::Error.assert(__var0)
    (__var1 == 1)
  end

  def self.dbus_is_unique_name(string : ::String)
    __var0 = LibGio.dbus_is_unique_name(string.to_unsafe)
    (__var0 == 1)
  end

  def self.dtls_client_connection_new(base_socket : Gio::DatagramBased, server_identity : Gio::SocketConnectable?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dtls_client_connection_new(base_socket.to_unsafe_datagrambased, server_identity ? server_identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_dtls_client_connection_new") if __var1.null?
    Gio::DtlsClientConnection::Wrapper.new(__var1)
  end

  def self.dtls_server_connection_new(base_socket : Gio::DatagramBased, certificate : Gio::TlsCertificate?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.dtls_server_connection_new(base_socket.to_unsafe_datagrambased, certificate ? certificate.to_unsafe_tlscertificate : Pointer(LibGio::TlsCertificate).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_dtls_server_connection_new") if __var1.null?
    Gio::DtlsServerConnection::Wrapper.new(__var1)
  end

  def self.file_new_for_commandline_arg(arg : ::String)
    __var0 = LibGio.file_new_for_commandline_arg(arg.to_unsafe)
    GObject.raise_unexpected_null("g_file_new_for_commandline_arg") if __var0.null?
    Gio::File::Wrapper.new(__var0)
  end

  def self.file_new_for_commandline_arg_and_cwd(arg : ::String, cwd : ::String)
    __var0 = LibGio.file_new_for_commandline_arg_and_cwd(arg.to_unsafe, cwd.to_unsafe)
    GObject.raise_unexpected_null("g_file_new_for_commandline_arg_and_cwd") if __var0.null?
    Gio::File::Wrapper.new(__var0)
  end

  def self.file_new_for_path(path : ::String)
    __var0 = LibGio.file_new_for_path(path.to_unsafe)
    GObject.raise_unexpected_null("g_file_new_for_path") if __var0.null?
    Gio::File::Wrapper.new(__var0)
  end

  def self.file_new_for_uri(uri : ::String)
    __var0 = LibGio.file_new_for_uri(uri.to_unsafe)
    GObject.raise_unexpected_null("g_file_new_for_uri") if __var0.null?
    Gio::File::Wrapper.new(__var0)
  end

  def self.file_new_tmp(tmpl : ::String?, iostream : Gio::FileIOStream)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.file_new_tmp(tmpl ? tmpl.to_unsafe : Pointer(UInt8).null, iostream, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_file_new_tmp") if __var1.null?
    Gio::File::Wrapper.new(__var1)
  end

  def self.file_parse_name(parse_name : ::String)
    __var0 = LibGio.file_parse_name(parse_name.to_unsafe)
    GObject.raise_unexpected_null("g_file_parse_name") if __var0.null?
    Gio::File::Wrapper.new(__var0)
  end

  def self.icon_deserialize(value : GLib::Variant)
    __var0 = LibGio.icon_deserialize(value.to_unsafe.as(LibGLib::Variant*))
    GObject.raise_unexpected_null("g_icon_deserialize") if __var0.null?
    Gio::Icon::Wrapper.new(__var0)
  end

  def self.icon_hash(icon : Void*)
    __var0 = LibGio.icon_hash(icon)
    __var0
  end

  def self.icon_new_for_string(str : ::String)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.icon_new_for_string(str.to_unsafe, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_icon_new_for_string") if __var1.null?
    Gio::Icon::Wrapper.new(__var1)
  end

  def self.initable_newv(object_type : UInt64, parameters : ::Enumerable, cancellable : Gio::Cancellable?)
    n_parameters = parameters.size
    __parameters = (__parameters_ary = parameters.map { |__item| __item }.to_a).to_unsafe
    n_parameters = __parameters_ary.size
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.initable_newv(UInt64.new(object_type), UInt32.new(n_parameters), __parameters, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_initable_newv") if __var1.null?
    GObject::Object.new(__var1)
  end

  def self.io_error_from_errno(err_no : ::Int)
    __var0 = LibGio.io_error_from_errno(Int32.new(err_no))
    Gio::IOErrorEnum.new(__var0)
  end

  def self.io_error_quark
    __var0 = LibGio.io_error_quark
    __var0
  end

  def self.io_extension_point_implement(extension_point_name : ::String, type : UInt64, extension_name : ::String, priority : ::Int)
    __var0 = LibGio.io_extension_point_implement(extension_point_name.to_unsafe, UInt64.new(type), extension_name.to_unsafe, Int32.new(priority))
    GObject.raise_unexpected_null("g_io_extension_point_implement") if __var0.null?
    Gio::IOExtension.new(__var0)
  end

  def self.io_extension_point_lookup(name : ::String)
    __var0 = LibGio.io_extension_point_lookup(name.to_unsafe)
    GObject.raise_unexpected_null("g_io_extension_point_lookup") if __var0.null?
    Gio::IOExtensionPoint.new(__var0)
  end

  def self.io_extension_point_register(name : ::String)
    __var0 = LibGio.io_extension_point_register(name.to_unsafe)
    GObject.raise_unexpected_null("g_io_extension_point_register") if __var0.null?
    Gio::IOExtensionPoint.new(__var0)
  end

  def self.io_modules_load_all_in_directory(dirname : ::String)
    __var0 = LibGio.io_modules_load_all_in_directory(dirname.to_unsafe)
    GObject.raise_unexpected_null("g_io_modules_load_all_in_directory") if __var0.null?
    GLib::ListIterator(Gio::IOModule, LibGio::IOModule*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.io_modules_load_all_in_directory_with_scope(dirname : ::String, scope : Gio::IOModuleScope)
    __var0 = LibGio.io_modules_load_all_in_directory_with_scope(dirname.to_unsafe, scope.to_unsafe.as(LibGio::IOModuleScope*))
    GObject.raise_unexpected_null("g_io_modules_load_all_in_directory_with_scope") if __var0.null?
    GLib::ListIterator(Gio::IOModule, LibGio::IOModule*).new(GLib::List.new(__var0.as(LibGLib::List*)))
  end

  def self.io_modules_scan_all_in_directory(dirname : ::String)
    LibGio.io_modules_scan_all_in_directory(dirname.to_unsafe)
    nil
  end

  def self.io_modules_scan_all_in_directory_with_scope(dirname : ::String, scope : Gio::IOModuleScope)
    LibGio.io_modules_scan_all_in_directory_with_scope(dirname.to_unsafe, scope.to_unsafe.as(LibGio::IOModuleScope*))
    nil
  end

  def self.io_scheduler_cancel_all_jobs
    LibGio.io_scheduler_cancel_all_jobs
    nil
  end

  def self.io_scheduler_push_job(job_func : Gio::IOSchedulerJobFunc, user_data : Void*?, notify : GLib::DestroyNotify?, io_priority : ::Int, cancellable : Gio::Cancellable?)
    LibGio.io_scheduler_push_job(job_func, user_data ? user_data : Pointer(Void).null, notify ? notify : nil, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
    nil
  end

  def self.keyfile_settings_backend_new(filename : ::String, root_path : ::String, root_group : ::String?)
    __var0 = LibGio.keyfile_settings_backend_new(filename.to_unsafe, root_path.to_unsafe, root_group ? root_group.to_unsafe : Pointer(UInt8).null)
    GObject.raise_unexpected_null("g_keyfile_settings_backend_new") if __var0.null?
    Gio::SettingsBackend.new(__var0)
  end

  def self.memory_monitor_dup_default
    __var0 = LibGio.memory_monitor_dup_default
    GObject.raise_unexpected_null("g_memory_monitor_dup_default") if __var0.null?
    Gio::MemoryMonitor::Wrapper.new(__var0)
  end

  def self.memory_settings_backend_new
    __var0 = LibGio.memory_settings_backend_new
    GObject.raise_unexpected_null("g_memory_settings_backend_new") if __var0.null?
    Gio::SettingsBackend.new(__var0)
  end

  def self.network_monitor_get_default
    __var0 = LibGio.network_monitor_get_default
    GObject.raise_unexpected_null("g_network_monitor_get_default") if __var0.null?
    Gio::NetworkMonitor::Wrapper.new(__var0)
  end

  def self.networking_init
    LibGio.networking_init
    nil
  end

  def self.null_settings_backend_new
    __var0 = LibGio.null_settings_backend_new
    GObject.raise_unexpected_null("g_null_settings_backend_new") if __var0.null?
    Gio::SettingsBackend.new(__var0)
  end

  def self.pollable_source_new(pollable_stream : GObject::Object)
    __var0 = LibGio.pollable_source_new(pollable_stream.to_unsafe_object)
    GObject.raise_unexpected_null("g_pollable_source_new") if __var0.null?
    GLib::Source.new(__var0)
  end

  def self.pollable_source_new_full(pollable_stream : GObject::Object, child_source : GLib::Source?, cancellable : Gio::Cancellable?)
    __var0 = LibGio.pollable_source_new_full(pollable_stream.to_unsafe_object, child_source ? child_source.to_unsafe.as(LibGLib::Source*) : Pointer(LibGLib::Source).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
    GObject.raise_unexpected_null("g_pollable_source_new_full") if __var0.null?
    GLib::Source.new(__var0)
  end

  def self.pollable_stream_read(stream : Gio::InputStream, buffer : ::Bytes, blocking : ::Bool, cancellable : Gio::Cancellable?)
    count = buffer.size
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.pollable_stream_read(stream.to_unsafe_inputstream, buffer.to_unsafe, UInt64.new(count), LibC::Int.new(blocking ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    __var1
  end

  def self.pollable_stream_write(stream : Gio::OutputStream, buffer : ::Bytes, blocking : ::Bool, cancellable : Gio::Cancellable?)
    count = buffer.size
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.pollable_stream_write(stream.to_unsafe_outputstream, buffer.to_unsafe, UInt64.new(count), LibC::Int.new(blocking ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    __var1
  end

  def self.pollable_stream_write_all(stream : Gio::OutputStream, buffer : ::Bytes, blocking : ::Bool, cancellable : Gio::Cancellable?)
    count = buffer.size
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.pollable_stream_write_all(stream.to_unsafe_outputstream, buffer.to_unsafe, UInt64.new(count), LibC::Int.new(blocking ? 1 : 0), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    {(__var1 == 1), bytes_written}
  end

  def self.proxy_get_default_for_protocol(protocol : ::String)
    __var0 = LibGio.proxy_get_default_for_protocol(protocol.to_unsafe)
    GObject.raise_unexpected_null("g_proxy_get_default_for_protocol") if __var0.null?
    Gio::Proxy::Wrapper.new(__var0)
  end

  def self.proxy_resolver_get_default
    __var0 = LibGio.proxy_resolver_get_default
    GObject.raise_unexpected_null("g_proxy_resolver_get_default") if __var0.null?
    Gio::ProxyResolver::Wrapper.new(__var0)
  end

  def self.resolver_error_quark
    __var0 = LibGio.resolver_error_quark
    __var0
  end

  def self.resource_error_quark
    __var0 = LibGio.resource_error_quark
    __var0
  end

  def self.resource_load(filename : ::String)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.resource_load(filename.to_unsafe, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_resource_load") if __var1.null?
    Gio::Resource.new(__var1)
  end

  def self.resources_enumerate_children(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.resources_enumerate_children(path.to_unsafe, lookup_flags, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_resources_enumerate_children") if __var1.null?
    GObject::PointerIterator.new(__var1) { |__var2|
      ::String.new(__var2)
    }
  end

  def self.resources_get_info(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.resources_get_info(path.to_unsafe, lookup_flags, out size, out flags, pointerof(__var0))
    GLib::Error.assert(__var0)
    {(__var1 == 1), size, flags}
  end

  def self.resources_lookup_data(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.resources_lookup_data(path.to_unsafe, lookup_flags, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_resources_lookup_data") if __var1.null?
    GLib::Bytes.new(__var1)
  end

  def self.resources_open_stream(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.resources_open_stream(path.to_unsafe, lookup_flags, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_resources_open_stream") if __var1.null?
    Gio::InputStream.new(__var1)
  end

  def self.resources_register(resource : Gio::Resource)
    LibGio.resources_register(resource.to_unsafe.as(LibGio::Resource*))
    nil
  end

  def self.resources_unregister(resource : Gio::Resource)
    LibGio.resources_unregister(resource.to_unsafe.as(LibGio::Resource*))
    nil
  end

  def self.settings_schema_source_get_default
    __var0 = LibGio.settings_schema_source_get_default
    __var1 = Gio::SettingsSchemaSource.new(__var0) if __var0
    __var1
  end

  def self.simple_async_report_gerror_in_idle(object : GObject::Object?, callback : Gio::AsyncReadyCallback?, user_data : Void*?, error : LibGLib::Error*)
    LibGio.simple_async_report_gerror_in_idle(object ? object.to_unsafe_object : Pointer(LibGObject::Object).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null, error)
    nil
  end

  def self.tls_backend_get_default
    __var0 = LibGio.tls_backend_get_default
    GObject.raise_unexpected_null("g_tls_backend_get_default") if __var0.null?
    Gio::TlsBackend::Wrapper.new(__var0)
  end

  def self.tls_client_connection_new(base_io_stream : Gio::IOStream, server_identity : Gio::SocketConnectable?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.tls_client_connection_new(base_io_stream.to_unsafe_iostream, server_identity ? server_identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_tls_client_connection_new") if __var1.null?
    Gio::TlsClientConnection::Wrapper.new(__var1)
  end

  def self.tls_error_quark
    __var0 = LibGio.tls_error_quark
    __var0
  end

  def self.tls_file_database_new(anchors : ::String)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.tls_file_database_new(anchors.to_unsafe, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_tls_file_database_new") if __var1.null?
    Gio::TlsFileDatabase::Wrapper.new(__var1)
  end

  def self.tls_server_connection_new(base_io_stream : Gio::IOStream, certificate : Gio::TlsCertificate?)
    __var0 = Pointer(LibGLib::Error).null
    __var1 = LibGio.tls_server_connection_new(base_io_stream.to_unsafe_iostream, certificate ? certificate.to_unsafe_tlscertificate : Pointer(LibGio::TlsCertificate).null, pointerof(__var0))
    GLib::Error.assert(__var0)
    GObject.raise_unexpected_null("g_tls_server_connection_new") if __var1.null?
    Gio::TlsServerConnection::Wrapper.new(__var1)
  end

  def self.unix_is_mount_path_system_internal(mount_path : ::String)
    __var0 = LibGio.unix_is_mount_path_system_internal(mount_path.to_unsafe)
    (__var0 == 1)
  end

  def self.unix_is_system_device_path(device_path : ::String)
    __var0 = LibGio.unix_is_system_device_path(device_path.to_unsafe)
    (__var0 == 1)
  end

  def self.unix_is_system_fs_type(fs_type : ::String)
    __var0 = LibGio.unix_is_system_fs_type(fs_type.to_unsafe)
    (__var0 == 1)
  end

  def self.unix_mount_at(mount_path : ::String)
    __var0 = LibGio.unix_mount_at(mount_path.to_unsafe, out time_read)
    GObject.raise_unexpected_null("g_unix_mount_at") if __var0.null?
    {Gio::UnixMountEntry.new(__var0), time_read}
  end

  def self.unix_mount_compare(mount1 : Gio::UnixMountEntry, mount2 : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_compare(mount1.to_unsafe.as(LibGio::UnixMountEntry*), mount2.to_unsafe.as(LibGio::UnixMountEntry*))
    __var0
  end

  def self.unix_mount_copy(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_copy(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_copy") if __var0.null?
    Gio::UnixMountEntry.new(__var0)
  end

  def self.unix_mount_for(file_path : ::String)
    __var0 = LibGio.unix_mount_for(file_path.to_unsafe, out time_read)
    GObject.raise_unexpected_null("g_unix_mount_for") if __var0.null?
    {Gio::UnixMountEntry.new(__var0), time_read}
  end

  def self.unix_mount_free(mount_entry : Gio::UnixMountEntry)
    LibGio.unix_mount_free(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    nil
  end

  def self.unix_mount_get_device_path(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_get_device_path(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_get_device_path") if __var0.null?
    ::String.new(__var0)
  end

  def self.unix_mount_get_fs_type(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_get_fs_type(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_get_fs_type") if __var0.null?
    ::String.new(__var0)
  end

  def self.unix_mount_get_mount_path(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_get_mount_path(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_get_mount_path") if __var0.null?
    ::String.new(__var0)
  end

  def self.unix_mount_get_options(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_get_options(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    __var1 = ::String.new(__var0) if __var0
    __var1
  end

  def self.unix_mount_get_root_path(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_get_root_path(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    __var1 = ::String.new(__var0) if __var0
    __var1
  end

  def self.unix_mount_guess_can_eject(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_guess_can_eject(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    (__var0 == 1)
  end

  def self.unix_mount_guess_icon(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_guess_icon(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_guess_icon") if __var0.null?
    Gio::Icon::Wrapper.new(__var0)
  end

  def self.unix_mount_guess_name(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_guess_name(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_guess_name") if __var0.null?
    ::String.new(__var0)
  end

  def self.unix_mount_guess_should_display(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_guess_should_display(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    (__var0 == 1)
  end

  def self.unix_mount_guess_symbolic_icon(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_guess_symbolic_icon(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    GObject.raise_unexpected_null("g_unix_mount_guess_symbolic_icon") if __var0.null?
    Gio::Icon::Wrapper.new(__var0)
  end

  def self.unix_mount_is_readonly(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_is_readonly(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    (__var0 == 1)
  end

  def self.unix_mount_is_system_internal(mount_entry : Gio::UnixMountEntry)
    __var0 = LibGio.unix_mount_is_system_internal(mount_entry.to_unsafe.as(LibGio::UnixMountEntry*))
    (__var0 == 1)
  end

  def self.unix_mount_points_changed_since(time : ::Int)
    __var0 = LibGio.unix_mount_points_changed_since(UInt64.new(time))
    (__var0 == 1)
  end

  def self.unix_mount_points_get
    __var0 = LibGio.unix_mount_points_get(out time_read)
    GObject.raise_unexpected_null("g_unix_mount_points_get") if __var0.null?
    {GLib::ListIterator(Gio::UnixMountPoint, LibGio::UnixMountPoint*).new(GLib::List.new(__var0.as(LibGLib::List*))), time_read}
  end

  def self.unix_mounts_changed_since(time : ::Int)
    __var0 = LibGio.unix_mounts_changed_since(UInt64.new(time))
    (__var0 == 1)
  end

  def self.unix_mounts_get
    __var0 = LibGio.unix_mounts_get(out time_read)
    GObject.raise_unexpected_null("g_unix_mounts_get") if __var0.null?
    {GLib::ListIterator(Gio::UnixMountEntry, LibGio::UnixMountEntry*).new(GLib::List.new(__var0.as(LibGLib::List*))), time_read}
  end

  module Action
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Action
      @pointer : Void*

      def initialize(pointer : LibGio::Action*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GAction")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_action_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Action*)
      end

      def to_unsafe_action
        @pointer.not_nil!.as(LibGio::Action*)
      end
    end

    def to_unsafe_action
      @pointer.not_nil!.as(LibGio::Action*)
    end

    def self.name_is_valid(action_name : ::String)
      __var0 = LibGio.action_name_is_valid(action_name.to_unsafe)
      (__var0 == 1)
    end

    def self.parse_detailed_name(detailed_name : ::String, target_value : GLib::Variant)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.action_parse_detailed_name(detailed_name.to_unsafe, out action_name, target_value, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), ::String.new(action_name)}
    end

    def self.print_detailed_name(action_name : ::String, target_value : GLib::Variant?)
      __var0 = LibGio.action_print_detailed_name(action_name.to_unsafe, target_value ? target_value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      GObject.raise_unexpected_null("g_action_print_detailed_name") if __var0.null?
      ::String.new(__var0)
    end

    def activate(parameter : GLib::Variant?)
      LibGio.action_activate(@pointer.as(LibGio::Action*), parameter ? parameter.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def change_state(value : GLib::Variant)
      LibGio.action_change_state(@pointer.as(LibGio::Action*), value.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def enabled
      __var0 = LibGio.action_get_enabled(@pointer.as(LibGio::Action*))
      (__var0 == 1)
    end

    def name
      __var0 = LibGio.action_get_name(@pointer.as(LibGio::Action*))
      GObject.raise_unexpected_null("g_action_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def parameter_type
      __var0 = LibGio.action_get_parameter_type(@pointer.as(LibGio::Action*))
      __var1 = GLib::VariantType.new(__var0) if __var0
      __var1
    end

    def state
      __var0 = LibGio.action_get_state(@pointer.as(LibGio::Action*))
      GObject.raise_unexpected_null("g_action_get_state") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def state_hint
      __var0 = LibGio.action_get_state_hint(@pointer.as(LibGio::Action*))
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def state_type
      __var0 = LibGio.action_get_state_type(@pointer.as(LibGio::Action*))
      __var1 = GLib::VariantType.new(__var0) if __var0
      __var1
    end
  end

  class ActionEntry
    include GObject::WrappedType

    def self.new(name : ::String? = nil, parameter_type : ::String? = nil, state : ::String? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(64u64, 0u8).as(LibGio::ActionEntry*))
      __var0.name = name unless name.nil?
      __var0.parameter_type = parameter_type unless parameter_type.nil?
      __var0.state = state unless state.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ActionEntry*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ActionEntry*)
    end

    def to_unsafe_actionentry
      @pointer.not_nil!.as(LibGio::ActionEntry*)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::ActionEntry*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::ActionEntry*).value.name = value.to_unsafe
    end

    def activate
      to_unsafe.as(LibGio::ActionEntry*).value.activate
    end

    def parameter_type
      ::String.new(to_unsafe.as(LibGio::ActionEntry*).value.parameter_type)
    end

    def parameter_type=(value : ::String)
      to_unsafe.as(LibGio::ActionEntry*).value.parameter_type = value.to_unsafe
    end

    def state
      ::String.new(to_unsafe.as(LibGio::ActionEntry*).value.state)
    end

    def state=(value : ::String)
      to_unsafe.as(LibGio::ActionEntry*).value.state = value.to_unsafe
    end

    def change_state
      to_unsafe.as(LibGio::ActionEntry*).value.change_state
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::ActionEntry*).value.padding) { |__var0|
        __var0
      }
    end
  end

  module ActionGroup
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include ActionGroup
      @pointer : Void*

      def initialize(pointer : LibGio::ActionGroup*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GActionGroup")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_action_group_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::ActionGroup*)
      end

      def to_unsafe_actiongroup
        @pointer.not_nil!.as(LibGio::ActionGroup*)
      end
    end

    def to_unsafe_actiongroup
      @pointer.not_nil!.as(LibGio::ActionGroup*)
    end

    def action_added(action_name : ::String)
      LibGio.action_group_action_added(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      nil
    end

    def action_enabled_changed(action_name : ::String, enabled : ::Bool)
      LibGio.action_group_action_enabled_changed(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe, LibC::Int.new(enabled ? 1 : 0))
      nil
    end

    def action_removed(action_name : ::String)
      LibGio.action_group_action_removed(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      nil
    end

    def action_state_changed(action_name : ::String, state : GLib::Variant)
      LibGio.action_group_action_state_changed(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe, state.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def activate_action(action_name : ::String, parameter : GLib::Variant?)
      LibGio.action_group_activate_action(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe, parameter ? parameter.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def change_action_state(action_name : ::String, value : GLib::Variant)
      LibGio.action_group_change_action_state(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe, value.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def action_enabled(action_name : ::String)
      __var0 = LibGio.action_group_get_action_enabled(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      (__var0 == 1)
    end

    def action_parameter_type(action_name : ::String)
      __var0 = LibGio.action_group_get_action_parameter_type(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      __var1 = GLib::VariantType.new(__var0) if __var0
      __var1
    end

    def action_state(action_name : ::String)
      __var0 = LibGio.action_group_get_action_state(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def action_state_hint(action_name : ::String)
      __var0 = LibGio.action_group_get_action_state_hint(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def action_state_type(action_name : ::String)
      __var0 = LibGio.action_group_get_action_state_type(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      __var1 = GLib::VariantType.new(__var0) if __var0
      __var1
    end

    def has_action(action_name : ::String)
      __var0 = LibGio.action_group_has_action(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe)
      (__var0 == 1)
    end

    def list_actions
      __var0 = LibGio.action_group_list_actions(@pointer.as(LibGio::ActionGroup*))
      GObject.raise_unexpected_null("g_action_group_list_actions") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def query_action(action_name : ::String, parameter_type : GLib::VariantType?, state_type : GLib::VariantType?, state_hint : GLib::Variant?, state : GLib::Variant?)
      __var0 = LibGio.action_group_query_action(@pointer.as(LibGio::ActionGroup*), action_name.to_unsafe, out enabled, parameter_type, state_type, state_hint, state)
      {(__var0 == 1), (enabled == 1)}
    end

    alias ActionAddedSignal = ActionGroup, ::String -> Nil

    def on_action_added(*, after = false, &block : ActionAddedSignal)
      __var0 = ->(arg0 : LibGio::ActionGroup*, arg1 : Pointer(UInt8), box : Void*) {
        ::Box(ActionAddedSignal).unbox(box).call(ActionGroup::Wrapper.new(arg0), ::String.new(arg1))
      }

      __var1 = ::Box.box(ActionAddedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "action-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_action_added(&block : ActionAddedSignal)
      on_action_added(after: true, &block)
    end

    alias ActionEnabledChangedSignal = ActionGroup, ::String, ::Bool -> Nil

    def on_action_enabled_changed(*, after = false, &block : ActionEnabledChangedSignal)
      __var0 = ->(arg0 : LibGio::ActionGroup*, arg1 : Pointer(UInt8), arg2 : LibC::Int, box : Void*) {
        ::Box(ActionEnabledChangedSignal).unbox(box).call(ActionGroup::Wrapper.new(arg0), ::String.new(arg1), (arg2 == 1))
      }

      __var1 = ::Box.box(ActionEnabledChangedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "action-enabled-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_action_enabled_changed(&block : ActionEnabledChangedSignal)
      on_action_enabled_changed(after: true, &block)
    end

    alias ActionRemovedSignal = ActionGroup, ::String -> Nil

    def on_action_removed(*, after = false, &block : ActionRemovedSignal)
      __var0 = ->(arg0 : LibGio::ActionGroup*, arg1 : Pointer(UInt8), box : Void*) {
        ::Box(ActionRemovedSignal).unbox(box).call(ActionGroup::Wrapper.new(arg0), ::String.new(arg1))
      }

      __var1 = ::Box.box(ActionRemovedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "action-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_action_removed(&block : ActionRemovedSignal)
      on_action_removed(after: true, &block)
    end

    alias ActionStateChangedSignal = ActionGroup, ::String, GLib::Variant -> Nil

    def on_action_state_changed(*, after = false, &block : ActionStateChangedSignal)
      __var0 = ->(arg0 : LibGio::ActionGroup*, arg1 : Pointer(UInt8), arg2 : LibGLib::Variant*, box : Void*) {
        ::Box(ActionStateChangedSignal).unbox(box).call(ActionGroup::Wrapper.new(arg0), ::String.new(arg1), arg2.null? ? GObject.raise_unexpected_null("value in action_state_changed") : GLib::Variant.new(arg2))
      }

      __var1 = ::Box.box(ActionStateChangedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "action-state-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_action_state_changed(&block : ActionStateChangedSignal)
      on_action_state_changed(after: true, &block)
    end
  end

  class ActionGroupInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(128u64, 0u8).as(LibGio::ActionGroupInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ActionGroupInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ActionGroupInterface*)
    end

    def to_unsafe_actiongroupinterface
      @pointer.not_nil!.as(LibGio::ActionGroupInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ActionGroupInterface*).value.g_iface)
    end

    def has_action
      to_unsafe.as(LibGio::ActionGroupInterface*).value.has_action
    end

    def list_actions
      to_unsafe.as(LibGio::ActionGroupInterface*).value.list_actions
    end

    def get_action_enabled
      to_unsafe.as(LibGio::ActionGroupInterface*).value.get_action_enabled
    end

    def get_action_parameter_type
      to_unsafe.as(LibGio::ActionGroupInterface*).value.get_action_parameter_type
    end

    def get_action_state_type
      to_unsafe.as(LibGio::ActionGroupInterface*).value.get_action_state_type
    end

    def get_action_state_hint
      to_unsafe.as(LibGio::ActionGroupInterface*).value.get_action_state_hint
    end

    def get_action_state
      to_unsafe.as(LibGio::ActionGroupInterface*).value.get_action_state
    end

    def change_action_state
      to_unsafe.as(LibGio::ActionGroupInterface*).value.change_action_state
    end

    def activate_action
      to_unsafe.as(LibGio::ActionGroupInterface*).value.activate_action
    end

    def action_added
      to_unsafe.as(LibGio::ActionGroupInterface*).value.action_added
    end

    def action_removed
      to_unsafe.as(LibGio::ActionGroupInterface*).value.action_removed
    end

    def action_enabled_changed
      to_unsafe.as(LibGio::ActionGroupInterface*).value.action_enabled_changed
    end

    def action_state_changed
      to_unsafe.as(LibGio::ActionGroupInterface*).value.action_state_changed
    end

    def query_action
      to_unsafe.as(LibGio::ActionGroupInterface*).value.query_action
    end
  end

  class ActionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(80u64, 0u8).as(LibGio::ActionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ActionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ActionInterface*)
    end

    def to_unsafe_actioninterface
      @pointer.not_nil!.as(LibGio::ActionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ActionInterface*).value.g_iface)
    end

    def get_name
      to_unsafe.as(LibGio::ActionInterface*).value.get_name
    end

    def get_parameter_type
      to_unsafe.as(LibGio::ActionInterface*).value.get_parameter_type
    end

    def get_state_type
      to_unsafe.as(LibGio::ActionInterface*).value.get_state_type
    end

    def get_state_hint
      to_unsafe.as(LibGio::ActionInterface*).value.get_state_hint
    end

    def get_enabled
      to_unsafe.as(LibGio::ActionInterface*).value.get_enabled
    end

    def get_state
      to_unsafe.as(LibGio::ActionInterface*).value.get_state
    end

    def change_state
      to_unsafe.as(LibGio::ActionInterface*).value.change_state
    end

    def activate
      to_unsafe.as(LibGio::ActionInterface*).value.activate
    end
  end

  module ActionMap
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include ActionMap
      @pointer : Void*

      def initialize(pointer : LibGio::ActionMap*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GActionMap")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_action_map_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::ActionMap*)
      end

      def to_unsafe_actionmap
        @pointer.not_nil!.as(LibGio::ActionMap*)
      end
    end

    def to_unsafe_actionmap
      @pointer.not_nil!.as(LibGio::ActionMap*)
    end

    def add_action(action : Gio::Action)
      LibGio.action_map_add_action(@pointer.as(LibGio::ActionMap*), action.to_unsafe_action)
      nil
    end

    def add_action_entries(entries : ::Enumerable, user_data : Void*?)
      n_entries = entries.size
      __entries = (__entries_ary = entries.map { |__item| __item }.to_a).to_unsafe
      n_entries = __entries_ary.size
      LibGio.action_map_add_action_entries(@pointer.as(LibGio::ActionMap*), __entries, Int32.new(n_entries), user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_action(action_name : ::String)
      __var0 = LibGio.action_map_lookup_action(@pointer.as(LibGio::ActionMap*), action_name.to_unsafe)
      GObject.raise_unexpected_null("g_action_map_lookup_action") if __var0.null?
      Gio::Action::Wrapper.new(__var0)
    end

    def remove_action(action_name : ::String)
      LibGio.action_map_remove_action(@pointer.as(LibGio::ActionMap*), action_name.to_unsafe)
      nil
    end
  end

  class ActionMapInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::ActionMapInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ActionMapInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ActionMapInterface*)
    end

    def to_unsafe_actionmapinterface
      @pointer.not_nil!.as(LibGio::ActionMapInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ActionMapInterface*).value.g_iface)
    end

    def lookup_action
      to_unsafe.as(LibGio::ActionMapInterface*).value.lookup_action
    end

    def add_action
      to_unsafe.as(LibGio::ActionMapInterface*).value.add_action
    end

    def remove_action
      to_unsafe.as(LibGio::ActionMapInterface*).value.remove_action
    end
  end

  module AppInfo
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include AppInfo
      @pointer : Void*

      def initialize(pointer : LibGio::AppInfo*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GAppInfo")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_app_info_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::AppInfo*)
      end

      def to_unsafe_appinfo
        @pointer.not_nil!.as(LibGio::AppInfo*)
      end
    end

    def to_unsafe_appinfo
      @pointer.not_nil!.as(LibGio::AppInfo*)
    end

    def self.create_from_commandline(commandline : ::String, application_name : ::String?, flags : Gio::AppInfoCreateFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_create_from_commandline(commandline.to_unsafe, application_name ? application_name.to_unsafe : Pointer(UInt8).null, flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_app_info_create_from_commandline") if __var1.null?
      Gio::AppInfo::Wrapper.new(__var1)
    end

    def self.all
      __var0 = LibGio.app_info_get_all
      GObject.raise_unexpected_null("g_app_info_get_all") if __var0.null?
      GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def self.all_for_type(content_type : ::String)
      __var0 = LibGio.app_info_get_all_for_type(content_type.to_unsafe)
      GObject.raise_unexpected_null("g_app_info_get_all_for_type") if __var0.null?
      GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def self.default_for_type(content_type : ::String, must_support_uris : ::Bool)
      __var0 = LibGio.app_info_get_default_for_type(content_type.to_unsafe, LibC::Int.new(must_support_uris ? 1 : 0))
      GObject.raise_unexpected_null("g_app_info_get_default_for_type") if __var0.null?
      Gio::AppInfo::Wrapper.new(__var0)
    end

    def self.default_for_uri_scheme(uri_scheme : ::String)
      __var0 = LibGio.app_info_get_default_for_uri_scheme(uri_scheme.to_unsafe)
      GObject.raise_unexpected_null("g_app_info_get_default_for_uri_scheme") if __var0.null?
      Gio::AppInfo::Wrapper.new(__var0)
    end

    def self.fallback_for_type(content_type : ::String)
      __var0 = LibGio.app_info_get_fallback_for_type(content_type.to_unsafe)
      GObject.raise_unexpected_null("g_app_info_get_fallback_for_type") if __var0.null?
      GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def self.recommended_for_type(content_type : ::String)
      __var0 = LibGio.app_info_get_recommended_for_type(content_type.to_unsafe)
      GObject.raise_unexpected_null("g_app_info_get_recommended_for_type") if __var0.null?
      GLib::ListIterator(Gio::AppInfo, LibGio::AppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def self.launch_default_for_uri(uri : ::String, context : Gio::AppLaunchContext?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_launch_default_for_uri(uri.to_unsafe, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def self.launch_default_for_uri_async(uri : ::String, context : Gio::AppLaunchContext?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.app_info_launch_default_for_uri_async(uri.to_unsafe, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def self.launch_default_for_uri_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_launch_default_for_uri_finish(result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def self.reset_type_associations(content_type : ::String)
      LibGio.app_info_reset_type_associations(content_type.to_unsafe)
      nil
    end

    def add_supports_type(content_type : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_add_supports_type(@pointer.as(LibGio::AppInfo*), content_type.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def can_delete
      __var0 = LibGio.app_info_can_delete(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end

    def can_remove_supports_type
      __var0 = LibGio.app_info_can_remove_supports_type(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end

    def delete
      __var0 = LibGio.app_info_delete(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end

    def dup
      __var0 = LibGio.app_info_dup(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_dup") if __var0.null?
      Gio::AppInfo::Wrapper.new(__var0)
    end

    def equal(appinfo2 : Gio::AppInfo)
      __var0 = LibGio.app_info_equal(@pointer.as(LibGio::AppInfo*), appinfo2.to_unsafe_appinfo)
      (__var0 == 1)
    end

    def commandline
      __var0 = LibGio.app_info_get_commandline(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_commandline") if __var0.null?
      ::String.new(__var0)
    end

    def description
      __var0 = LibGio.app_info_get_description(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_description") if __var0.null?
      ::String.new(__var0)
    end

    def display_name
      __var0 = LibGio.app_info_get_display_name(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_display_name") if __var0.null?
      ::String.new(__var0)
    end

    def executable
      __var0 = LibGio.app_info_get_executable(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_executable") if __var0.null?
      ::String.new(__var0)
    end

    def icon
      __var0 = LibGio.app_info_get_icon(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def id
      __var0 = LibGio.app_info_get_id(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_id") if __var0.null?
      ::String.new(__var0)
    end

    def name
      __var0 = LibGio.app_info_get_name(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def supported_types
      __var0 = LibGio.app_info_get_supported_types(@pointer.as(LibGio::AppInfo*))
      GObject.raise_unexpected_null("g_app_info_get_supported_types") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def launch(files : Void*?, context : Gio::AppLaunchContext?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_launch(@pointer.as(LibGio::AppInfo*), files ? files : Pointer(Void*).null, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def launch_uris(uris : Void*?, context : Gio::AppLaunchContext?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_launch_uris(@pointer.as(LibGio::AppInfo*), uris ? uris : Pointer(Void*).null, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def launch_uris_async(uris : Void*?, context : Gio::AppLaunchContext?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.app_info_launch_uris_async(@pointer.as(LibGio::AppInfo*), uris ? uris : Pointer(Void*).null, context ? context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def launch_uris_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_launch_uris_finish(@pointer.as(LibGio::AppInfo*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def remove_supports_type(content_type : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_remove_supports_type(@pointer.as(LibGio::AppInfo*), content_type.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_as_default_for_extension(extension : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_set_as_default_for_extension(@pointer.as(LibGio::AppInfo*), extension.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_as_default_for_type(content_type : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_set_as_default_for_type(@pointer.as(LibGio::AppInfo*), content_type.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_as_last_used_for_type(content_type : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.app_info_set_as_last_used_for_type(@pointer.as(LibGio::AppInfo*), content_type.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def should_show
      __var0 = LibGio.app_info_should_show(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end

    def supports_files
      __var0 = LibGio.app_info_supports_files(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end

    def supports_uris
      __var0 = LibGio.app_info_supports_uris(@pointer.as(LibGio::AppInfo*))
      (__var0 == 1)
    end
  end

  @[Flags]
  enum AppInfoCreateFlags : UInt32
    NONE                          = 0
    NEEDS_TERMINAL                = 1
    SUPPORTS_URIS                 = 2
    SUPPORTS_STARTUP_NOTIFICATION = 4
  end

  class AppInfoIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(216u64, 0u8).as(LibGio::AppInfoIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::AppInfoIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AppInfoIface*)
    end

    def to_unsafe_appinfoiface
      @pointer.not_nil!.as(LibGio::AppInfoIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::AppInfoIface*).value.g_iface)
    end

    def dup
      to_unsafe.as(LibGio::AppInfoIface*).value.dup
    end

    def equal
      to_unsafe.as(LibGio::AppInfoIface*).value.equal
    end

    def get_id
      to_unsafe.as(LibGio::AppInfoIface*).value.get_id
    end

    def get_name
      to_unsafe.as(LibGio::AppInfoIface*).value.get_name
    end

    def get_description
      to_unsafe.as(LibGio::AppInfoIface*).value.get_description
    end

    def get_executable
      to_unsafe.as(LibGio::AppInfoIface*).value.get_executable
    end

    def get_icon
      to_unsafe.as(LibGio::AppInfoIface*).value.get_icon
    end

    def launch
      to_unsafe.as(LibGio::AppInfoIface*).value.launch
    end

    def supports_uris
      to_unsafe.as(LibGio::AppInfoIface*).value.supports_uris
    end

    def supports_files
      to_unsafe.as(LibGio::AppInfoIface*).value.supports_files
    end

    def launch_uris
      to_unsafe.as(LibGio::AppInfoIface*).value.launch_uris
    end

    def should_show
      to_unsafe.as(LibGio::AppInfoIface*).value.should_show
    end

    def set_as_default_for_type
      to_unsafe.as(LibGio::AppInfoIface*).value.set_as_default_for_type
    end

    def set_as_default_for_extension
      to_unsafe.as(LibGio::AppInfoIface*).value.set_as_default_for_extension
    end

    def add_supports_type
      to_unsafe.as(LibGio::AppInfoIface*).value.add_supports_type
    end

    def can_remove_supports_type
      to_unsafe.as(LibGio::AppInfoIface*).value.can_remove_supports_type
    end

    def remove_supports_type
      to_unsafe.as(LibGio::AppInfoIface*).value.remove_supports_type
    end

    def can_delete
      to_unsafe.as(LibGio::AppInfoIface*).value.can_delete
    end

    def do_delete
      to_unsafe.as(LibGio::AppInfoIface*).value.do_delete
    end

    def get_commandline
      to_unsafe.as(LibGio::AppInfoIface*).value.get_commandline
    end

    def get_display_name
      to_unsafe.as(LibGio::AppInfoIface*).value.get_display_name
    end

    def set_as_last_used_for_type
      to_unsafe.as(LibGio::AppInfoIface*).value.set_as_last_used_for_type
    end

    def get_supported_types
      to_unsafe.as(LibGio::AppInfoIface*).value.get_supported_types
    end

    def launch_uris_async
      to_unsafe.as(LibGio::AppInfoIface*).value.launch_uris_async
    end

    def launch_uris_finish
      to_unsafe.as(LibGio::AppInfoIface*).value.launch_uris_finish
    end
  end

  class AppInfoMonitor < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::AppInfoMonitor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GAppInfoMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_app_info_monitor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AppInfoMonitor*)
    end

    def to_unsafe_appinfomonitor
      @pointer.not_nil!.as(LibGio::AppInfoMonitor*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_app_info_monitor_get_type, 0, nil, nil).as(Void*)
    end

    def self.get
      __var0 = LibGio.app_info_monitor_get
      GObject.raise_unexpected_null("g_app_info_monitor_get") if __var0.null?
      Gio::AppInfoMonitor.new(__var0)
    end

    alias ChangedSignal = AppInfoMonitor -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::AppInfoMonitor*, box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(AppInfoMonitor.new(arg0))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end
  end

  class AppLaunchContext < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::AppLaunchContext*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GAppLaunchContext")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_app_launch_context_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AppLaunchContext*)
    end

    def to_unsafe_applaunchcontext
      @pointer.not_nil!.as(LibGio::AppLaunchContext*)
    end

    def self.new : self
      __var0 = LibGio.app_launch_context_new
      GObject.raise_unexpected_null("g_app_launch_context_new") if __var0.null?
      cast(Gio::AppLaunchContext.new(__var0))
    end

    def display(info : Gio::AppInfo, files : Void*)
      __var0 = LibGio.app_launch_context_get_display(@pointer.as(LibGio::AppLaunchContext*), info.to_unsafe_appinfo, files)
      GObject.raise_unexpected_null("g_app_launch_context_get_display") if __var0.null?
      ::String.new(__var0)
    end

    def environment
      __var0 = LibGio.app_launch_context_get_environment(@pointer.as(LibGio::AppLaunchContext*))
      GObject.raise_unexpected_null("g_app_launch_context_get_environment") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def startup_notify_id(info : Gio::AppInfo, files : Void*)
      __var0 = LibGio.app_launch_context_get_startup_notify_id(@pointer.as(LibGio::AppLaunchContext*), info.to_unsafe_appinfo, files)
      GObject.raise_unexpected_null("g_app_launch_context_get_startup_notify_id") if __var0.null?
      ::String.new(__var0)
    end

    def launch_failed(startup_notify_id : ::String)
      LibGio.app_launch_context_launch_failed(@pointer.as(LibGio::AppLaunchContext*), startup_notify_id.to_unsafe)
      nil
    end

    def setenv(variable : ::String, value : ::String)
      LibGio.app_launch_context_setenv(@pointer.as(LibGio::AppLaunchContext*), variable.to_unsafe, value.to_unsafe)
      nil
    end

    def unsetenv(variable : ::String)
      LibGio.app_launch_context_unsetenv(@pointer.as(LibGio::AppLaunchContext*), variable.to_unsafe)
      nil
    end

    alias LaunchFailedSignal = AppLaunchContext, ::String -> Nil

    def on_launch_failed(*, after = false, &block : LaunchFailedSignal)
      __var0 = ->(arg0 : LibGio::AppLaunchContext*, arg1 : Pointer(UInt8), box : Void*) {
        ::Box(LaunchFailedSignal).unbox(box).call(AppLaunchContext.new(arg0), ::String.new(arg1))
      }

      __var1 = ::Box.box(LaunchFailedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "launch-failed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_launch_failed(&block : LaunchFailedSignal)
      on_launch_failed(after: true, &block)
    end

    alias LaunchedSignal = AppLaunchContext, Gio::AppInfo, GLib::Variant -> Nil

    def on_launched(*, after = false, &block : LaunchedSignal)
      __var0 = ->(arg0 : LibGio::AppLaunchContext*, arg1 : LibGio::AppInfo*, arg2 : LibGLib::Variant*, box : Void*) {
        ::Box(LaunchedSignal).unbox(box).call(AppLaunchContext.new(arg0), arg1.null? ? GObject.raise_unexpected_null("info in launched") : Gio::AppInfo::Wrapper.new(arg1), arg2.null? ? GObject.raise_unexpected_null("platform_data in launched") : GLib::Variant.new(arg2))
      }

      __var1 = ::Box.box(LaunchedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "launched", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_launched(&block : LaunchedSignal)
      on_launched(after: true, &block)
    end
  end

  class AppLaunchContextClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(200u64, 0u8).as(LibGio::AppLaunchContextClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::AppLaunchContextClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AppLaunchContextClass*)
    end

    def to_unsafe_applaunchcontextclass
      @pointer.not_nil!.as(LibGio::AppLaunchContextClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::AppLaunchContextClass*).value.parent_class)
    end

    def get_display
      to_unsafe.as(LibGio::AppLaunchContextClass*).value.get_display
    end

    def get_startup_notify_id
      to_unsafe.as(LibGio::AppLaunchContextClass*).value.get_startup_notify_id
    end

    def launch_failed
      to_unsafe.as(LibGio::AppLaunchContextClass*).value.launch_failed
    end

    def launched
      to_unsafe.as(LibGio::AppLaunchContextClass*).value.launched
    end

    def _g_reserved1
      to_unsafe.as(LibGio::AppLaunchContextClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::AppLaunchContextClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::AppLaunchContextClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::AppLaunchContextClass*).value._g_reserved4
    end
  end

  class AppLaunchContextPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::AppLaunchContextPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AppLaunchContextPrivate*)
    end

    def to_unsafe_applaunchcontextprivate
      @pointer.not_nil!.as(LibGio::AppLaunchContextPrivate*)
    end
  end

  class Application < GObject::Object
    include Gio::ActionGroup
    include Gio::ActionMap

    @pointer : Void*

    def initialize(pointer : LibGio::Application*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GApplication")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_application_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Application*)
    end

    def to_unsafe_application
      @pointer.not_nil!.as(LibGio::Application*)
    end

    def initialize(*, action_group : Gio::ActionGroup? = nil, application_id : ::String? = nil, flags : Gio::ApplicationFlags? = nil, inactivity_timeout : UInt32? = nil, resource_base_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless action_group.nil?
        __var0 << "action-group".to_unsafe
        __var1 << action_group.to_gvalue.to_unsafe.value
      end

      unless application_id.nil?
        __var0 << "application-id".to_unsafe
        __var1 << application_id.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      unless inactivity_timeout.nil?
        __var0 << "inactivity-timeout".to_unsafe
        __var1 << inactivity_timeout.to_gvalue.to_unsafe.value
      end

      unless resource_base_path.nil?
        __var0 << "resource-base-path".to_unsafe
        __var1 << resource_base_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_application_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(application_id : ::String?, flags : Gio::ApplicationFlags) : self
      __var0 = LibGio.application_new(application_id ? application_id.to_unsafe : Pointer(UInt8).null, flags)
      GObject.raise_unexpected_null("g_application_new") if __var0.null?
      cast(Gio::Application.new(__var0))
    end

    def self.default
      __var0 = LibGio.application_get_default
      GObject.raise_unexpected_null("g_application_get_default") if __var0.null?
      Gio::Application.new(__var0)
    end

    def self.id_is_valid(application_id : ::String)
      __var0 = LibGio.application_id_is_valid(application_id.to_unsafe)
      (__var0 == 1)
    end

    def activate
      LibGio.application_activate(@pointer.as(LibGio::Application*))
      nil
    end

    def add_main_option(long_name : ::String, short_name : ::Int, flags : GLib::OptionFlags, arg : GLib::OptionArg, description : ::String, arg_description : ::String?)
      LibGio.application_add_main_option(@pointer.as(LibGio::Application*), long_name.to_unsafe, Int8.new(short_name), flags, arg, description.to_unsafe, arg_description ? arg_description.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def add_main_option_entries(entries : ::Enumerable)
      LibGio.application_add_main_option_entries(@pointer.as(LibGio::Application*), (__entries_ary = entries.map { |__item| __item }.to_a).to_unsafe)
      nil
    end

    def add_option_group(group : GLib::OptionGroup)
      LibGio.application_add_option_group(@pointer.as(LibGio::Application*), group.to_unsafe.as(LibGLib::OptionGroup*))
      nil
    end

    def bind_busy_property(object : GObject::Object, property : ::String)
      LibGio.application_bind_busy_property(@pointer.as(LibGio::Application*), object.to_unsafe_object, property.to_unsafe)
      nil
    end

    def application_id
      __var0 = LibGio.application_get_application_id(@pointer.as(LibGio::Application*))
      GObject.raise_unexpected_null("g_application_get_application_id") if __var0.null?
      ::String.new(__var0)
    end

    def dbus_connection
      __var0 = LibGio.application_get_dbus_connection(@pointer.as(LibGio::Application*))
      GObject.raise_unexpected_null("g_application_get_dbus_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def dbus_object_path
      __var0 = LibGio.application_get_dbus_object_path(@pointer.as(LibGio::Application*))
      GObject.raise_unexpected_null("g_application_get_dbus_object_path") if __var0.null?
      ::String.new(__var0)
    end

    def flags
      __var0 = LibGio.application_get_flags(@pointer.as(LibGio::Application*))
      Gio::ApplicationFlags.new(__var0)
    end

    def inactivity_timeout
      __var0 = LibGio.application_get_inactivity_timeout(@pointer.as(LibGio::Application*))
      __var0
    end

    def is_busy
      __var0 = LibGio.application_get_is_busy(@pointer.as(LibGio::Application*))
      (__var0 == 1)
    end

    def is_registered
      __var0 = LibGio.application_get_is_registered(@pointer.as(LibGio::Application*))
      (__var0 == 1)
    end

    def is_remote
      __var0 = LibGio.application_get_is_remote(@pointer.as(LibGio::Application*))
      (__var0 == 1)
    end

    def resource_base_path
      __var0 = LibGio.application_get_resource_base_path(@pointer.as(LibGio::Application*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def hold
      LibGio.application_hold(@pointer.as(LibGio::Application*))
      nil
    end

    def mark_busy
      LibGio.application_mark_busy(@pointer.as(LibGio::Application*))
      nil
    end

    def open(files : ::Enumerable, hint : ::String)
      n_files = files.size
      __files = (__files_ary = files.map { |__item| __item.to_unsafe_file }.to_a).to_unsafe
      n_files = __files_ary.size
      LibGio.application_open(@pointer.as(LibGio::Application*), __files, Int32.new(n_files), hint.to_unsafe)
      nil
    end

    def quit
      LibGio.application_quit(@pointer.as(LibGio::Application*))
      nil
    end

    def register(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.application_register(@pointer.as(LibGio::Application*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def release
      LibGio.application_release(@pointer.as(LibGio::Application*))
      nil
    end

    def run(argv : ::Enumerable?)
      argc = argv ? argv.size : 0
      __var0 = LibGio.application_run(@pointer.as(LibGio::Application*), Int32.new(argc), argv ? (__argv_ary = argv.map { |__item| __item.to_unsafe }.to_a).to_unsafe : Pointer(Pointer(UInt8)).null)
      __var0
    end

    def send_notification(id : ::String?, notification : Gio::Notification)
      LibGio.application_send_notification(@pointer.as(LibGio::Application*), id ? id.to_unsafe : Pointer(UInt8).null, notification.to_unsafe_notification)
      nil
    end

    def action_group=(action_group : Gio::ActionGroup?)
      LibGio.application_set_action_group(@pointer.as(LibGio::Application*), action_group ? action_group.to_unsafe_actiongroup : Pointer(LibGio::ActionGroup).null)
      nil
    end

    def application_id=(application_id : ::String?)
      LibGio.application_set_application_id(@pointer.as(LibGio::Application*), application_id ? application_id.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def set_default
      LibGio.application_set_default(@pointer.as(LibGio::Application*))
      nil
    end

    def flags=(flags : Gio::ApplicationFlags)
      LibGio.application_set_flags(@pointer.as(LibGio::Application*), flags)
      nil
    end

    def inactivity_timeout=(inactivity_timeout : ::Int)
      LibGio.application_set_inactivity_timeout(@pointer.as(LibGio::Application*), UInt32.new(inactivity_timeout))
      nil
    end

    def option_context_description=(description : ::String?)
      LibGio.application_set_option_context_description(@pointer.as(LibGio::Application*), description ? description.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def option_context_parameter_string=(parameter_string : ::String?)
      LibGio.application_set_option_context_parameter_string(@pointer.as(LibGio::Application*), parameter_string ? parameter_string.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def option_context_summary=(summary : ::String?)
      LibGio.application_set_option_context_summary(@pointer.as(LibGio::Application*), summary ? summary.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def resource_base_path=(resource_path : ::String?)
      LibGio.application_set_resource_base_path(@pointer.as(LibGio::Application*), resource_path ? resource_path.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def unbind_busy_property(object : GObject::Object, property : ::String)
      LibGio.application_unbind_busy_property(@pointer.as(LibGio::Application*), object.to_unsafe_object, property.to_unsafe)
      nil
    end

    def unmark_busy
      LibGio.application_unmark_busy(@pointer.as(LibGio::Application*))
      nil
    end

    def withdraw_notification(id : ::String)
      LibGio.application_withdraw_notification(@pointer.as(LibGio::Application*), id.to_unsafe)
      nil
    end

    alias ActivateSignal = Application -> Nil

    def on_activate(*, after = false, &block : ActivateSignal)
      __var0 = ->(arg0 : LibGio::Application*, box : Void*) {
        ::Box(ActivateSignal).unbox(box).call(Application.new(arg0))
      }

      __var1 = ::Box.box(ActivateSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "activate", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_activate(&block : ActivateSignal)
      on_activate(after: true, &block)
    end

    alias CommandLineSignal = Application, Gio::ApplicationCommandLine -> Int32

    def on_command_line(*, after = false, &block : CommandLineSignal)
      __var0 = ->(arg0 : LibGio::Application*, arg1 : LibGio::ApplicationCommandLine*, box : Void*) {
        Int32.new(::Box(CommandLineSignal).unbox(box).call(Application.new(arg0), arg1.null? ? GObject.raise_unexpected_null("command_line in command_line") : Gio::ApplicationCommandLine.new(arg1)))
      }

      __var1 = ::Box.box(CommandLineSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "command-line", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_command_line(&block : CommandLineSignal)
      on_command_line(after: true, &block)
    end

    alias HandleLocalOptionsSignal = Application, GLib::VariantDict -> Int32

    def on_handle_local_options(*, after = false, &block : HandleLocalOptionsSignal)
      __var0 = ->(arg0 : LibGio::Application*, arg1 : LibGLib::VariantDict*, box : Void*) {
        Int32.new(::Box(HandleLocalOptionsSignal).unbox(box).call(Application.new(arg0), arg1.null? ? GObject.raise_unexpected_null("options in handle_local_options") : GLib::VariantDict.new(arg1)))
      }

      __var1 = ::Box.box(HandleLocalOptionsSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "handle-local-options", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_handle_local_options(&block : HandleLocalOptionsSignal)
      on_handle_local_options(after: true, &block)
    end

    alias NameLostSignal = Application -> ::Bool

    def on_name_lost(*, after = false, &block : NameLostSignal)
      __var0 = ->(arg0 : LibGio::Application*, box : Void*) {
        LibC::Int.new(::Box(NameLostSignal).unbox(box).call(Application.new(arg0)) ? 1 : 0)
      }

      __var1 = ::Box.box(NameLostSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "name-lost", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_name_lost(&block : NameLostSignal)
      on_name_lost(after: true, &block)
    end

    alias OpenSignal = Application, ::Enumerable(Gio::File), Int32, ::String -> Nil

    def on_open(*, after = false, &block : OpenSignal)
      __var0 = ->(arg0 : LibGio::Application*, arg1 : Pointer(LibGio::File), arg2 : Int32, arg3 : Pointer(UInt8), box : Void*) {
        ::Box(OpenSignal).unbox(box).call(Application.new(arg0), GObject::PointerIterator.new(arg1) { |__var0|
          Gio::File::Wrapper.new(__var0)
        }, arg2, ::String.new(arg3))
      }

      __var1 = ::Box.box(OpenSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "open", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_open(&block : OpenSignal)
      on_open(after: true, &block)
    end

    alias ShutdownSignal = Application -> Nil

    def on_shutdown(*, after = false, &block : ShutdownSignal)
      __var0 = ->(arg0 : LibGio::Application*, box : Void*) {
        ::Box(ShutdownSignal).unbox(box).call(Application.new(arg0))
      }

      __var1 = ::Box.box(ShutdownSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "shutdown", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_shutdown(&block : ShutdownSignal)
      on_shutdown(after: true, &block)
    end

    alias StartupSignal = Application -> Nil

    def on_startup(*, after = false, &block : StartupSignal)
      __var0 = ->(arg0 : LibGio::Application*, box : Void*) {
        ::Box(StartupSignal).unbox(box).call(Application.new(arg0))
      }

      __var1 = ::Box.box(StartupSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "startup", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_startup(&block : StartupSignal)
      on_startup(after: true, &block)
    end
  end

  class ApplicationClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(312u64, 0u8).as(LibGio::ApplicationClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ApplicationClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ApplicationClass*)
    end

    def to_unsafe_applicationclass
      @pointer.not_nil!.as(LibGio::ApplicationClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ApplicationClass*).value.parent_class)
    end

    def startup
      to_unsafe.as(LibGio::ApplicationClass*).value.startup
    end

    def activate
      to_unsafe.as(LibGio::ApplicationClass*).value.activate
    end

    def open
      to_unsafe.as(LibGio::ApplicationClass*).value.open
    end

    def command_line
      to_unsafe.as(LibGio::ApplicationClass*).value.command_line
    end

    def local_command_line
      to_unsafe.as(LibGio::ApplicationClass*).value.local_command_line
    end

    def before_emit
      to_unsafe.as(LibGio::ApplicationClass*).value.before_emit
    end

    def after_emit
      to_unsafe.as(LibGio::ApplicationClass*).value.after_emit
    end

    def add_platform_data
      to_unsafe.as(LibGio::ApplicationClass*).value.add_platform_data
    end

    def quit_mainloop
      to_unsafe.as(LibGio::ApplicationClass*).value.quit_mainloop
    end

    def run_mainloop
      to_unsafe.as(LibGio::ApplicationClass*).value.run_mainloop
    end

    def shutdown
      to_unsafe.as(LibGio::ApplicationClass*).value.shutdown
    end

    def dbus_register
      to_unsafe.as(LibGio::ApplicationClass*).value.dbus_register
    end

    def dbus_unregister
      to_unsafe.as(LibGio::ApplicationClass*).value.dbus_unregister
    end

    def handle_local_options
      to_unsafe.as(LibGio::ApplicationClass*).value.handle_local_options
    end

    def name_lost
      to_unsafe.as(LibGio::ApplicationClass*).value.name_lost
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::ApplicationClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class ApplicationCommandLine < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::ApplicationCommandLine*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GApplicationCommandLine")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_application_command_line_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ApplicationCommandLine*)
    end

    def to_unsafe_applicationcommandline
      @pointer.not_nil!.as(LibGio::ApplicationCommandLine*)
    end

    def initialize(*, arguments : GLib::Variant? = nil, options : GLib::Variant? = nil, platform_data : GLib::Variant? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless arguments.nil?
        __var0 << "arguments".to_unsafe
        __var1 << arguments.to_gvalue.to_unsafe.value
      end

      unless options.nil?
        __var0 << "options".to_unsafe
        __var1 << options.to_gvalue.to_unsafe.value
      end

      unless platform_data.nil?
        __var0 << "platform-data".to_unsafe
        __var1 << platform_data.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_application_command_line_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def create_file_for_arg(arg : ::String)
      __var0 = LibGio.application_command_line_create_file_for_arg(@pointer.as(LibGio::ApplicationCommandLine*), arg.to_unsafe)
      GObject.raise_unexpected_null("g_application_command_line_create_file_for_arg") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def arguments
      __var0 = LibGio.application_command_line_get_arguments(@pointer.as(LibGio::ApplicationCommandLine*), out argc)
      GObject.raise_unexpected_null("g_application_command_line_get_arguments") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }, argc}
    end

    def cwd
      __var0 = LibGio.application_command_line_get_cwd(@pointer.as(LibGio::ApplicationCommandLine*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def environ
      __var0 = LibGio.application_command_line_get_environ(@pointer.as(LibGio::ApplicationCommandLine*))
      GObject.raise_unexpected_null("g_application_command_line_get_environ") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def exit_status
      __var0 = LibGio.application_command_line_get_exit_status(@pointer.as(LibGio::ApplicationCommandLine*))
      __var0
    end

    def is_remote
      __var0 = LibGio.application_command_line_get_is_remote(@pointer.as(LibGio::ApplicationCommandLine*))
      (__var0 == 1)
    end

    def options_dict
      __var0 = LibGio.application_command_line_get_options_dict(@pointer.as(LibGio::ApplicationCommandLine*))
      GObject.raise_unexpected_null("g_application_command_line_get_options_dict") if __var0.null?
      GLib::VariantDict.new(__var0)
    end

    def platform_data
      __var0 = LibGio.application_command_line_get_platform_data(@pointer.as(LibGio::ApplicationCommandLine*))
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def stdin
      __var0 = LibGio.application_command_line_get_stdin(@pointer.as(LibGio::ApplicationCommandLine*))
      GObject.raise_unexpected_null("g_application_command_line_get_stdin") if __var0.null?
      Gio::InputStream.new(__var0)
    end

    def getenv(name : ::String)
      __var0 = LibGio.application_command_line_getenv(@pointer.as(LibGio::ApplicationCommandLine*), name.to_unsafe)
      GObject.raise_unexpected_null("g_application_command_line_getenv") if __var0.null?
      ::String.new(__var0)
    end

    def exit_status=(exit_status : ::Int)
      LibGio.application_command_line_set_exit_status(@pointer.as(LibGio::ApplicationCommandLine*), Int32.new(exit_status))
      nil
    end
  end

  class ApplicationCommandLineClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(248u64, 0u8).as(LibGio::ApplicationCommandLineClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ApplicationCommandLineClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ApplicationCommandLineClass*)
    end

    def to_unsafe_applicationcommandlineclass
      @pointer.not_nil!.as(LibGio::ApplicationCommandLineClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ApplicationCommandLineClass*).value.parent_class)
    end

    def print_literal
      to_unsafe.as(LibGio::ApplicationCommandLineClass*).value.print_literal
    end

    def printerr_literal
      to_unsafe.as(LibGio::ApplicationCommandLineClass*).value.printerr_literal
    end

    def get_stdin
      to_unsafe.as(LibGio::ApplicationCommandLineClass*).value.get_stdin
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::ApplicationCommandLineClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class ApplicationCommandLinePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ApplicationCommandLinePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ApplicationCommandLinePrivate*)
    end

    def to_unsafe_applicationcommandlineprivate
      @pointer.not_nil!.as(LibGio::ApplicationCommandLinePrivate*)
    end
  end

  @[Flags]
  enum ApplicationFlags : UInt32
    FLAGS_NONE           =   0
    IS_SERVICE           =   1
    IS_LAUNCHER          =   2
    HANDLES_OPEN         =   4
    HANDLES_COMMAND_LINE =   8
    SEND_ENVIRONMENT     =  16
    NON_UNIQUE           =  32
    CAN_OVERRIDE_APP_ID  =  64
    ALLOW_REPLACEMENT    = 128
    REPLACE              = 256
  end

  class ApplicationPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ApplicationPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ApplicationPrivate*)
    end

    def to_unsafe_applicationprivate
      @pointer.not_nil!.as(LibGio::ApplicationPrivate*)
    end
  end

  @[Flags]
  enum AskPasswordFlags : UInt32
    ZERO_NONE           =  0
    NEED_PASSWORD       =  1
    NEED_USERNAME       =  2
    NEED_DOMAIN         =  4
    SAVING_SUPPORTED    =  8
    ANONYMOUS_SUPPORTED = 16
    TCRYPT              = 32
  end

  module AsyncInitable
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include AsyncInitable
      @pointer : Void*

      def initialize(pointer : LibGio::AsyncInitable*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GAsyncInitable")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_async_initable_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::AsyncInitable*)
      end

      def to_unsafe_asyncinitable
        @pointer.not_nil!.as(LibGio::AsyncInitable*)
      end
    end

    def to_unsafe_asyncinitable
      @pointer.not_nil!.as(LibGio::AsyncInitable*)
    end

    def self.newv_async(object_type : UInt64, parameters : GObject::Parameter, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      __parameters = parameters.to_unsafe.as(LibGObject::Parameter*)
      n_parameters = __parameters_ary.size
      LibGio.async_initable_newv_async(UInt64.new(object_type), UInt32.new(n_parameters), __parameters, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def init_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.async_initable_init_async(@pointer.as(LibGio::AsyncInitable*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def init_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.async_initable_init_finish(@pointer.as(LibGio::AsyncInitable*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def new_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.async_initable_new_finish(@pointer.as(LibGio::AsyncInitable*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_async_initable_new_finish") if __var1.null?
      GObject::Object.new(__var1)
    end
  end

  class AsyncInitableIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::AsyncInitableIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::AsyncInitableIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AsyncInitableIface*)
    end

    def to_unsafe_asyncinitableiface
      @pointer.not_nil!.as(LibGio::AsyncInitableIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::AsyncInitableIface*).value.g_iface)
    end

    def init_async
      to_unsafe.as(LibGio::AsyncInitableIface*).value.init_async
    end

    def init_finish
      to_unsafe.as(LibGio::AsyncInitableIface*).value.init_finish
    end
  end

  alias AsyncReadyCallback = LibGio::AsyncReadyCallback

  module AsyncResult
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include AsyncResult
      @pointer : Void*

      def initialize(pointer : LibGio::AsyncResult*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GAsyncResult")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_async_result_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::AsyncResult*)
      end

      def to_unsafe_asyncresult
        @pointer.not_nil!.as(LibGio::AsyncResult*)
      end
    end

    def to_unsafe_asyncresult
      @pointer.not_nil!.as(LibGio::AsyncResult*)
    end

    def source_object
      __var0 = LibGio.async_result_get_source_object(@pointer.as(LibGio::AsyncResult*))
      __var1 = GObject::Object.new(__var0) if __var0
      __var1
    end

    def user_data
      LibGio.async_result_get_user_data(@pointer.as(LibGio::AsyncResult*))
      nil
    end

    def tagged?(source_tag : Void*?)
      __var0 = LibGio.async_result_is_tagged(@pointer.as(LibGio::AsyncResult*), source_tag ? source_tag : Pointer(Void).null)
      (__var0 == 1)
    end

    def legacy_propagate_error
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.async_result_legacy_propagate_error(@pointer.as(LibGio::AsyncResult*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class AsyncResultIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::AsyncResultIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::AsyncResultIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::AsyncResultIface*)
    end

    def to_unsafe_asyncresultiface
      @pointer.not_nil!.as(LibGio::AsyncResultIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::AsyncResultIface*).value.g_iface)
    end

    def get_user_data
      to_unsafe.as(LibGio::AsyncResultIface*).value.get_user_data
    end

    def get_source_object
      to_unsafe.as(LibGio::AsyncResultIface*).value.get_source_object
    end

    def is_tagged
      to_unsafe.as(LibGio::AsyncResultIface*).value.is_tagged
    end
  end

  class InputStream < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::InputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InputStream*)
    end

    def to_unsafe_inputstream
      @pointer.not_nil!.as(LibGio::InputStream*)
    end

    def clear_pending
      LibGio.input_stream_clear_pending(@pointer.as(LibGio::InputStream*))
      nil
    end

    def close(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_close(@pointer.as(LibGio::InputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.input_stream_close_async(@pointer.as(LibGio::InputStream*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_close_finish(@pointer.as(LibGio::InputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def has_pending
      __var0 = LibGio.input_stream_has_pending(@pointer.as(LibGio::InputStream*))
      (__var0 == 1)
    end

    def closed?
      __var0 = LibGio.input_stream_is_closed(@pointer.as(LibGio::InputStream*))
      (__var0 == 1)
    end

    def read(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read(@pointer.as(LibGio::InputStream*), buffer, out count, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {__var1, count}
    end

    def read_all(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read_all(@pointer.as(LibGio::InputStream*), buffer, out count, out bytes_read, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), count, bytes_read}
    end

    def read_all_async(buffer : ::Bytes, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.input_stream_read_all_async(@pointer.as(LibGio::InputStream*), buffer, out count, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      count
    end

    def read_all_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read_all_finish(@pointer.as(LibGio::InputStream*), result.to_unsafe_asyncresult, out bytes_read, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_read}
    end

    def read_async(buffer : ::Bytes, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.input_stream_read_async(@pointer.as(LibGio::InputStream*), buffer, out count, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      count
    end

    def read_bytes(count : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read_bytes(@pointer.as(LibGio::InputStream*), UInt64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_input_stream_read_bytes") if __var1.null?
      GLib::Bytes.new(__var1)
    end

    def read_bytes_async(count : ::Int, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.input_stream_read_bytes_async(@pointer.as(LibGio::InputStream*), UInt64.new(count), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def read_bytes_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read_bytes_finish(@pointer.as(LibGio::InputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_input_stream_read_bytes_finish") if __var1.null?
      GLib::Bytes.new(__var1)
    end

    def read_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_read_finish(@pointer.as(LibGio::InputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def pending=
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_set_pending(@pointer.as(LibGio::InputStream*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def skip(count : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_skip(@pointer.as(LibGio::InputStream*), UInt64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def skip_async(count : ::Int, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.input_stream_skip_async(@pointer.as(LibGio::InputStream*), UInt64.new(count), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def skip_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.input_stream_skip_finish(@pointer.as(LibGio::InputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end
  end

  class BufferedInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::BufferedInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedInputStreamClass*)
    end

    def to_unsafe_bufferedinputstreamclass
      @pointer.not_nil!.as(LibGio::BufferedInputStreamClass*)
    end

    def parent_class
      Gio::FilterInputStreamClass.new(to_unsafe.as(LibGio::BufferedInputStreamClass*).value.parent_class)
    end

    def fill
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value.fill
    end

    def fill_async
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value.fill_async
    end

    def fill_finish
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value.fill_finish
    end

    def _g_reserved1
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::BufferedInputStreamClass*).value._g_reserved5
    end
  end

  class BufferedInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedInputStreamPrivate*)
    end

    def to_unsafe_bufferedinputstreamprivate
      @pointer.not_nil!.as(LibGio::BufferedInputStreamPrivate*)
    end
  end

  class OutputStream < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::OutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::OutputStream*)
    end

    def to_unsafe_outputstream
      @pointer.not_nil!.as(LibGio::OutputStream*)
    end

    def clear_pending
      LibGio.output_stream_clear_pending(@pointer.as(LibGio::OutputStream*))
      nil
    end

    def close(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_close(@pointer.as(LibGio::OutputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.output_stream_close_async(@pointer.as(LibGio::OutputStream*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_close_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def flush(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_flush(@pointer.as(LibGio::OutputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def flush_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.output_stream_flush_async(@pointer.as(LibGio::OutputStream*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def flush_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_flush_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def has_pending
      __var0 = LibGio.output_stream_has_pending(@pointer.as(LibGio::OutputStream*))
      (__var0 == 1)
    end

    def closed?
      __var0 = LibGio.output_stream_is_closed(@pointer.as(LibGio::OutputStream*))
      (__var0 == 1)
    end

    def closing?
      __var0 = LibGio.output_stream_is_closing(@pointer.as(LibGio::OutputStream*))
      (__var0 == 1)
    end

    def pending=
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_set_pending(@pointer.as(LibGio::OutputStream*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def splice(source : Gio::InputStream, flags : Gio::OutputStreamSpliceFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_splice(@pointer.as(LibGio::OutputStream*), source.to_unsafe_inputstream, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def splice_async(source : Gio::InputStream, flags : Gio::OutputStreamSpliceFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.output_stream_splice_async(@pointer.as(LibGio::OutputStream*), source.to_unsafe_inputstream, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def splice_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_splice_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def write(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      count = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write(@pointer.as(LibGio::OutputStream*), buffer.to_unsafe, UInt64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def write_all(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      count = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write_all(@pointer.as(LibGio::OutputStream*), buffer.to_unsafe, UInt64.new(count), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end

    def write_all_async(buffer : ::Bytes, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      count = buffer.size
      LibGio.output_stream_write_all_async(@pointer.as(LibGio::OutputStream*), buffer.to_unsafe, UInt64.new(count), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def write_all_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write_all_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, out bytes_written, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end

    def write_async(buffer : ::Bytes, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      count = buffer.size
      LibGio.output_stream_write_async(@pointer.as(LibGio::OutputStream*), buffer.to_unsafe, UInt64.new(count), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def write_bytes(bytes : GLib::Bytes, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write_bytes(@pointer.as(LibGio::OutputStream*), bytes.to_unsafe.as(LibGLib::Bytes*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def write_bytes_async(bytes : GLib::Bytes, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.output_stream_write_bytes_async(@pointer.as(LibGio::OutputStream*), bytes.to_unsafe.as(LibGLib::Bytes*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def write_bytes_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write_bytes_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def write_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_write_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def writev(vectors : ::Enumerable, cancellable : Gio::Cancellable?)
      n_vectors = vectors.size
      __vectors = (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe
      n_vectors = __vectors_ary.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_writev(@pointer.as(LibGio::OutputStream*), __vectors, UInt64.new(n_vectors), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end

    def writev_all(vectors : ::Enumerable, cancellable : Gio::Cancellable?)
      n_vectors = vectors.size
      __vectors = (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe
      n_vectors = __vectors_ary.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_writev_all(@pointer.as(LibGio::OutputStream*), __vectors, UInt64.new(n_vectors), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end

    def writev_all_async(vectors : ::Enumerable, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      n_vectors = vectors.size
      __vectors = (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe
      n_vectors = __vectors_ary.size
      LibGio.output_stream_writev_all_async(@pointer.as(LibGio::OutputStream*), __vectors, UInt64.new(n_vectors), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def writev_all_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_writev_all_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, out bytes_written, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end

    def writev_async(vectors : ::Enumerable, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      n_vectors = vectors.size
      __vectors = (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe
      n_vectors = __vectors_ary.size
      LibGio.output_stream_writev_async(@pointer.as(LibGio::OutputStream*), __vectors, UInt64.new(n_vectors), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def writev_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.output_stream_writev_finish(@pointer.as(LibGio::OutputStream*), result.to_unsafe_asyncresult, out bytes_written, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), bytes_written}
    end
  end

  class BufferedOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::BufferedOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedOutputStreamClass*)
    end

    def to_unsafe_bufferedoutputstreamclass
      @pointer.not_nil!.as(LibGio::BufferedOutputStreamClass*)
    end

    def parent_class
      Gio::FilterOutputStreamClass.new(to_unsafe.as(LibGio::BufferedOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::BufferedOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::BufferedOutputStreamClass*).value._g_reserved2
    end
  end

  class BufferedOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedOutputStreamPrivate*)
    end

    def to_unsafe_bufferedoutputstreamprivate
      @pointer.not_nil!.as(LibGio::BufferedOutputStreamPrivate*)
    end
  end

  alias BusAcquiredCallback = LibGio::BusAcquiredCallback
  alias BusNameAcquiredCallback = LibGio::BusNameAcquiredCallback
  alias BusNameAppearedCallback = LibGio::BusNameAppearedCallback
  alias BusNameLostCallback = LibGio::BusNameLostCallback

  @[Flags]
  enum BusNameOwnerFlags : UInt32
    NONE              = 0
    ALLOW_REPLACEMENT = 1
    REPLACE           = 2
    DO_NOT_QUEUE      = 4
  end
  alias BusNameVanishedCallback = LibGio::BusNameVanishedCallback

  @[Flags]
  enum BusNameWatcherFlags : UInt32
    NONE       = 0
    AUTO_START = 1
  end

  enum BusType : Int32
    STARTER = -1
    NONE    =  0
    SYSTEM  =  1
    SESSION =  2
  end

  module Icon
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Icon
      @pointer : Void*

      def initialize(pointer : LibGio::Icon*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_icon_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Icon*)
      end

      def to_unsafe_icon
        @pointer.not_nil!.as(LibGio::Icon*)
      end
    end

    def to_unsafe_icon
      @pointer.not_nil!.as(LibGio::Icon*)
    end

    def self.deserialize(value : GLib::Variant)
      __var0 = LibGio.icon_deserialize(value.to_unsafe.as(LibGLib::Variant*))
      GObject.raise_unexpected_null("g_icon_deserialize") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def self.hash(icon : Void*)
      __var0 = LibGio.icon_hash(icon)
      __var0
    end

    def self.new_for_string(str : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.icon_new_for_string(str.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_icon_new_for_string") if __var1.null?
      Gio::Icon::Wrapper.new(__var1)
    end

    def equal(icon2 : Gio::Icon?)
      __var0 = LibGio.icon_equal(@pointer.as(LibGio::Icon*), icon2 ? icon2.to_unsafe_icon : Pointer(LibGio::Icon).null)
      (__var0 == 1)
    end

    def serialize
      __var0 = LibGio.icon_serialize(@pointer.as(LibGio::Icon*))
      GObject.raise_unexpected_null("g_icon_serialize") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def to_string
      __var0 = LibGio.icon_to_string(@pointer.as(LibGio::Icon*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end
  end

  class Cancellable < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Cancellable*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GCancellable")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_cancellable_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Cancellable*)
    end

    def to_unsafe_cancellable
      @pointer.not_nil!.as(LibGio::Cancellable*)
    end

    def self.new : self
      __var0 = LibGio.cancellable_new
      GObject.raise_unexpected_null("g_cancellable_new") if __var0.null?
      cast(Gio::Cancellable.new(__var0))
    end

    def self.current
      __var0 = LibGio.cancellable_get_current
      __var1 = Gio::Cancellable.new(__var0) if __var0
      __var1
    end

    def cancel
      LibGio.cancellable_cancel(@pointer.as(LibGio::Cancellable*))
      nil
    end

    def connect(callback : GObject::Callback, data : Void*?, data_destroy_func : GLib::DestroyNotify?)
      __var0 = LibGio.cancellable_connect(@pointer.as(LibGio::Cancellable*), callback, data ? data : Pointer(Void).null, data_destroy_func ? data_destroy_func : nil)
      __var0
    end

    def disconnect(handler_id : ::Int)
      LibGio.cancellable_disconnect(@pointer.as(LibGio::Cancellable*), UInt64.new(handler_id))
      nil
    end

    def fd
      __var0 = LibGio.cancellable_get_fd(@pointer.as(LibGio::Cancellable*))
      __var0
    end

    def cancelled?
      __var0 = LibGio.cancellable_is_cancelled(@pointer.as(LibGio::Cancellable*))
      (__var0 == 1)
    end

    def make_pollfd(pollfd : GLib::PollFD)
      __var0 = LibGio.cancellable_make_pollfd(@pointer.as(LibGio::Cancellable*), pollfd.to_unsafe.as(LibGLib::PollFD*))
      (__var0 == 1)
    end

    def pop_current
      LibGio.cancellable_pop_current(@pointer.as(LibGio::Cancellable*))
      nil
    end

    def push_current
      LibGio.cancellable_push_current(@pointer.as(LibGio::Cancellable*))
      nil
    end

    def release_fd
      LibGio.cancellable_release_fd(@pointer.as(LibGio::Cancellable*))
      nil
    end

    def reset
      LibGio.cancellable_reset(@pointer.as(LibGio::Cancellable*))
      nil
    end

    def error_if_cancelled=
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.cancellable_set_error_if_cancelled(@pointer.as(LibGio::Cancellable*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def source_new
      __var0 = LibGio.cancellable_source_new(@pointer.as(LibGio::Cancellable*))
      GObject.raise_unexpected_null("g_cancellable_source_new") if __var0.null?
      GLib::Source.new(__var0)
    end

    alias CancelledSignal = Cancellable -> Nil

    def on_cancelled(*, after = false, &block : CancelledSignal)
      __var0 = ->(arg0 : LibGio::Cancellable*, box : Void*) {
        ::Box(CancelledSignal).unbox(box).call(Cancellable.new(arg0))
      }

      __var1 = ::Box.box(CancelledSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "cancelled", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_cancelled(&block : CancelledSignal)
      on_cancelled(after: true, &block)
    end
  end

  class CancellableClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(184u64, 0u8).as(LibGio::CancellableClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::CancellableClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::CancellableClass*)
    end

    def to_unsafe_cancellableclass
      @pointer.not_nil!.as(LibGio::CancellableClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::CancellableClass*).value.parent_class)
    end

    def cancelled
      to_unsafe.as(LibGio::CancellableClass*).value.cancelled
    end

    def _g_reserved1
      to_unsafe.as(LibGio::CancellableClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::CancellableClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::CancellableClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::CancellableClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::CancellableClass*).value._g_reserved5
    end
  end

  class CancellablePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::CancellablePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::CancellablePrivate*)
    end

    def to_unsafe_cancellableprivate
      @pointer.not_nil!.as(LibGio::CancellablePrivate*)
    end
  end

  alias CancellableSourceFunc = LibGio::CancellableSourceFunc

  module Converter
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Converter
      @pointer : Void*

      def initialize(pointer : LibGio::Converter*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GConverter")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_converter_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Converter*)
      end

      def to_unsafe_converter
        @pointer.not_nil!.as(LibGio::Converter*)
      end
    end

    def to_unsafe_converter
      @pointer.not_nil!.as(LibGio::Converter*)
    end

    def convert(inbuf : ::Bytes, outbuf : ::Bytes, flags : Gio::ConverterFlags)
      inbuf_size = inbuf.size
      outbuf_size = outbuf.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.converter_convert(@pointer.as(LibGio::Converter*), inbuf.to_unsafe, UInt64.new(inbuf_size), outbuf.to_unsafe, UInt64.new(outbuf_size), flags, out bytes_read, out bytes_written, pointerof(__var0))
      GLib::Error.assert(__var0)
      {Gio::ConverterResult.new(__var1), bytes_read, bytes_written}
    end

    def reset
      LibGio.converter_reset(@pointer.as(LibGio::Converter*))
      nil
    end
  end

  class CharsetConverterClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::CharsetConverterClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::CharsetConverterClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::CharsetConverterClass*)
    end

    def to_unsafe_charsetconverterclass
      @pointer.not_nil!.as(LibGio::CharsetConverterClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::CharsetConverterClass*).value.parent_class)
    end
  end

  module Initable
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Initable
      @pointer : Void*

      def initialize(pointer : LibGio::Initable*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GInitable")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_initable_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Initable*)
      end

      def to_unsafe_initable
        @pointer.not_nil!.as(LibGio::Initable*)
      end
    end

    def to_unsafe_initable
      @pointer.not_nil!.as(LibGio::Initable*)
    end

    def self.newv(object_type : UInt64, parameters : ::Enumerable, cancellable : Gio::Cancellable?)
      n_parameters = parameters.size
      __parameters = (__parameters_ary = parameters.map { |__item| __item }.to_a).to_unsafe
      n_parameters = __parameters_ary.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.initable_newv(UInt64.new(object_type), UInt32.new(n_parameters), __parameters, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_initable_newv") if __var1.null?
      GObject::Object.new(__var1)
    end

    def init(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.initable_init(@pointer.as(LibGio::Initable*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  @[Flags]
  enum ConverterFlags : UInt32
    NONE         = 0
    INPUT_AT_END = 1
    FLUSH        = 2
  end

  class ConverterIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::ConverterIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterIface*)
    end

    def to_unsafe_converteriface
      @pointer.not_nil!.as(LibGio::ConverterIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ConverterIface*).value.g_iface)
    end

    def convert
      to_unsafe.as(LibGio::ConverterIface*).value.convert
    end

    def reset
      to_unsafe.as(LibGio::ConverterIface*).value.reset
    end
  end

  class FilterInputStream < InputStream
    @pointer : Void*

    def initialize(pointer : LibGio::FilterInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFilterInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_filter_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilterInputStream*)
    end

    def to_unsafe_filterinputstream
      @pointer.not_nil!.as(LibGio::FilterInputStream*)
    end

    def base_stream
      __var0 = LibGio.filter_input_stream_get_base_stream(@pointer.as(LibGio::FilterInputStream*))
      GObject.raise_unexpected_null("g_filter_input_stream_get_base_stream") if __var0.null?
      Gio::InputStream.new(__var0)
    end

    def close_base_stream
      __var0 = LibGio.filter_input_stream_get_close_base_stream(@pointer.as(LibGio::FilterInputStream*))
      (__var0 == 1)
    end

    def close_base_stream=(close_base : ::Bool)
      LibGio.filter_input_stream_set_close_base_stream(@pointer.as(LibGio::FilterInputStream*), LibC::Int.new(close_base ? 1 : 0))
      nil
    end
  end

  class ConverterInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(312u64, 0u8).as(LibGio::ConverterInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterInputStreamClass*)
    end

    def to_unsafe_converterinputstreamclass
      @pointer.not_nil!.as(LibGio::ConverterInputStreamClass*)
    end

    def parent_class
      Gio::FilterInputStreamClass.new(to_unsafe.as(LibGio::ConverterInputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::ConverterInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::ConverterInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::ConverterInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::ConverterInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::ConverterInputStreamClass*).value._g_reserved5
    end
  end

  class ConverterInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterInputStreamPrivate*)
    end

    def to_unsafe_converterinputstreamprivate
      @pointer.not_nil!.as(LibGio::ConverterInputStreamPrivate*)
    end
  end

  class FilterOutputStream < OutputStream
    @pointer : Void*

    def initialize(pointer : LibGio::FilterOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFilterOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_filter_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilterOutputStream*)
    end

    def to_unsafe_filteroutputstream
      @pointer.not_nil!.as(LibGio::FilterOutputStream*)
    end

    def base_stream
      __var0 = LibGio.filter_output_stream_get_base_stream(@pointer.as(LibGio::FilterOutputStream*))
      GObject.raise_unexpected_null("g_filter_output_stream_get_base_stream") if __var0.null?
      Gio::OutputStream.new(__var0)
    end

    def close_base_stream
      __var0 = LibGio.filter_output_stream_get_close_base_stream(@pointer.as(LibGio::FilterOutputStream*))
      (__var0 == 1)
    end

    def close_base_stream=(close_base : ::Bool)
      LibGio.filter_output_stream_set_close_base_stream(@pointer.as(LibGio::FilterOutputStream*), LibC::Int.new(close_base ? 1 : 0))
      nil
    end
  end

  class ConverterOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(360u64, 0u8).as(LibGio::ConverterOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterOutputStreamClass*)
    end

    def to_unsafe_converteroutputstreamclass
      @pointer.not_nil!.as(LibGio::ConverterOutputStreamClass*)
    end

    def parent_class
      Gio::FilterOutputStreamClass.new(to_unsafe.as(LibGio::ConverterOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::ConverterOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::ConverterOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::ConverterOutputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::ConverterOutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::ConverterOutputStreamClass*).value._g_reserved5
    end
  end

  class ConverterOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterOutputStreamPrivate*)
    end

    def to_unsafe_converteroutputstreamprivate
      @pointer.not_nil!.as(LibGio::ConverterOutputStreamPrivate*)
    end
  end

  enum ConverterResult : UInt32
    ERROR     = 0
    CONVERTED = 1
    FINISHED  = 2
    FLUSHED   = 3
  end

  class Credentials < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Credentials*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GCredentials")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_credentials_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Credentials*)
    end

    def to_unsafe_credentials
      @pointer.not_nil!.as(LibGio::Credentials*)
    end

    def self.new : self
      __var0 = LibGio.credentials_new
      GObject.raise_unexpected_null("g_credentials_new") if __var0.null?
      cast(Gio::Credentials.new(__var0))
    end

    def unix_pid
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.credentials_get_unix_pid(@pointer.as(LibGio::Credentials*), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def unix_user
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.credentials_get_unix_user(@pointer.as(LibGio::Credentials*), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def same_user?(other_credentials : Gio::Credentials)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.credentials_is_same_user(@pointer.as(LibGio::Credentials*), other_credentials.to_unsafe_credentials, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_native(native_type : Gio::CredentialsType, native : Void*)
      LibGio.credentials_set_native(@pointer.as(LibGio::Credentials*), native_type, native)
      nil
    end

    def set_unix_user(uid : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.credentials_set_unix_user(@pointer.as(LibGio::Credentials*), UInt32.new(uid), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def to_string
      __var0 = LibGio.credentials_to_string(@pointer.as(LibGio::Credentials*))
      GObject.raise_unexpected_null("g_credentials_to_string") if __var0.null?
      ::String.new(__var0)
    end
  end

  class CredentialsClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::CredentialsClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::CredentialsClass*)
    end

    def to_unsafe_credentialsclass
      @pointer.not_nil!.as(LibGio::CredentialsClass*)
    end
  end

  enum CredentialsType : UInt32
    INVALID              = 0
    LINUX_UCRED          = 1
    FREEBSD_CMSGCRED     = 2
    OPENBSD_SOCKPEERCRED = 3
    SOLARIS_UCRED        = 4
    NETBSD_UNPCBID       = 5
  end

  module RemoteActionGroup
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include RemoteActionGroup
      @pointer : Void*

      def initialize(pointer : LibGio::RemoteActionGroup*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GRemoteActionGroup")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_remote_action_group_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::RemoteActionGroup*)
      end

      def to_unsafe_remoteactiongroup
        @pointer.not_nil!.as(LibGio::RemoteActionGroup*)
      end
    end

    def to_unsafe_remoteactiongroup
      @pointer.not_nil!.as(LibGio::RemoteActionGroup*)
    end

    def activate_action_full(action_name : ::String, parameter : GLib::Variant?, platform_data : GLib::Variant)
      LibGio.remote_action_group_activate_action_full(@pointer.as(LibGio::RemoteActionGroup*), action_name.to_unsafe, parameter ? parameter.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, platform_data.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def change_action_state_full(action_name : ::String, value : GLib::Variant, platform_data : GLib::Variant)
      LibGio.remote_action_group_change_action_state_full(@pointer.as(LibGio::RemoteActionGroup*), action_name.to_unsafe, value.to_unsafe.as(LibGLib::Variant*), platform_data.to_unsafe.as(LibGLib::Variant*))
      nil
    end
  end

  class DBusAnnotationInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, key : ::String? = nil, value : ::String? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::DBusAnnotationInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.key = key unless key.nil?
      __var0.value = value unless value.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusAnnotationInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusAnnotationInfo*)
    end

    def to_unsafe_dbusannotationinfo
      @pointer.not_nil!.as(LibGio::DBusAnnotationInfo*)
    end

    def ref
      __var0 = LibGio.d_bus_annotation_info_ref(@pointer.as(LibGio::DBusAnnotationInfo*))
      GObject.raise_unexpected_null("g_dbus_annotation_info_ref") if __var0.null?
      Gio::DBusAnnotationInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_annotation_info_unref(@pointer.as(LibGio::DBusAnnotationInfo*))
      nil
    end

    def self.lookup(annotations : ::Enumerable?, name : ::String)
      __var0 = LibGio.d_bus_annotation_info_lookup(annotations ? (__annotations_ary = annotations.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe : Pointer(Pointer(LibGio::DBusAnnotationInfo)).null, name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_annotation_info_lookup") if __var0.null?
      ::String.new(__var0)
    end

    def ref_count
      to_unsafe.as(LibGio::DBusAnnotationInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusAnnotationInfo*).value.ref_count = Int32.new(value)
    end

    def key
      ::String.new(to_unsafe.as(LibGio::DBusAnnotationInfo*).value.key)
    end

    def key=(value : ::String)
      to_unsafe.as(LibGio::DBusAnnotationInfo*).value.key = value.to_unsafe
    end

    def value
      ::String.new(to_unsafe.as(LibGio::DBusAnnotationInfo*).value.value)
    end

    def value=(value : ::String)
      to_unsafe.as(LibGio::DBusAnnotationInfo*).value.value = value.to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusAnnotationInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusAnnotationInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  class DBusArgInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, name : ::String? = nil, signature : ::String? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::DBusArgInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.name = name unless name.nil?
      __var0.signature = signature unless signature.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusArgInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusArgInfo*)
    end

    def to_unsafe_dbusarginfo
      @pointer.not_nil!.as(LibGio::DBusArgInfo*)
    end

    def ref
      __var0 = LibGio.d_bus_arg_info_ref(@pointer.as(LibGio::DBusArgInfo*))
      GObject.raise_unexpected_null("g_dbus_arg_info_ref") if __var0.null?
      Gio::DBusArgInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_arg_info_unref(@pointer.as(LibGio::DBusArgInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusArgInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusArgInfo*).value.ref_count = Int32.new(value)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::DBusArgInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::DBusArgInfo*).value.name = value.to_unsafe
    end

    def signature
      ::String.new(to_unsafe.as(LibGio::DBusArgInfo*).value.signature)
    end

    def signature=(value : ::String)
      to_unsafe.as(LibGio::DBusArgInfo*).value.signature = value.to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusArgInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusArgInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  class DBusAuthObserver < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::DBusAuthObserver*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusAuthObserver")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_auth_observer_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusAuthObserver*)
    end

    def to_unsafe_dbusauthobserver
      @pointer.not_nil!.as(LibGio::DBusAuthObserver*)
    end

    def self.new : self
      __var0 = LibGio.d_bus_auth_observer_new
      GObject.raise_unexpected_null("g_dbus_auth_observer_new") if __var0.null?
      cast(Gio::DBusAuthObserver.new(__var0))
    end

    def allow_mechanism(mechanism : ::String)
      __var0 = LibGio.d_bus_auth_observer_allow_mechanism(@pointer.as(LibGio::DBusAuthObserver*), mechanism.to_unsafe)
      (__var0 == 1)
    end

    def authorize_authenticated_peer(stream : Gio::IOStream, credentials : Gio::Credentials?)
      __var0 = LibGio.d_bus_auth_observer_authorize_authenticated_peer(@pointer.as(LibGio::DBusAuthObserver*), stream.to_unsafe_iostream, credentials ? credentials.to_unsafe_credentials : Pointer(LibGio::Credentials).null)
      (__var0 == 1)
    end

    alias AllowMechanismSignal = DBusAuthObserver, ::String -> ::Bool

    def on_allow_mechanism(*, after = false, &block : AllowMechanismSignal)
      __var0 = ->(arg0 : LibGio::DBusAuthObserver*, arg1 : Pointer(UInt8), box : Void*) {
        LibC::Int.new(::Box(AllowMechanismSignal).unbox(box).call(DBusAuthObserver.new(arg0), ::String.new(arg1)) ? 1 : 0)
      }

      __var1 = ::Box.box(AllowMechanismSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "allow-mechanism", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_allow_mechanism(&block : AllowMechanismSignal)
      on_allow_mechanism(after: true, &block)
    end

    alias AuthorizeAuthenticatedPeerSignal = DBusAuthObserver, Gio::IOStream, Gio::Credentials? -> ::Bool

    def on_authorize_authenticated_peer(*, after = false, &block : AuthorizeAuthenticatedPeerSignal)
      __var0 = ->(arg0 : LibGio::DBusAuthObserver*, arg1 : LibGio::IOStream*, arg2 : LibGio::Credentials*, box : Void*) {
        LibC::Int.new(::Box(AuthorizeAuthenticatedPeerSignal).unbox(box).call(DBusAuthObserver.new(arg0), arg1.null? ? GObject.raise_unexpected_null("stream in authorize_authenticated_peer") : Gio::IOStream.new(arg1), arg2.null? ? nil : Gio::Credentials.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(AuthorizeAuthenticatedPeerSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "authorize-authenticated-peer", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_authorize_authenticated_peer(&block : AuthorizeAuthenticatedPeerSignal)
      on_authorize_authenticated_peer(after: true, &block)
    end
  end

  @[Flags]
  enum DBusCallFlags : UInt32
    NONE                            = 0
    NO_AUTO_START                   = 1
    ALLOW_INTERACTIVE_AUTHORIZATION = 2
  end

  @[Flags]
  enum DBusCapabilityFlags : UInt32
    NONE            = 0
    UNIX_FD_PASSING = 1
  end

  class DBusConnection < GObject::Object
    include Gio::AsyncInitable
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::DBusConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusConnection*)
    end

    def to_unsafe_dbusconnection
      @pointer.not_nil!.as(LibGio::DBusConnection*)
    end

    def initialize(*, address : ::String? = nil, authentication_observer : Gio::DBusAuthObserver? = nil, exit_on_close : ::Bool? = nil, flags : Gio::DBusConnectionFlags? = nil, guid : ::String? = nil, stream : Gio::IOStream? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless address.nil?
        __var0 << "address".to_unsafe
        __var1 << address.to_gvalue.to_unsafe.value
      end

      unless authentication_observer.nil?
        __var0 << "authentication-observer".to_unsafe
        __var1 << authentication_observer.to_gvalue.to_unsafe.value
      end

      unless exit_on_close.nil?
        __var0 << "exit-on-close".to_unsafe
        __var1 << exit_on_close.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      unless guid.nil?
        __var0 << "guid".to_unsafe
        __var1 << guid.to_gvalue.to_unsafe.value
      end

      unless stream.nil?
        __var0 << "stream".to_unsafe
        __var1 << stream.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_connection_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_new_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_new_finish") if __var1.null?
      cast(Gio::DBusConnection.new(__var1))
    end

    def self.new_for_address_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_new_for_address_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_new_for_address_finish") if __var1.null?
      cast(Gio::DBusConnection.new(__var1))
    end

    def self.new_for_address_sync(address : ::String, flags : Gio::DBusConnectionFlags, observer : Gio::DBusAuthObserver?, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_new_for_address_sync(address.to_unsafe, flags, observer ? observer.to_unsafe_dbusauthobserver : Pointer(LibGio::DBusAuthObserver).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_new_for_address_sync") if __var1.null?
      cast(Gio::DBusConnection.new(__var1))
    end

    def self.new_sync(stream : Gio::IOStream, guid : ::String?, flags : Gio::DBusConnectionFlags, observer : Gio::DBusAuthObserver?, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_new_sync(stream.to_unsafe_iostream, guid ? guid.to_unsafe : Pointer(UInt8).null, flags, observer ? observer.to_unsafe_dbusauthobserver : Pointer(LibGio::DBusAuthObserver).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_new_sync") if __var1.null?
      cast(Gio::DBusConnection.new(__var1))
    end

    def self.new(stream : Gio::IOStream, guid : ::String?, flags : Gio::DBusConnectionFlags, observer : Gio::DBusAuthObserver?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_new(stream.to_unsafe_iostream, guid ? guid.to_unsafe : Pointer(UInt8).null, flags, observer ? observer.to_unsafe_dbusauthobserver : Pointer(LibGio::DBusAuthObserver).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def self.new_for_address(address : ::String, flags : Gio::DBusConnectionFlags, observer : Gio::DBusAuthObserver?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_new_for_address(address.to_unsafe, flags, observer ? observer.to_unsafe_dbusauthobserver : Pointer(LibGio::DBusAuthObserver).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def add_filter(filter_function : Gio::DBusMessageFilterFunction, user_data : Void*?, user_data_free_func : GLib::DestroyNotify)
      __var0 = LibGio.d_bus_connection_add_filter(@pointer.as(LibGio::DBusConnection*), filter_function, user_data ? user_data : Pointer(Void).null, user_data_free_func)
      __var0
    end

    def call(bus_name : ::String?, object_path : ::String, interface_name : ::String, method_name : ::String, parameters : GLib::Variant?, reply_type : GLib::VariantType?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_call(@pointer.as(LibGio::DBusConnection*), bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, reply_type ? reply_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null, flags, Int32.new(timeout_msec), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def call_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_call_finish(@pointer.as(LibGio::DBusConnection*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_call_finish") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_sync(bus_name : ::String?, object_path : ::String, interface_name : ::String, method_name : ::String, parameters : GLib::Variant?, reply_type : GLib::VariantType?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_call_sync(@pointer.as(LibGio::DBusConnection*), bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, reply_type ? reply_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null, flags, Int32.new(timeout_msec), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_call_sync") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_with_unix_fd_list(bus_name : ::String?, object_path : ::String, interface_name : ::String, method_name : ::String, parameters : GLib::Variant?, reply_type : GLib::VariantType?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, fd_list : Gio::UnixFDList?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_call_with_unix_fd_list(@pointer.as(LibGio::DBusConnection*), bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, reply_type ? reply_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null, flags, Int32.new(timeout_msec), fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def call_with_unix_fd_list_finish(out_fd_list : Gio::UnixFDList?, res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_call_with_unix_fd_list_finish(@pointer.as(LibGio::DBusConnection*), out_fd_list, res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_call_with_unix_fd_list_finish") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_with_unix_fd_list_sync(bus_name : ::String?, object_path : ::String, interface_name : ::String, method_name : ::String, parameters : GLib::Variant?, reply_type : GLib::VariantType?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, fd_list : Gio::UnixFDList?, out_fd_list : Gio::UnixFDList?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_call_with_unix_fd_list_sync(@pointer.as(LibGio::DBusConnection*), bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, reply_type ? reply_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null, flags, Int32.new(timeout_msec), fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null, out_fd_list, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_call_with_unix_fd_list_sync") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def close(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_close(@pointer.as(LibGio::DBusConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_close_finish(@pointer.as(LibGio::DBusConnection*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_sync(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_close_sync(@pointer.as(LibGio::DBusConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def emit_signal(destination_bus_name : ::String?, object_path : ::String, interface_name : ::String, signal_name : ::String, parameters : GLib::Variant?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_emit_signal(@pointer.as(LibGio::DBusConnection*), destination_bus_name ? destination_bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, signal_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def export_action_group(object_path : ::String, action_group : Gio::ActionGroup)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_export_action_group(@pointer.as(LibGio::DBusConnection*), object_path.to_unsafe, action_group.to_unsafe_actiongroup, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def export_menu_model(object_path : ::String, menu : Gio::MenuModel)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_export_menu_model(@pointer.as(LibGio::DBusConnection*), object_path.to_unsafe, menu.to_unsafe_menumodel, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def flush(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_flush(@pointer.as(LibGio::DBusConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def flush_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_flush_finish(@pointer.as(LibGio::DBusConnection*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def flush_sync(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_flush_sync(@pointer.as(LibGio::DBusConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def capabilities
      __var0 = LibGio.d_bus_connection_get_capabilities(@pointer.as(LibGio::DBusConnection*))
      Gio::DBusCapabilityFlags.new(__var0)
    end

    def exit_on_close
      __var0 = LibGio.d_bus_connection_get_exit_on_close(@pointer.as(LibGio::DBusConnection*))
      (__var0 == 1)
    end

    def flags
      __var0 = LibGio.d_bus_connection_get_flags(@pointer.as(LibGio::DBusConnection*))
      Gio::DBusConnectionFlags.new(__var0)
    end

    def guid
      __var0 = LibGio.d_bus_connection_get_guid(@pointer.as(LibGio::DBusConnection*))
      GObject.raise_unexpected_null("g_dbus_connection_get_guid") if __var0.null?
      ::String.new(__var0)
    end

    def last_serial
      __var0 = LibGio.d_bus_connection_get_last_serial(@pointer.as(LibGio::DBusConnection*))
      __var0
    end

    def peer_credentials
      __var0 = LibGio.d_bus_connection_get_peer_credentials(@pointer.as(LibGio::DBusConnection*))
      __var1 = Gio::Credentials.new(__var0) if __var0
      __var1
    end

    def stream
      __var0 = LibGio.d_bus_connection_get_stream(@pointer.as(LibGio::DBusConnection*))
      GObject.raise_unexpected_null("g_dbus_connection_get_stream") if __var0.null?
      Gio::IOStream.new(__var0)
    end

    def unique_name
      __var0 = LibGio.d_bus_connection_get_unique_name(@pointer.as(LibGio::DBusConnection*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def closed?
      __var0 = LibGio.d_bus_connection_is_closed(@pointer.as(LibGio::DBusConnection*))
      (__var0 == 1)
    end

    def register_object(object_path : ::String, interface_info : Gio::DBusInterfaceInfo, method_call_closure : GObject::Closure?, get_property_closure : GObject::Closure?, set_property_closure : GObject::Closure?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_register_object(@pointer.as(LibGio::DBusConnection*), object_path.to_unsafe, interface_info.to_unsafe.as(LibGio::DBusInterfaceInfo*), method_call_closure ? method_call_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, get_property_closure ? get_property_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, set_property_closure ? set_property_closure.to_unsafe.as(LibGObject::Closure*) : Pointer(LibGObject::Closure).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def register_subtree(object_path : ::String, vtable : Gio::DBusSubtreeVTable, flags : Gio::DBusSubtreeFlags, user_data : Void*?, user_data_free_func : GLib::DestroyNotify)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_register_subtree(@pointer.as(LibGio::DBusConnection*), object_path.to_unsafe, vtable.to_unsafe.as(LibGio::DBusSubtreeVTable*), flags, user_data ? user_data : Pointer(Void).null, user_data_free_func, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def remove_filter(filter_id : ::Int)
      LibGio.d_bus_connection_remove_filter(@pointer.as(LibGio::DBusConnection*), UInt32.new(filter_id))
      nil
    end

    def send_message(message : Gio::DBusMessage, flags : Gio::DBusSendMessageFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_send_message(@pointer.as(LibGio::DBusConnection*), message.to_unsafe_dbusmessage, flags, out out_serial, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), out_serial}
    end

    def send_message_with_reply(message : Gio::DBusMessage, flags : Gio::DBusSendMessageFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_connection_send_message_with_reply(@pointer.as(LibGio::DBusConnection*), message.to_unsafe_dbusmessage, flags, Int32.new(timeout_msec), out out_serial, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      out_serial
    end

    def send_message_with_reply_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_send_message_with_reply_finish(@pointer.as(LibGio::DBusConnection*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_send_message_with_reply_finish") if __var1.null?
      Gio::DBusMessage.new(__var1)
    end

    def send_message_with_reply_sync(message : Gio::DBusMessage, flags : Gio::DBusSendMessageFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_connection_send_message_with_reply_sync(@pointer.as(LibGio::DBusConnection*), message.to_unsafe_dbusmessage, flags, Int32.new(timeout_msec), out out_serial, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_connection_send_message_with_reply_sync") if __var1.null?
      {Gio::DBusMessage.new(__var1), out_serial}
    end

    def exit_on_close=(exit_on_close : ::Bool)
      LibGio.d_bus_connection_set_exit_on_close(@pointer.as(LibGio::DBusConnection*), LibC::Int.new(exit_on_close ? 1 : 0))
      nil
    end

    def signal_subscribe(sender : ::String?, interface_name : ::String?, member : ::String?, object_path : ::String?, arg0 : ::String?, flags : Gio::DBusSignalFlags, callback : Gio::DBusSignalCallback, user_data : Void*?, user_data_free_func : GLib::DestroyNotify?)
      __var0 = LibGio.d_bus_connection_signal_subscribe(@pointer.as(LibGio::DBusConnection*), sender ? sender.to_unsafe : Pointer(UInt8).null, interface_name ? interface_name.to_unsafe : Pointer(UInt8).null, member ? member.to_unsafe : Pointer(UInt8).null, object_path ? object_path.to_unsafe : Pointer(UInt8).null, arg0 ? arg0.to_unsafe : Pointer(UInt8).null, flags, callback, user_data ? user_data : Pointer(Void).null, user_data_free_func ? user_data_free_func : nil)
      __var0
    end

    def signal_unsubscribe(subscription_id : ::Int)
      LibGio.d_bus_connection_signal_unsubscribe(@pointer.as(LibGio::DBusConnection*), UInt32.new(subscription_id))
      nil
    end

    def start_message_processing
      LibGio.d_bus_connection_start_message_processing(@pointer.as(LibGio::DBusConnection*))
      nil
    end

    def unexport_action_group(export_id : ::Int)
      LibGio.d_bus_connection_unexport_action_group(@pointer.as(LibGio::DBusConnection*), UInt32.new(export_id))
      nil
    end

    def unexport_menu_model(export_id : ::Int)
      LibGio.d_bus_connection_unexport_menu_model(@pointer.as(LibGio::DBusConnection*), UInt32.new(export_id))
      nil
    end

    def unregister_object(registration_id : ::Int)
      __var0 = LibGio.d_bus_connection_unregister_object(@pointer.as(LibGio::DBusConnection*), UInt32.new(registration_id))
      (__var0 == 1)
    end

    def unregister_subtree(registration_id : ::Int)
      __var0 = LibGio.d_bus_connection_unregister_subtree(@pointer.as(LibGio::DBusConnection*), UInt32.new(registration_id))
      (__var0 == 1)
    end

    def closed : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "closed", __var0)
      __var0.boolean
    end

    alias ClosedSignal = DBusConnection, ::Bool, LibGLib::Error*? -> Nil

    def on_closed(*, after = false, &block : ClosedSignal)
      __var0 = ->(arg0 : LibGio::DBusConnection*, arg1 : LibC::Int, arg2 : Pointer(LibGLib::Error*), box : Void*) {
        ::Box(ClosedSignal).unbox(box).call(DBusConnection.new(arg0), (arg1 == 1), arg2)
      }

      __var1 = ::Box.box(ClosedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "closed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_closed(&block : ClosedSignal)
      on_closed(after: true, &block)
    end
  end

  @[Flags]
  enum DBusConnectionFlags : UInt32
    NONE                           =  0
    AUTHENTICATION_CLIENT          =  1
    AUTHENTICATION_SERVER          =  2
    AUTHENTICATION_ALLOW_ANONYMOUS =  4
    MESSAGE_BUS_CONNECTION         =  8
    DELAY_MESSAGE_PROCESSING       = 16
  end

  enum DBusError : UInt32
    FAILED                           =  0
    NO_MEMORY                        =  1
    SERVICE_UNKNOWN                  =  2
    NAME_HAS_NO_OWNER                =  3
    NO_REPLY                         =  4
    IO_ERROR                         =  5
    BAD_ADDRESS                      =  6
    NOT_SUPPORTED                    =  7
    LIMITS_EXCEEDED                  =  8
    ACCESS_DENIED                    =  9
    AUTH_FAILED                      = 10
    NO_SERVER                        = 11
    TIMEOUT                          = 12
    NO_NETWORK                       = 13
    ADDRESS_IN_USE                   = 14
    DISCONNECTED                     = 15
    INVALID_ARGS                     = 16
    FILE_NOT_FOUND                   = 17
    FILE_EXISTS                      = 18
    UNKNOWN_METHOD                   = 19
    TIMED_OUT                        = 20
    MATCH_RULE_NOT_FOUND             = 21
    MATCH_RULE_INVALID               = 22
    SPAWN_EXEC_FAILED                = 23
    SPAWN_FORK_FAILED                = 24
    SPAWN_CHILD_EXITED               = 25
    SPAWN_CHILD_SIGNALED             = 26
    SPAWN_FAILED                     = 27
    SPAWN_SETUP_FAILED               = 28
    SPAWN_CONFIG_INVALID             = 29
    SPAWN_SERVICE_INVALID            = 30
    SPAWN_SERVICE_NOT_FOUND          = 31
    SPAWN_PERMISSIONS_INVALID        = 32
    SPAWN_FILE_INVALID               = 33
    SPAWN_NO_MEMORY                  = 34
    UNIX_PROCESS_ID_UNKNOWN          = 35
    INVALID_SIGNATURE                = 36
    INVALID_FILE_CONTENT             = 37
    SELINUX_SECURITY_CONTEXT_UNKNOWN = 38
    ADT_AUDIT_DATA_UNKNOWN           = 39
    OBJECT_PATH_IN_USE               = 40
    UNKNOWN_OBJECT                   = 41
    UNKNOWN_INTERFACE                = 42
    UNKNOWN_PROPERTY                 = 43
    PROPERTY_READ_ONLY               = 44
  end

  # Function encode_gerror
  # Function get_remote_error
  # Function is_remote_error
  # Function new_for_dbus_error
  # Function quark
  # Function register_error
  # Function register_error_domain
  # Function strip_remote_error
  # Function unregister_error

  class DBusErrorEntry
    include GObject::WrappedType

    def self.new(error_code : Int32? = nil, dbus_error_name : ::String? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::DBusErrorEntry*))
      __var0.error_code = error_code unless error_code.nil?
      __var0.dbus_error_name = dbus_error_name unless dbus_error_name.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusErrorEntry*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusErrorEntry*)
    end

    def to_unsafe_dbuserrorentry
      @pointer.not_nil!.as(LibGio::DBusErrorEntry*)
    end

    def error_code
      to_unsafe.as(LibGio::DBusErrorEntry*).value.error_code
    end

    def error_code=(value : Int32)
      to_unsafe.as(LibGio::DBusErrorEntry*).value.error_code = Int32.new(value)
    end

    def dbus_error_name
      ::String.new(to_unsafe.as(LibGio::DBusErrorEntry*).value.dbus_error_name)
    end

    def dbus_error_name=(value : ::String)
      to_unsafe.as(LibGio::DBusErrorEntry*).value.dbus_error_name = value.to_unsafe
    end
  end

  module DBusInterface
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DBusInterface
      @pointer : Void*

      def initialize(pointer : LibGio::DBusInterface*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDBusInterface")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_interface_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DBusInterface*)
      end

      def to_unsafe_dbusinterface
        @pointer.not_nil!.as(LibGio::DBusInterface*)
      end
    end

    def to_unsafe_dbusinterface
      @pointer.not_nil!.as(LibGio::DBusInterface*)
    end

    def object
      __var0 = LibGio.d_bus_interface_get_object(@pointer.as(LibGio::DBusInterface*))
      GObject.raise_unexpected_null("g_dbus_interface_dup_object") if __var0.null?
      Gio::DBusObject::Wrapper.new(__var0)
    end

    def info
      __var0 = LibGio.d_bus_interface_get_info(@pointer.as(LibGio::DBusInterface*))
      GObject.raise_unexpected_null("g_dbus_interface_get_info") if __var0.null?
      Gio::DBusInterfaceInfo.new(__var0)
    end

    def object=(object : Gio::DBusObject?)
      LibGio.d_bus_interface_set_object(@pointer.as(LibGio::DBusInterface*), object ? object.to_unsafe_dbusobject : Pointer(LibGio::DBusObject).null)
      nil
    end
  end

  alias DBusInterfaceGetPropertyFunc = LibGio::DBusInterfaceGetPropertyFunc

  class DBusInterfaceIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::DBusInterfaceIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceIface*)
    end

    def to_unsafe_dbusinterfaceiface
      @pointer.not_nil!.as(LibGio::DBusInterfaceIface*)
    end

    def parent_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DBusInterfaceIface*).value.parent_iface)
    end

    def get_info
      to_unsafe.as(LibGio::DBusInterfaceIface*).value.get_info
    end

    def get_object
      to_unsafe.as(LibGio::DBusInterfaceIface*).value.get_object
    end

    def set_object
      to_unsafe.as(LibGio::DBusInterfaceIface*).value.set_object
    end

    def dup_object
      to_unsafe.as(LibGio::DBusInterfaceIface*).value.dup_object
    end
  end

  class DBusInterfaceInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, name : ::String? = nil, methods : ::Enumerable(Gio::DBusMethodInfo)? = nil, signals : ::Enumerable(Gio::DBusSignalInfo)? = nil, properties : ::Enumerable(Gio::DBusPropertyInfo)? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::DBusInterfaceInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.name = name unless name.nil?
      __var0.methods = methods unless methods.nil?
      __var0.signals = signals unless signals.nil?
      __var0.properties = properties unless properties.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceInfo*)
    end

    def to_unsafe_dbusinterfaceinfo
      @pointer.not_nil!.as(LibGio::DBusInterfaceInfo*)
    end

    def cache_build
      LibGio.d_bus_interface_info_cache_build(@pointer.as(LibGio::DBusInterfaceInfo*))
      nil
    end

    def cache_release
      LibGio.d_bus_interface_info_cache_release(@pointer.as(LibGio::DBusInterfaceInfo*))
      nil
    end

    def generate_xml(indent : ::Int, string_builder : GLib::String)
      LibGio.d_bus_interface_info_generate_xml(@pointer.as(LibGio::DBusInterfaceInfo*), UInt32.new(indent), string_builder.to_unsafe.as(LibGLib::String*))
      nil
    end

    def lookup_method(name : ::String)
      __var0 = LibGio.d_bus_interface_info_lookup_method(@pointer.as(LibGio::DBusInterfaceInfo*), name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_interface_info_lookup_method") if __var0.null?
      Gio::DBusMethodInfo.new(__var0)
    end

    def lookup_property(name : ::String)
      __var0 = LibGio.d_bus_interface_info_lookup_property(@pointer.as(LibGio::DBusInterfaceInfo*), name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_interface_info_lookup_property") if __var0.null?
      Gio::DBusPropertyInfo.new(__var0)
    end

    def lookup_signal(name : ::String)
      __var0 = LibGio.d_bus_interface_info_lookup_signal(@pointer.as(LibGio::DBusInterfaceInfo*), name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_interface_info_lookup_signal") if __var0.null?
      Gio::DBusSignalInfo.new(__var0)
    end

    def ref
      __var0 = LibGio.d_bus_interface_info_ref(@pointer.as(LibGio::DBusInterfaceInfo*))
      GObject.raise_unexpected_null("g_dbus_interface_info_ref") if __var0.null?
      Gio::DBusInterfaceInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_interface_info_unref(@pointer.as(LibGio::DBusInterfaceInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.ref_count = Int32.new(value)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::DBusInterfaceInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.name = value.to_unsafe
    end

    def methods
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceInfo*).value.methods) { |__var0|
        Gio::DBusMethodInfo.new(__var0)
      }
    end

    def methods=(value : ::Enumerable(Gio::DBusMethodInfo))
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.methods = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusMethodInfo*) }.to_a).to_unsafe
    end

    def signals
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceInfo*).value.signals) { |__var0|
        Gio::DBusSignalInfo.new(__var0)
      }
    end

    def signals=(value : ::Enumerable(Gio::DBusSignalInfo))
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.signals = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusSignalInfo*) }.to_a).to_unsafe
    end

    def properties
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceInfo*).value.properties) { |__var0|
        Gio::DBusPropertyInfo.new(__var0)
      }
    end

    def properties=(value : ::Enumerable(Gio::DBusPropertyInfo))
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.properties = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusPropertyInfo*) }.to_a).to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusInterfaceInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  alias DBusInterfaceMethodCallFunc = LibGio::DBusInterfaceMethodCallFunc
  alias DBusInterfaceSetPropertyFunc = LibGio::DBusInterfaceSetPropertyFunc

  class DBusInterfaceSkeleton < GObject::Object
    include Gio::DBusInterface

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceSkeleton*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusInterfaceSkeleton")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_interface_skeleton_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeleton*)
    end

    def to_unsafe_dbusinterfaceskeleton
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeleton*)
    end

    def export(connection : Gio::DBusConnection, object_path : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_interface_skeleton_export(@pointer.as(LibGio::DBusInterfaceSkeleton*), connection.to_unsafe_dbusconnection, object_path.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def flush
      LibGio.d_bus_interface_skeleton_flush(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      nil
    end

    def connection
      __var0 = LibGio.d_bus_interface_skeleton_get_connection(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      GObject.raise_unexpected_null("g_dbus_interface_skeleton_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def connections
      __var0 = LibGio.d_bus_interface_skeleton_get_connections(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      GObject.raise_unexpected_null("g_dbus_interface_skeleton_get_connections") if __var0.null?
      GLib::ListIterator(Gio::DBusConnection, LibGio::DBusConnection*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def flags
      __var0 = LibGio.d_bus_interface_skeleton_get_flags(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      Gio::DBusInterfaceSkeletonFlags.new(__var0)
    end

    def info
      __var0 = LibGio.d_bus_interface_skeleton_get_info(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      GObject.raise_unexpected_null("g_dbus_interface_skeleton_get_info") if __var0.null?
      Gio::DBusInterfaceInfo.new(__var0)
    end

    def object_path
      __var0 = LibGio.d_bus_interface_skeleton_get_object_path(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      GObject.raise_unexpected_null("g_dbus_interface_skeleton_get_object_path") if __var0.null?
      ::String.new(__var0)
    end

    def properties
      __var0 = LibGio.d_bus_interface_skeleton_get_properties(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      GObject.raise_unexpected_null("g_dbus_interface_skeleton_get_properties") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def has_connection(connection : Gio::DBusConnection)
      __var0 = LibGio.d_bus_interface_skeleton_has_connection(@pointer.as(LibGio::DBusInterfaceSkeleton*), connection.to_unsafe_dbusconnection)
      (__var0 == 1)
    end

    def flags=(flags : Gio::DBusInterfaceSkeletonFlags)
      LibGio.d_bus_interface_skeleton_set_flags(@pointer.as(LibGio::DBusInterfaceSkeleton*), flags)
      nil
    end

    def unexport
      LibGio.d_bus_interface_skeleton_unexport(@pointer.as(LibGio::DBusInterfaceSkeleton*))
      nil
    end

    def unexport_from_connection(connection : Gio::DBusConnection)
      LibGio.d_bus_interface_skeleton_unexport_from_connection(@pointer.as(LibGio::DBusInterfaceSkeleton*), connection.to_unsafe_dbusconnection)
      nil
    end

    def g_flags : Gio::DBusInterfaceSkeletonFlags
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-flags", __var0)
      Gio::DBusInterfaceSkeletonFlags.new(UInt32.new(__var0.flags))
    end

    def g_flags=(value : Gio::DBusInterfaceSkeletonFlags)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "g-flags", value.to_gvalue)
    end

    alias GAuthorizeMethodSignal = DBusInterfaceSkeleton, Gio::DBusMethodInvocation -> ::Bool

    def on_g_authorize_method(*, after = false, &block : GAuthorizeMethodSignal)
      __var0 = ->(arg0 : LibGio::DBusInterfaceSkeleton*, arg1 : LibGio::DBusMethodInvocation*, box : Void*) {
        LibC::Int.new(::Box(GAuthorizeMethodSignal).unbox(box).call(DBusInterfaceSkeleton.new(arg0), arg1.null? ? GObject.raise_unexpected_null("invocation in g_authorize_method") : Gio::DBusMethodInvocation.new(arg1)) ? 1 : 0)
      }

      __var1 = ::Box.box(GAuthorizeMethodSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "g-authorize-method", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_g_authorize_method(&block : GAuthorizeMethodSignal)
      on_g_authorize_method(after: true, &block)
    end
  end

  class DBusInterfaceSkeletonClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(304u64, 0u8).as(LibGio::DBusInterfaceSkeletonClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceSkeletonClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeletonClass*)
    end

    def to_unsafe_dbusinterfaceskeletonclass
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeletonClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.parent_class)
    end

    def get_info
      to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.get_info
    end

    def get_vtable
      to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.get_vtable
    end

    def get_properties
      to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.get_properties
    end

    def flush
      to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.flush
    end

    def vfunc_padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.vfunc_padding) { |__var0|
        __var0
      }
    end

    def g_authorize_method
      to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.g_authorize_method
    end

    def signal_padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceSkeletonClass*).value.signal_padding) { |__var0|
        __var0
      }
    end
  end

  @[Flags]
  enum DBusInterfaceSkeletonFlags : UInt32
    NONE                                = 0
    HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
  end

  class DBusInterfaceSkeletonPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceSkeletonPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeletonPrivate*)
    end

    def to_unsafe_dbusinterfaceskeletonprivate
      @pointer.not_nil!.as(LibGio::DBusInterfaceSkeletonPrivate*)
    end
  end

  class DBusInterfaceVTable
    include GObject::WrappedType

    def self.new(method_call : Gio::DBusInterfaceMethodCallFunc? = nil, get_property : Gio::DBusInterfaceGetPropertyFunc? = nil, set_property : Gio::DBusInterfaceSetPropertyFunc? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(88u64, 0u8).as(LibGio::DBusInterfaceVTable*))
      __var0.method_call = method_call unless method_call.nil?
      __var0.get_property = get_property unless get_property.nil?
      __var0.set_property = set_property unless set_property.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusInterfaceVTable*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusInterfaceVTable*)
    end

    def to_unsafe_dbusinterfacevtable
      @pointer.not_nil!.as(LibGio::DBusInterfaceVTable*)
    end

    def method_call
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.method_call
    end

    def method_call=(value : Gio::DBusInterfaceMethodCallFunc)
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.method_call = value
    end

    def get_property
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.get_property
    end

    def get_property=(value : Gio::DBusInterfaceGetPropertyFunc)
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.get_property = value
    end

    def set_property
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.set_property
    end

    def set_property=(value : Gio::DBusInterfaceSetPropertyFunc)
      to_unsafe.as(LibGio::DBusInterfaceVTable*).value.set_property = value
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusInterfaceVTable*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class MenuModel < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::MenuModel*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMenuModel")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_menu_model_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuModel*)
    end

    def to_unsafe_menumodel
      @pointer.not_nil!.as(LibGio::MenuModel*)
    end

    def item_attribute_value(item_index : ::Int, attribute : ::String, expected_type : GLib::VariantType?)
      __var0 = LibGio.menu_model_get_item_attribute_value(@pointer.as(LibGio::MenuModel*), Int32.new(item_index), attribute.to_unsafe, expected_type ? expected_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null)
      GObject.raise_unexpected_null("g_menu_model_get_item_attribute_value") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def item_link(item_index : ::Int, link : ::String)
      __var0 = LibGio.menu_model_get_item_link(@pointer.as(LibGio::MenuModel*), Int32.new(item_index), link.to_unsafe)
      GObject.raise_unexpected_null("g_menu_model_get_item_link") if __var0.null?
      Gio::MenuModel.new(__var0)
    end

    def n_items
      __var0 = LibGio.menu_model_get_n_items(@pointer.as(LibGio::MenuModel*))
      __var0
    end

    def mutable?
      __var0 = LibGio.menu_model_is_mutable(@pointer.as(LibGio::MenuModel*))
      (__var0 == 1)
    end

    def items_changed(position : ::Int, removed : ::Int, added : ::Int)
      LibGio.menu_model_items_changed(@pointer.as(LibGio::MenuModel*), Int32.new(position), Int32.new(removed), Int32.new(added))
      nil
    end

    def iterate_item_attributes(item_index : ::Int)
      __var0 = LibGio.menu_model_iterate_item_attributes(@pointer.as(LibGio::MenuModel*), Int32.new(item_index))
      GObject.raise_unexpected_null("g_menu_model_iterate_item_attributes") if __var0.null?
      Gio::MenuAttributeIter.new(__var0)
    end

    def iterate_item_links(item_index : ::Int)
      __var0 = LibGio.menu_model_iterate_item_links(@pointer.as(LibGio::MenuModel*), Int32.new(item_index))
      GObject.raise_unexpected_null("g_menu_model_iterate_item_links") if __var0.null?
      Gio::MenuLinkIter.new(__var0)
    end

    alias ItemsChangedSignal = MenuModel, Int32, Int32, Int32 -> Nil

    def on_items_changed(*, after = false, &block : ItemsChangedSignal)
      __var0 = ->(arg0 : LibGio::MenuModel*, arg1 : Int32, arg2 : Int32, arg3 : Int32, box : Void*) {
        ::Box(ItemsChangedSignal).unbox(box).call(MenuModel.new(arg0), arg1, arg2, arg3)
      }

      __var1 = ::Box.box(ItemsChangedSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "items-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_items_changed(&block : ItemsChangedSignal)
      on_items_changed(after: true, &block)
    end
  end

  class DBusMessage < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::DBusMessage*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusMessage")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_message_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusMessage*)
    end

    def to_unsafe_dbusmessage
      @pointer.not_nil!.as(LibGio::DBusMessage*)
    end

    def self.new : self
      __var0 = LibGio.d_bus_message_new
      GObject.raise_unexpected_null("g_dbus_message_new") if __var0.null?
      cast(Gio::DBusMessage.new(__var0))
    end

    def self.new_from_blob(blob : ::Bytes, capabilities : Gio::DBusCapabilityFlags) : self
      blob_len = blob.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_message_new_from_blob(blob.to_unsafe, UInt64.new(blob_len), capabilities, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_message_new_from_blob") if __var1.null?
      cast(Gio::DBusMessage.new(__var1))
    end

    def self.new_method_call(name : ::String?, path : ::String, interface_ : ::String?, method : ::String) : self
      __var0 = LibGio.d_bus_message_new_method_call(name ? name.to_unsafe : Pointer(UInt8).null, path.to_unsafe, interface_ ? interface_.to_unsafe : Pointer(UInt8).null, method.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_message_new_method_call") if __var0.null?
      cast(Gio::DBusMessage.new(__var0))
    end

    def self.new_signal(path : ::String, interface_ : ::String, signal : ::String) : self
      __var0 = LibGio.d_bus_message_new_signal(path.to_unsafe, interface_.to_unsafe, signal.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_message_new_signal") if __var0.null?
      cast(Gio::DBusMessage.new(__var0))
    end

    def self.bytes_needed(blob : ::Bytes)
      blob_len = blob.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_message_bytes_needed(blob.to_unsafe, UInt64.new(blob_len), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def copy
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_message_copy(@pointer.as(LibGio::DBusMessage*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_message_copy") if __var1.null?
      Gio::DBusMessage.new(__var1)
    end

    def arg0
      __var0 = LibGio.d_bus_message_get_arg0(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_arg0") if __var0.null?
      ::String.new(__var0)
    end

    def body
      __var0 = LibGio.d_bus_message_get_body(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_body") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def byte_order
      __var0 = LibGio.d_bus_message_get_byte_order(@pointer.as(LibGio::DBusMessage*))
      Gio::DBusMessageByteOrder.new(__var0)
    end

    def destination
      __var0 = LibGio.d_bus_message_get_destination(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_destination") if __var0.null?
      ::String.new(__var0)
    end

    def error_name
      __var0 = LibGio.d_bus_message_get_error_name(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_error_name") if __var0.null?
      ::String.new(__var0)
    end

    def flags
      __var0 = LibGio.d_bus_message_get_flags(@pointer.as(LibGio::DBusMessage*))
      Gio::DBusMessageFlags.new(__var0)
    end

    def header(header_field : Gio::DBusMessageHeaderField)
      __var0 = LibGio.d_bus_message_get_header(@pointer.as(LibGio::DBusMessage*), header_field)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def header_fields
      __var0 = LibGio.d_bus_message_get_header_fields(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_header_fields") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        __var1
      }
    end

    def interface
      __var0 = LibGio.d_bus_message_get_interface(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_interface") if __var0.null?
      ::String.new(__var0)
    end

    def locked
      __var0 = LibGio.d_bus_message_get_locked(@pointer.as(LibGio::DBusMessage*))
      (__var0 == 1)
    end

    def member
      __var0 = LibGio.d_bus_message_get_member(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_member") if __var0.null?
      ::String.new(__var0)
    end

    def message_type
      __var0 = LibGio.d_bus_message_get_message_type(@pointer.as(LibGio::DBusMessage*))
      Gio::DBusMessageType.new(__var0)
    end

    def num_unix_fds
      __var0 = LibGio.d_bus_message_get_num_unix_fds(@pointer.as(LibGio::DBusMessage*))
      __var0
    end

    def path
      __var0 = LibGio.d_bus_message_get_path(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_path") if __var0.null?
      ::String.new(__var0)
    end

    def reply_serial
      __var0 = LibGio.d_bus_message_get_reply_serial(@pointer.as(LibGio::DBusMessage*))
      __var0
    end

    def sender
      __var0 = LibGio.d_bus_message_get_sender(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_sender") if __var0.null?
      ::String.new(__var0)
    end

    def serial
      __var0 = LibGio.d_bus_message_get_serial(@pointer.as(LibGio::DBusMessage*))
      __var0
    end

    def signature
      __var0 = LibGio.d_bus_message_get_signature(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_signature") if __var0.null?
      ::String.new(__var0)
    end

    def unix_fd_list
      __var0 = LibGio.d_bus_message_get_unix_fd_list(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_get_unix_fd_list") if __var0.null?
      Gio::UnixFDList.new(__var0)
    end

    def lock
      LibGio.d_bus_message_lock(@pointer.as(LibGio::DBusMessage*))
      nil
    end

    def new_method_error_literal(error_name : ::String, error_message : ::String)
      __var0 = LibGio.d_bus_message_new_method_error_literal(@pointer.as(LibGio::DBusMessage*), error_name.to_unsafe, error_message.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_message_new_method_error_literal") if __var0.null?
      Gio::DBusMessage.new(__var0)
    end

    def new_method_reply
      __var0 = LibGio.d_bus_message_new_method_reply(@pointer.as(LibGio::DBusMessage*))
      GObject.raise_unexpected_null("g_dbus_message_new_method_reply") if __var0.null?
      Gio::DBusMessage.new(__var0)
    end

    def print(indent : ::Int)
      __var0 = LibGio.d_bus_message_print(@pointer.as(LibGio::DBusMessage*), UInt32.new(indent))
      GObject.raise_unexpected_null("g_dbus_message_print") if __var0.null?
      ::String.new(__var0)
    end

    def body=(body : GLib::Variant)
      LibGio.d_bus_message_set_body(@pointer.as(LibGio::DBusMessage*), body.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def byte_order=(byte_order : Gio::DBusMessageByteOrder)
      LibGio.d_bus_message_set_byte_order(@pointer.as(LibGio::DBusMessage*), byte_order)
      nil
    end

    def destination=(value : ::String)
      LibGio.d_bus_message_set_destination(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def error_name=(value : ::String)
      LibGio.d_bus_message_set_error_name(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def flags=(flags : Gio::DBusMessageFlags)
      LibGio.d_bus_message_set_flags(@pointer.as(LibGio::DBusMessage*), flags)
      nil
    end

    def set_header(header_field : Gio::DBusMessageHeaderField, value : GLib::Variant?)
      LibGio.d_bus_message_set_header(@pointer.as(LibGio::DBusMessage*), header_field, value ? value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def interface=(value : ::String)
      LibGio.d_bus_message_set_interface(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def member=(value : ::String)
      LibGio.d_bus_message_set_member(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def message_type=(type : Gio::DBusMessageType)
      LibGio.d_bus_message_set_message_type(@pointer.as(LibGio::DBusMessage*), type)
      nil
    end

    def num_unix_fds=(value : ::Int)
      LibGio.d_bus_message_set_num_unix_fds(@pointer.as(LibGio::DBusMessage*), UInt32.new(value))
      nil
    end

    def path=(value : ::String)
      LibGio.d_bus_message_set_path(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def reply_serial=(value : ::Int)
      LibGio.d_bus_message_set_reply_serial(@pointer.as(LibGio::DBusMessage*), UInt32.new(value))
      nil
    end

    def sender=(value : ::String)
      LibGio.d_bus_message_set_sender(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def serial=(serial : ::Int)
      LibGio.d_bus_message_set_serial(@pointer.as(LibGio::DBusMessage*), UInt32.new(serial))
      nil
    end

    def signature=(value : ::String)
      LibGio.d_bus_message_set_signature(@pointer.as(LibGio::DBusMessage*), value.to_unsafe)
      nil
    end

    def unix_fd_list=(fd_list : Gio::UnixFDList?)
      LibGio.d_bus_message_set_unix_fd_list(@pointer.as(LibGio::DBusMessage*), fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null)
      nil
    end

    def to_blob(capabilities : Gio::DBusCapabilityFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_message_to_blob(@pointer.as(LibGio::DBusMessage*), out out_size, capabilities, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_message_to_blob") if __var1.null?
      {GObject::PointerIterator.new(__var1) { |__var2|
        __var2
      }, out_size}
    end

    def to_gerror
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_message_to_gerror(@pointer.as(LibGio::DBusMessage*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  enum DBusMessageByteOrder : UInt32
    ZERO_NONE     =   0
    BIG_ENDIAN    =  66
    LITTLE_ENDIAN = 108
  end
  alias DBusMessageFilterFunction = LibGio::DBusMessageFilterFunction

  @[Flags]
  enum DBusMessageFlags : UInt32
    NONE                            = 0
    NO_REPLY_EXPECTED               = 1
    NO_AUTO_START                   = 2
    ALLOW_INTERACTIVE_AUTHORIZATION = 4
  end

  enum DBusMessageHeaderField : UInt32
    INVALID      = 0
    PATH         = 1
    INTERFACE    = 2
    MEMBER       = 3
    ERROR_NAME   = 4
    REPLY_SERIAL = 5
    DESTINATION  = 6
    SENDER       = 7
    SIGNATURE    = 8
    NUM_UNIX_FDS = 9
  end

  enum DBusMessageType : UInt32
    INVALID       = 0
    METHOD_CALL   = 1
    METHOD_RETURN = 2
    ERROR         = 3
    SIGNAL        = 4
  end

  class DBusMethodInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, name : ::String? = nil, in_args : ::Enumerable(Gio::DBusArgInfo)? = nil, out_args : ::Enumerable(Gio::DBusArgInfo)? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::DBusMethodInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.name = name unless name.nil?
      __var0.in_args = in_args unless in_args.nil?
      __var0.out_args = out_args unless out_args.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusMethodInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusMethodInfo*)
    end

    def to_unsafe_dbusmethodinfo
      @pointer.not_nil!.as(LibGio::DBusMethodInfo*)
    end

    def ref
      __var0 = LibGio.d_bus_method_info_ref(@pointer.as(LibGio::DBusMethodInfo*))
      GObject.raise_unexpected_null("g_dbus_method_info_ref") if __var0.null?
      Gio::DBusMethodInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_method_info_unref(@pointer.as(LibGio::DBusMethodInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusMethodInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusMethodInfo*).value.ref_count = Int32.new(value)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::DBusMethodInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::DBusMethodInfo*).value.name = value.to_unsafe
    end

    def in_args
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusMethodInfo*).value.in_args) { |__var0|
        Gio::DBusArgInfo.new(__var0)
      }
    end

    def in_args=(value : ::Enumerable(Gio::DBusArgInfo))
      to_unsafe.as(LibGio::DBusMethodInfo*).value.in_args = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusArgInfo*) }.to_a).to_unsafe
    end

    def out_args
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusMethodInfo*).value.out_args) { |__var0|
        Gio::DBusArgInfo.new(__var0)
      }
    end

    def out_args=(value : ::Enumerable(Gio::DBusArgInfo))
      to_unsafe.as(LibGio::DBusMethodInfo*).value.out_args = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusArgInfo*) }.to_a).to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusMethodInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusMethodInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  class DBusMethodInvocation < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::DBusMethodInvocation*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusMethodInvocation")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_method_invocation_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusMethodInvocation*)
    end

    def to_unsafe_dbusmethodinvocation
      @pointer.not_nil!.as(LibGio::DBusMethodInvocation*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_method_invocation_get_type, 0, nil, nil).as(Void*)
    end

    def connection
      __var0 = LibGio.d_bus_method_invocation_get_connection(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def interface_name
      __var0 = LibGio.d_bus_method_invocation_get_interface_name(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_interface_name") if __var0.null?
      ::String.new(__var0)
    end

    def message
      __var0 = LibGio.d_bus_method_invocation_get_message(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_message") if __var0.null?
      Gio::DBusMessage.new(__var0)
    end

    def method_info
      __var0 = LibGio.d_bus_method_invocation_get_method_info(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_method_info") if __var0.null?
      Gio::DBusMethodInfo.new(__var0)
    end

    def method_name
      __var0 = LibGio.d_bus_method_invocation_get_method_name(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_method_name") if __var0.null?
      ::String.new(__var0)
    end

    def object_path
      __var0 = LibGio.d_bus_method_invocation_get_object_path(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_object_path") if __var0.null?
      ::String.new(__var0)
    end

    def parameters
      __var0 = LibGio.d_bus_method_invocation_get_parameters(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_parameters") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def property_info
      __var0 = LibGio.d_bus_method_invocation_get_property_info(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_property_info") if __var0.null?
      Gio::DBusPropertyInfo.new(__var0)
    end

    def sender
      __var0 = LibGio.d_bus_method_invocation_get_sender(@pointer.as(LibGio::DBusMethodInvocation*))
      GObject.raise_unexpected_null("g_dbus_method_invocation_get_sender") if __var0.null?
      ::String.new(__var0)
    end

    def return_dbus_error(error_name : ::String, error_message : ::String)
      LibGio.d_bus_method_invocation_return_dbus_error(@pointer.as(LibGio::DBusMethodInvocation*), error_name.to_unsafe, error_message.to_unsafe)
      nil
    end

    def return_error_literal(domain : ::Int, code : ::Int, message : ::String)
      LibGio.d_bus_method_invocation_return_error_literal(@pointer.as(LibGio::DBusMethodInvocation*), UInt32.new(domain), Int32.new(code), message.to_unsafe)
      nil
    end

    def return_gerror(error : LibGLib::Error*)
      LibGio.d_bus_method_invocation_return_gerror(@pointer.as(LibGio::DBusMethodInvocation*), error)
      nil
    end

    def return_value(parameters : GLib::Variant?)
      LibGio.d_bus_method_invocation_return_value(@pointer.as(LibGio::DBusMethodInvocation*), parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def return_value_with_unix_fd_list(parameters : GLib::Variant?, fd_list : Gio::UnixFDList?)
      LibGio.d_bus_method_invocation_return_value_with_unix_fd_list(@pointer.as(LibGio::DBusMethodInvocation*), parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null)
      nil
    end
  end

  class DBusNodeInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, path : ::String? = nil, interfaces : ::Enumerable(Gio::DBusInterfaceInfo)? = nil, nodes : ::Enumerable(Gio::DBusNodeInfo)? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::DBusNodeInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.path = path unless path.nil?
      __var0.interfaces = interfaces unless interfaces.nil?
      __var0.nodes = nodes unless nodes.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusNodeInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusNodeInfo*)
    end

    def to_unsafe_dbusnodeinfo
      @pointer.not_nil!.as(LibGio::DBusNodeInfo*)
    end

    def self.new_for_xml(xml_data : ::String) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_node_info_new_for_xml(xml_data.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_node_info_new_for_xml") if __var1.null?
      cast(Gio::DBusNodeInfo.new(__var1))
    end

    def generate_xml(indent : ::Int, string_builder : GLib::String)
      LibGio.d_bus_node_info_generate_xml(@pointer.as(LibGio::DBusNodeInfo*), UInt32.new(indent), string_builder.to_unsafe.as(LibGLib::String*))
      nil
    end

    def lookup_interface(name : ::String)
      __var0 = LibGio.d_bus_node_info_lookup_interface(@pointer.as(LibGio::DBusNodeInfo*), name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_node_info_lookup_interface") if __var0.null?
      Gio::DBusInterfaceInfo.new(__var0)
    end

    def ref
      __var0 = LibGio.d_bus_node_info_ref(@pointer.as(LibGio::DBusNodeInfo*))
      GObject.raise_unexpected_null("g_dbus_node_info_ref") if __var0.null?
      Gio::DBusNodeInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_node_info_unref(@pointer.as(LibGio::DBusNodeInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusNodeInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusNodeInfo*).value.ref_count = Int32.new(value)
    end

    def path
      ::String.new(to_unsafe.as(LibGio::DBusNodeInfo*).value.path)
    end

    def path=(value : ::String)
      to_unsafe.as(LibGio::DBusNodeInfo*).value.path = value.to_unsafe
    end

    def interfaces
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusNodeInfo*).value.interfaces) { |__var0|
        Gio::DBusInterfaceInfo.new(__var0)
      }
    end

    def interfaces=(value : ::Enumerable(Gio::DBusInterfaceInfo))
      to_unsafe.as(LibGio::DBusNodeInfo*).value.interfaces = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusInterfaceInfo*) }.to_a).to_unsafe
    end

    def nodes
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusNodeInfo*).value.nodes) { |__var0|
        Gio::DBusNodeInfo.new(__var0)
      }
    end

    def nodes=(value : ::Enumerable(Gio::DBusNodeInfo))
      to_unsafe.as(LibGio::DBusNodeInfo*).value.nodes = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusNodeInfo*) }.to_a).to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusNodeInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusNodeInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  module DBusObject
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DBusObject
      @pointer : Void*

      def initialize(pointer : LibGio::DBusObject*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDBusObject")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DBusObject*)
      end

      def to_unsafe_dbusobject
        @pointer.not_nil!.as(LibGio::DBusObject*)
      end
    end

    def to_unsafe_dbusobject
      @pointer.not_nil!.as(LibGio::DBusObject*)
    end

    def interface(interface_name : ::String)
      __var0 = LibGio.d_bus_object_get_interface(@pointer.as(LibGio::DBusObject*), interface_name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_get_interface") if __var0.null?
      Gio::DBusInterface::Wrapper.new(__var0)
    end

    def interfaces
      __var0 = LibGio.d_bus_object_get_interfaces(@pointer.as(LibGio::DBusObject*))
      GObject.raise_unexpected_null("g_dbus_object_get_interfaces") if __var0.null?
      GLib::ListIterator(Gio::DBusInterface, LibGio::DBusInterface*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def object_path
      __var0 = LibGio.d_bus_object_get_object_path(@pointer.as(LibGio::DBusObject*))
      GObject.raise_unexpected_null("g_dbus_object_get_object_path") if __var0.null?
      ::String.new(__var0)
    end

    alias InterfaceAddedSignal = DBusObject, Gio::DBusInterface -> Nil

    def on_interface_added(*, after = false, &block : InterfaceAddedSignal)
      __var0 = ->(arg0 : LibGio::DBusObject*, arg1 : LibGio::DBusInterface*, box : Void*) {
        ::Box(InterfaceAddedSignal).unbox(box).call(DBusObject::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("interface in interface_added") : Gio::DBusInterface::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(InterfaceAddedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_added(&block : InterfaceAddedSignal)
      on_interface_added(after: true, &block)
    end

    alias InterfaceRemovedSignal = DBusObject, Gio::DBusInterface -> Nil

    def on_interface_removed(*, after = false, &block : InterfaceRemovedSignal)
      __var0 = ->(arg0 : LibGio::DBusObject*, arg1 : LibGio::DBusInterface*, box : Void*) {
        ::Box(InterfaceRemovedSignal).unbox(box).call(DBusObject::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("interface in interface_removed") : Gio::DBusInterface::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(InterfaceRemovedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_removed(&block : InterfaceRemovedSignal)
      on_interface_removed(after: true, &block)
    end
  end

  class DBusObjectIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::DBusObjectIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectIface*)
    end

    def to_unsafe_dbusobjectiface
      @pointer.not_nil!.as(LibGio::DBusObjectIface*)
    end

    def parent_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DBusObjectIface*).value.parent_iface)
    end

    def get_object_path
      to_unsafe.as(LibGio::DBusObjectIface*).value.get_object_path
    end

    def get_interfaces
      to_unsafe.as(LibGio::DBusObjectIface*).value.get_interfaces
    end

    def get_interface
      to_unsafe.as(LibGio::DBusObjectIface*).value.get_interface
    end

    def interface_added
      to_unsafe.as(LibGio::DBusObjectIface*).value.interface_added
    end

    def interface_removed
      to_unsafe.as(LibGio::DBusObjectIface*).value.interface_removed
    end
  end

  module DBusObjectManager
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DBusObjectManager
      @pointer : Void*

      def initialize(pointer : LibGio::DBusObjectManager*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDBusObjectManager")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_manager_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DBusObjectManager*)
      end

      def to_unsafe_dbusobjectmanager
        @pointer.not_nil!.as(LibGio::DBusObjectManager*)
      end
    end

    def to_unsafe_dbusobjectmanager
      @pointer.not_nil!.as(LibGio::DBusObjectManager*)
    end

    def interface(object_path : ::String, interface_name : ::String)
      __var0 = LibGio.d_bus_object_manager_get_interface(@pointer.as(LibGio::DBusObjectManager*), object_path.to_unsafe, interface_name.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_manager_get_interface") if __var0.null?
      Gio::DBusInterface::Wrapper.new(__var0)
    end

    def object(object_path : ::String)
      __var0 = LibGio.d_bus_object_manager_get_object(@pointer.as(LibGio::DBusObjectManager*), object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_manager_get_object") if __var0.null?
      Gio::DBusObject::Wrapper.new(__var0)
    end

    def object_path
      __var0 = LibGio.d_bus_object_manager_get_object_path(@pointer.as(LibGio::DBusObjectManager*))
      GObject.raise_unexpected_null("g_dbus_object_manager_get_object_path") if __var0.null?
      ::String.new(__var0)
    end

    def objects
      __var0 = LibGio.d_bus_object_manager_get_objects(@pointer.as(LibGio::DBusObjectManager*))
      GObject.raise_unexpected_null("g_dbus_object_manager_get_objects") if __var0.null?
      GLib::ListIterator(Gio::DBusObject, LibGio::DBusObject*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    alias InterfaceAddedSignal = DBusObjectManager, Gio::DBusObject, Gio::DBusInterface -> Nil

    def on_interface_added(*, after = false, &block : InterfaceAddedSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManager*, arg1 : LibGio::DBusObject*, arg2 : LibGio::DBusInterface*, box : Void*) {
        ::Box(InterfaceAddedSignal).unbox(box).call(DBusObjectManager::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object in interface_added") : Gio::DBusObject::Wrapper.new(arg1), arg2.null? ? GObject.raise_unexpected_null("interface in interface_added") : Gio::DBusInterface::Wrapper.new(arg2))
      }

      __var1 = ::Box.box(InterfaceAddedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_added(&block : InterfaceAddedSignal)
      on_interface_added(after: true, &block)
    end

    alias InterfaceRemovedSignal = DBusObjectManager, Gio::DBusObject, Gio::DBusInterface -> Nil

    def on_interface_removed(*, after = false, &block : InterfaceRemovedSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManager*, arg1 : LibGio::DBusObject*, arg2 : LibGio::DBusInterface*, box : Void*) {
        ::Box(InterfaceRemovedSignal).unbox(box).call(DBusObjectManager::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object in interface_removed") : Gio::DBusObject::Wrapper.new(arg1), arg2.null? ? GObject.raise_unexpected_null("interface in interface_removed") : Gio::DBusInterface::Wrapper.new(arg2))
      }

      __var1 = ::Box.box(InterfaceRemovedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_removed(&block : InterfaceRemovedSignal)
      on_interface_removed(after: true, &block)
    end

    alias ObjectAddedSignal = DBusObjectManager, Gio::DBusObject -> Nil

    def on_object_added(*, after = false, &block : ObjectAddedSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManager*, arg1 : LibGio::DBusObject*, box : Void*) {
        ::Box(ObjectAddedSignal).unbox(box).call(DBusObjectManager::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object in object_added") : Gio::DBusObject::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(ObjectAddedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "object-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_object_added(&block : ObjectAddedSignal)
      on_object_added(after: true, &block)
    end

    alias ObjectRemovedSignal = DBusObjectManager, Gio::DBusObject -> Nil

    def on_object_removed(*, after = false, &block : ObjectRemovedSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManager*, arg1 : LibGio::DBusObject*, box : Void*) {
        ::Box(ObjectRemovedSignal).unbox(box).call(DBusObjectManager::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object in object_removed") : Gio::DBusObject::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(ObjectRemovedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "object-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_object_removed(&block : ObjectRemovedSignal)
      on_object_removed(after: true, &block)
    end
  end

  class DBusObjectManagerClient < GObject::Object
    include Gio::AsyncInitable
    include Gio::DBusObjectManager
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerClient*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusObjectManagerClient")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_manager_client_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClient*)
    end

    def to_unsafe_dbusobjectmanagerclient
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClient*)
    end

    def initialize(*, bus_type : Gio::BusType? = nil, connection : Gio::DBusConnection? = nil, flags : Gio::DBusObjectManagerClientFlags? = nil, get_proxy_type_destroy_notify : Void*? = nil, get_proxy_type_func : Void*? = nil, get_proxy_type_user_data : Void*? = nil, name : ::String? = nil, object_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless bus_type.nil?
        __var0 << "bus-type".to_unsafe
        __var1 << bus_type.to_gvalue.to_unsafe.value
      end

      unless connection.nil?
        __var0 << "connection".to_unsafe
        __var1 << connection.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      unless get_proxy_type_destroy_notify.nil?
        __var0 << "get-proxy-type-destroy-notify".to_unsafe
        __var1 << get_proxy_type_destroy_notify.to_gvalue.to_unsafe.value
      end

      unless get_proxy_type_func.nil?
        __var0 << "get-proxy-type-func".to_unsafe
        __var1 << get_proxy_type_func.to_gvalue.to_unsafe.value
      end

      unless get_proxy_type_user_data.nil?
        __var0 << "get-proxy-type-user-data".to_unsafe
        __var1 << get_proxy_type_user_data.to_gvalue.to_unsafe.value
      end

      unless name.nil?
        __var0 << "name".to_unsafe
        __var1 << name.to_gvalue.to_unsafe.value
      end

      unless object_path.nil?
        __var0 << "object-path".to_unsafe
        __var1 << object_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_object_manager_client_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_object_manager_client_new_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_object_manager_client_new_finish") if __var1.null?
      cast(Gio::DBusObjectManagerClient.new(__var1))
    end

    def self.new_for_bus_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_object_manager_client_new_for_bus_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_object_manager_client_new_for_bus_finish") if __var1.null?
      cast(Gio::DBusObjectManagerClient.new(__var1))
    end

    def self.new_for_bus_sync(bus_type : Gio::BusType, flags : Gio::DBusObjectManagerClientFlags, name : ::String, object_path : ::String, get_proxy_type_func : Gio::DBusProxyTypeFunc?, get_proxy_type_user_data : Void*?, get_proxy_type_destroy_notify : GLib::DestroyNotify?, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_object_manager_client_new_for_bus_sync(bus_type, flags, name.to_unsafe, object_path.to_unsafe, get_proxy_type_func ? get_proxy_type_func : nil, get_proxy_type_user_data ? get_proxy_type_user_data : Pointer(Void).null, get_proxy_type_destroy_notify ? get_proxy_type_destroy_notify : nil, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_object_manager_client_new_for_bus_sync") if __var1.null?
      cast(Gio::DBusObjectManagerClient.new(__var1))
    end

    def self.new_sync(connection : Gio::DBusConnection, flags : Gio::DBusObjectManagerClientFlags, name : ::String?, object_path : ::String, get_proxy_type_func : Gio::DBusProxyTypeFunc?, get_proxy_type_user_data : Void*?, get_proxy_type_destroy_notify : GLib::DestroyNotify?, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_object_manager_client_new_sync(connection.to_unsafe_dbusconnection, flags, name ? name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, get_proxy_type_func ? get_proxy_type_func : nil, get_proxy_type_user_data ? get_proxy_type_user_data : Pointer(Void).null, get_proxy_type_destroy_notify ? get_proxy_type_destroy_notify : nil, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_object_manager_client_new_sync") if __var1.null?
      cast(Gio::DBusObjectManagerClient.new(__var1))
    end

    def self.new(connection : Gio::DBusConnection, flags : Gio::DBusObjectManagerClientFlags, name : ::String, object_path : ::String, get_proxy_type_func : Gio::DBusProxyTypeFunc?, get_proxy_type_user_data : Void*?, get_proxy_type_destroy_notify : GLib::DestroyNotify?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_object_manager_client_new(connection.to_unsafe_dbusconnection, flags, name.to_unsafe, object_path.to_unsafe, get_proxy_type_func ? get_proxy_type_func : nil, get_proxy_type_user_data ? get_proxy_type_user_data : Pointer(Void).null, get_proxy_type_destroy_notify ? get_proxy_type_destroy_notify : nil, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def self.new_for_bus(bus_type : Gio::BusType, flags : Gio::DBusObjectManagerClientFlags, name : ::String, object_path : ::String, get_proxy_type_func : Gio::DBusProxyTypeFunc?, get_proxy_type_user_data : Void*?, get_proxy_type_destroy_notify : GLib::DestroyNotify?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_object_manager_client_new_for_bus(bus_type, flags, name.to_unsafe, object_path.to_unsafe, get_proxy_type_func ? get_proxy_type_func : nil, get_proxy_type_user_data ? get_proxy_type_user_data : Pointer(Void).null, get_proxy_type_destroy_notify ? get_proxy_type_destroy_notify : nil, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connection
      __var0 = LibGio.d_bus_object_manager_client_get_connection(@pointer.as(LibGio::DBusObjectManagerClient*))
      GObject.raise_unexpected_null("g_dbus_object_manager_client_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def flags
      __var0 = LibGio.d_bus_object_manager_client_get_flags(@pointer.as(LibGio::DBusObjectManagerClient*))
      Gio::DBusObjectManagerClientFlags.new(__var0)
    end

    def name
      __var0 = LibGio.d_bus_object_manager_client_get_name(@pointer.as(LibGio::DBusObjectManagerClient*))
      GObject.raise_unexpected_null("g_dbus_object_manager_client_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def name_owner
      __var0 = LibGio.d_bus_object_manager_client_get_name_owner(@pointer.as(LibGio::DBusObjectManagerClient*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def get_proxy_type_destroy_notify : Void*
      __var0 = GObject::Value.new(type: GObject::Type::VOID)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "get-proxy-type-destroy-notify", __var0)
      __var0
    end

    def get_proxy_type_func : Void*
      __var0 = GObject::Value.new(type: GObject::Type::VOID)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "get-proxy-type-func", __var0)
      __var0
    end

    def get_proxy_type_user_data : Void*
      __var0 = GObject::Value.new(type: GObject::Type::VOID)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "get-proxy-type-user-data", __var0)
      __var0
    end

    def object_path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "object-path", __var0)
      __var0.string
    end

    alias InterfaceProxyPropertiesChangedSignal = DBusObjectManagerClient, Gio::DBusObjectProxy, Gio::DBusProxy, GLib::Variant, ::Enumerable(::String) -> Nil

    def on_interface_proxy_properties_changed(*, after = false, &block : InterfaceProxyPropertiesChangedSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManagerClient*, arg1 : LibGio::DBusObjectProxy*, arg2 : LibGio::DBusProxy*, arg3 : LibGLib::Variant*, arg4 : Pointer(Pointer(UInt8)), box : Void*) {
        ::Box(InterfaceProxyPropertiesChangedSignal).unbox(box).call(DBusObjectManagerClient.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object_proxy in interface_proxy_properties_changed") : Gio::DBusObjectProxy.new(arg1), arg2.null? ? GObject.raise_unexpected_null("interface_proxy in interface_proxy_properties_changed") : Gio::DBusProxy.new(arg2), arg3.null? ? GObject.raise_unexpected_null("changed_properties in interface_proxy_properties_changed") : GLib::Variant.new(arg3), GObject::PointerIterator.new(arg4) { |__var1|
          ::String.new(__var1)
        })
      }

      __var1 = ::Box.box(InterfaceProxyPropertiesChangedSignal.new { |arg0, arg1, arg2, arg3, arg4|
        block.call(arg0, arg1, arg2, arg3, arg4)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-proxy-properties-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_proxy_properties_changed(&block : InterfaceProxyPropertiesChangedSignal)
      on_interface_proxy_properties_changed(after: true, &block)
    end

    alias InterfaceProxySignalSignal = DBusObjectManagerClient, Gio::DBusObjectProxy, Gio::DBusProxy, ::String, ::String, GLib::Variant -> Nil

    def on_interface_proxy_signal(*, after = false, &block : InterfaceProxySignalSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectManagerClient*, arg1 : LibGio::DBusObjectProxy*, arg2 : LibGio::DBusProxy*, arg3 : Pointer(UInt8), arg4 : Pointer(UInt8), arg5 : LibGLib::Variant*, box : Void*) {
        ::Box(InterfaceProxySignalSignal).unbox(box).call(DBusObjectManagerClient.new(arg0), arg1.null? ? GObject.raise_unexpected_null("object_proxy in interface_proxy_signal") : Gio::DBusObjectProxy.new(arg1), arg2.null? ? GObject.raise_unexpected_null("interface_proxy in interface_proxy_signal") : Gio::DBusProxy.new(arg2), ::String.new(arg3), ::String.new(arg4), arg5.null? ? GObject.raise_unexpected_null("parameters in interface_proxy_signal") : GLib::Variant.new(arg5))
      }

      __var1 = ::Box.box(InterfaceProxySignalSignal.new { |arg0, arg1, arg2, arg3, arg4, arg5|
        block.call(arg0, arg1, arg2, arg3, arg4, arg5)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "interface-proxy-signal", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_interface_proxy_signal(&block : InterfaceProxySignalSignal)
      on_interface_proxy_signal(after: true, &block)
    end
  end

  class DBusObjectManagerClientClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(216u64, 0u8).as(LibGio::DBusObjectManagerClientClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerClientClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClientClass*)
    end

    def to_unsafe_dbusobjectmanagerclientclass
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClientClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusObjectManagerClientClass*).value.parent_class)
    end

    def interface_proxy_signal
      to_unsafe.as(LibGio::DBusObjectManagerClientClass*).value.interface_proxy_signal
    end

    def interface_proxy_properties_changed
      to_unsafe.as(LibGio::DBusObjectManagerClientClass*).value.interface_proxy_properties_changed
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusObjectManagerClientClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  @[Flags]
  enum DBusObjectManagerClientFlags : UInt32
    NONE              = 0
    DO_NOT_AUTO_START = 1
  end

  class DBusObjectManagerClientPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerClientPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClientPrivate*)
    end

    def to_unsafe_dbusobjectmanagerclientprivate
      @pointer.not_nil!.as(LibGio::DBusObjectManagerClientPrivate*)
    end
  end

  class DBusObjectManagerIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(80u64, 0u8).as(LibGio::DBusObjectManagerIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerIface*)
    end

    def to_unsafe_dbusobjectmanageriface
      @pointer.not_nil!.as(LibGio::DBusObjectManagerIface*)
    end

    def parent_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DBusObjectManagerIface*).value.parent_iface)
    end

    def get_object_path
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.get_object_path
    end

    def get_objects
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.get_objects
    end

    def get_object
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.get_object
    end

    def get_interface
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.get_interface
    end

    def object_added
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.object_added
    end

    def object_removed
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.object_removed
    end

    def interface_added
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.interface_added
    end

    def interface_removed
      to_unsafe.as(LibGio::DBusObjectManagerIface*).value.interface_removed
    end
  end

  class DBusObjectManagerServer < GObject::Object
    include Gio::DBusObjectManager

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerServer*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusObjectManagerServer")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_manager_server_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServer*)
    end

    def to_unsafe_dbusobjectmanagerserver
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServer*)
    end

    def initialize(*, connection : Gio::DBusConnection? = nil, object_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless connection.nil?
        __var0 << "connection".to_unsafe
        __var1 << connection.to_gvalue.to_unsafe.value
      end

      unless object_path.nil?
        __var0 << "object-path".to_unsafe
        __var1 << object_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_object_manager_server_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(object_path : ::String) : self
      __var0 = LibGio.d_bus_object_manager_server_new(object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_manager_server_new") if __var0.null?
      cast(Gio::DBusObjectManagerServer.new(__var0))
    end

    def export(object : Gio::DBusObjectSkeleton)
      LibGio.d_bus_object_manager_server_export(@pointer.as(LibGio::DBusObjectManagerServer*), object.to_unsafe_dbusobjectskeleton)
      nil
    end

    def export_uniquely(object : Gio::DBusObjectSkeleton)
      LibGio.d_bus_object_manager_server_export_uniquely(@pointer.as(LibGio::DBusObjectManagerServer*), object.to_unsafe_dbusobjectskeleton)
      nil
    end

    def connection
      __var0 = LibGio.d_bus_object_manager_server_get_connection(@pointer.as(LibGio::DBusObjectManagerServer*))
      GObject.raise_unexpected_null("g_dbus_object_manager_server_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def exported?(object : Gio::DBusObjectSkeleton)
      __var0 = LibGio.d_bus_object_manager_server_is_exported(@pointer.as(LibGio::DBusObjectManagerServer*), object.to_unsafe_dbusobjectskeleton)
      (__var0 == 1)
    end

    def connection=(connection : Gio::DBusConnection?)
      LibGio.d_bus_object_manager_server_set_connection(@pointer.as(LibGio::DBusObjectManagerServer*), connection ? connection.to_unsafe_dbusconnection : Pointer(LibGio::DBusConnection).null)
      nil
    end

    def unexport(object_path : ::String)
      __var0 = LibGio.d_bus_object_manager_server_unexport(@pointer.as(LibGio::DBusObjectManagerServer*), object_path.to_unsafe)
      (__var0 == 1)
    end

    def object_path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "object-path", __var0)
      __var0.string
    end
  end

  class DBusObjectManagerServerClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(200u64, 0u8).as(LibGio::DBusObjectManagerServerClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerServerClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServerClass*)
    end

    def to_unsafe_dbusobjectmanagerserverclass
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServerClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusObjectManagerServerClass*).value.parent_class)
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusObjectManagerServerClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class DBusObjectManagerServerPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectManagerServerPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServerPrivate*)
    end

    def to_unsafe_dbusobjectmanagerserverprivate
      @pointer.not_nil!.as(LibGio::DBusObjectManagerServerPrivate*)
    end
  end

  class DBusObjectProxy < GObject::Object
    include Gio::DBusObject

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectProxy*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusObjectProxy")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_proxy_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectProxy*)
    end

    def to_unsafe_dbusobjectproxy
      @pointer.not_nil!.as(LibGio::DBusObjectProxy*)
    end

    def initialize(*, g_connection : Gio::DBusConnection? = nil, g_object_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless g_connection.nil?
        __var0 << "g-connection".to_unsafe
        __var1 << g_connection.to_gvalue.to_unsafe.value
      end

      unless g_object_path.nil?
        __var0 << "g-object-path".to_unsafe
        __var1 << g_object_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_object_proxy_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(connection : Gio::DBusConnection, object_path : ::String) : self
      __var0 = LibGio.d_bus_object_proxy_new(connection.to_unsafe_dbusconnection, object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_proxy_new") if __var0.null?
      cast(Gio::DBusObjectProxy.new(__var0))
    end

    def connection
      __var0 = LibGio.d_bus_object_proxy_get_connection(@pointer.as(LibGio::DBusObjectProxy*))
      GObject.raise_unexpected_null("g_dbus_object_proxy_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def g_connection : Gio::DBusConnection
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-connection", __var0)
      Gio::DBusConnection.cast(__var0.object)
    end

    def g_object_path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-object-path", __var0)
      __var0.string
    end
  end

  class DBusObjectProxyClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(200u64, 0u8).as(LibGio::DBusObjectProxyClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectProxyClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectProxyClass*)
    end

    def to_unsafe_dbusobjectproxyclass
      @pointer.not_nil!.as(LibGio::DBusObjectProxyClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusObjectProxyClass*).value.parent_class)
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusObjectProxyClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class DBusObjectProxyPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectProxyPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectProxyPrivate*)
    end

    def to_unsafe_dbusobjectproxyprivate
      @pointer.not_nil!.as(LibGio::DBusObjectProxyPrivate*)
    end
  end

  class DBusObjectSkeleton < GObject::Object
    include Gio::DBusObject

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectSkeleton*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusObjectSkeleton")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_object_skeleton_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectSkeleton*)
    end

    def to_unsafe_dbusobjectskeleton
      @pointer.not_nil!.as(LibGio::DBusObjectSkeleton*)
    end

    def initialize(*, g_object_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless g_object_path.nil?
        __var0 << "g-object-path".to_unsafe
        __var1 << g_object_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_object_skeleton_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(object_path : ::String) : self
      __var0 = LibGio.d_bus_object_skeleton_new(object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_object_skeleton_new") if __var0.null?
      cast(Gio::DBusObjectSkeleton.new(__var0))
    end

    def add_interface(interface_ : Gio::DBusInterfaceSkeleton)
      LibGio.d_bus_object_skeleton_add_interface(@pointer.as(LibGio::DBusObjectSkeleton*), interface_.to_unsafe_dbusinterfaceskeleton)
      nil
    end

    def flush
      LibGio.d_bus_object_skeleton_flush(@pointer.as(LibGio::DBusObjectSkeleton*))
      nil
    end

    def remove_interface(interface_ : Gio::DBusInterfaceSkeleton)
      LibGio.d_bus_object_skeleton_remove_interface(@pointer.as(LibGio::DBusObjectSkeleton*), interface_.to_unsafe_dbusinterfaceskeleton)
      nil
    end

    def remove_interface_by_name(interface_name : ::String)
      LibGio.d_bus_object_skeleton_remove_interface_by_name(@pointer.as(LibGio::DBusObjectSkeleton*), interface_name.to_unsafe)
      nil
    end

    def object_path=(object_path : ::String)
      LibGio.d_bus_object_skeleton_set_object_path(@pointer.as(LibGio::DBusObjectSkeleton*), object_path.to_unsafe)
      nil
    end

    def g_object_path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-object-path", __var0)
      __var0.string
    end

    def g_object_path=(value : ::String)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "g-object-path", value.to_gvalue)
    end

    alias AuthorizeMethodSignal = DBusObjectSkeleton, Gio::DBusInterfaceSkeleton, Gio::DBusMethodInvocation -> ::Bool

    def on_authorize_method(*, after = false, &block : AuthorizeMethodSignal)
      __var0 = ->(arg0 : LibGio::DBusObjectSkeleton*, arg1 : LibGio::DBusInterfaceSkeleton*, arg2 : LibGio::DBusMethodInvocation*, box : Void*) {
        LibC::Int.new(::Box(AuthorizeMethodSignal).unbox(box).call(DBusObjectSkeleton.new(arg0), arg1.null? ? GObject.raise_unexpected_null("interface in authorize_method") : Gio::DBusInterfaceSkeleton.new(arg1), arg2.null? ? GObject.raise_unexpected_null("invocation in authorize_method") : Gio::DBusMethodInvocation.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(AuthorizeMethodSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "authorize-method", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_authorize_method(&block : AuthorizeMethodSignal)
      on_authorize_method(after: true, &block)
    end
  end

  class DBusObjectSkeletonClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(208u64, 0u8).as(LibGio::DBusObjectSkeletonClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectSkeletonClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectSkeletonClass*)
    end

    def to_unsafe_dbusobjectskeletonclass
      @pointer.not_nil!.as(LibGio::DBusObjectSkeletonClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusObjectSkeletonClass*).value.parent_class)
    end

    def authorize_method
      to_unsafe.as(LibGio::DBusObjectSkeletonClass*).value.authorize_method
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusObjectSkeletonClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class DBusObjectSkeletonPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusObjectSkeletonPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusObjectSkeletonPrivate*)
    end

    def to_unsafe_dbusobjectskeletonprivate
      @pointer.not_nil!.as(LibGio::DBusObjectSkeletonPrivate*)
    end
  end

  class DBusPropertyInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, name : ::String? = nil, signature : ::String? = nil, flags : Gio::DBusPropertyInfoFlags? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::DBusPropertyInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.name = name unless name.nil?
      __var0.signature = signature unless signature.nil?
      __var0.flags = flags unless flags.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusPropertyInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusPropertyInfo*)
    end

    def to_unsafe_dbuspropertyinfo
      @pointer.not_nil!.as(LibGio::DBusPropertyInfo*)
    end

    def ref
      __var0 = LibGio.d_bus_property_info_ref(@pointer.as(LibGio::DBusPropertyInfo*))
      GObject.raise_unexpected_null("g_dbus_property_info_ref") if __var0.null?
      Gio::DBusPropertyInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_property_info_unref(@pointer.as(LibGio::DBusPropertyInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.ref_count = Int32.new(value)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::DBusPropertyInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.name = value.to_unsafe
    end

    def signature
      ::String.new(to_unsafe.as(LibGio::DBusPropertyInfo*).value.signature)
    end

    def signature=(value : ::String)
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.signature = value.to_unsafe
    end

    def flags
      Gio::DBusPropertyInfoFlags.new(to_unsafe.as(LibGio::DBusPropertyInfo*).value.flags)
    end

    def flags=(value : Gio::DBusPropertyInfoFlags)
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.flags = value
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusPropertyInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusPropertyInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  @[Flags]
  enum DBusPropertyInfoFlags : UInt32
    NONE     = 0
    READABLE = 1
    WRITABLE = 2
  end

  class DBusProxy < GObject::Object
    include Gio::AsyncInitable
    include Gio::DBusInterface
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::DBusProxy*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusProxy")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_proxy_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusProxy*)
    end

    def to_unsafe_dbusproxy
      @pointer.not_nil!.as(LibGio::DBusProxy*)
    end

    def initialize(*, g_bus_type : Gio::BusType? = nil, g_connection : Gio::DBusConnection? = nil, g_default_timeout : Int32? = nil, g_flags : Gio::DBusProxyFlags? = nil, g_interface_info : Gio::DBusInterfaceInfo? = nil, g_interface_name : ::String? = nil, g_name : ::String? = nil, g_object_path : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless g_bus_type.nil?
        __var0 << "g-bus-type".to_unsafe
        __var1 << g_bus_type.to_gvalue.to_unsafe.value
      end

      unless g_connection.nil?
        __var0 << "g-connection".to_unsafe
        __var1 << g_connection.to_gvalue.to_unsafe.value
      end

      unless g_default_timeout.nil?
        __var0 << "g-default-timeout".to_unsafe
        __var1 << g_default_timeout.to_gvalue.to_unsafe.value
      end

      unless g_flags.nil?
        __var0 << "g-flags".to_unsafe
        __var1 << g_flags.to_gvalue.to_unsafe.value
      end

      unless g_interface_info.nil?
        __var0 << "g-interface-info".to_unsafe
        __var1 << g_interface_info.to_gvalue.to_unsafe.value
      end

      unless g_interface_name.nil?
        __var0 << "g-interface-name".to_unsafe
        __var1 << g_interface_name.to_gvalue.to_unsafe.value
      end

      unless g_name.nil?
        __var0 << "g-name".to_unsafe
        __var1 << g_name.to_gvalue.to_unsafe.value
      end

      unless g_object_path.nil?
        __var0 << "g-object-path".to_unsafe
        __var1 << g_object_path.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_proxy_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_new_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_new_finish") if __var1.null?
      cast(Gio::DBusProxy.new(__var1))
    end

    def self.new_for_bus_finish(res : Gio::AsyncResult) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_new_for_bus_finish(res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_new_for_bus_finish") if __var1.null?
      cast(Gio::DBusProxy.new(__var1))
    end

    def self.new_for_bus_sync(bus_type : Gio::BusType, flags : Gio::DBusProxyFlags, info : Gio::DBusInterfaceInfo?, name : ::String, object_path : ::String, interface_name : ::String, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_new_for_bus_sync(bus_type, flags, info ? info.to_unsafe.as(LibGio::DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo).null, name.to_unsafe, object_path.to_unsafe, interface_name.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_new_for_bus_sync") if __var1.null?
      cast(Gio::DBusProxy.new(__var1))
    end

    def self.new_sync(connection : Gio::DBusConnection, flags : Gio::DBusProxyFlags, info : Gio::DBusInterfaceInfo?, name : ::String?, object_path : ::String, interface_name : ::String, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_new_sync(connection.to_unsafe_dbusconnection, flags, info ? info.to_unsafe.as(LibGio::DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo).null, name ? name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_new_sync") if __var1.null?
      cast(Gio::DBusProxy.new(__var1))
    end

    def self.new(connection : Gio::DBusConnection, flags : Gio::DBusProxyFlags, info : Gio::DBusInterfaceInfo?, name : ::String?, object_path : ::String, interface_name : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_proxy_new(connection.to_unsafe_dbusconnection, flags, info ? info.to_unsafe.as(LibGio::DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo).null, name ? name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe, interface_name.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def self.new_for_bus(bus_type : Gio::BusType, flags : Gio::DBusProxyFlags, info : Gio::DBusInterfaceInfo?, name : ::String, object_path : ::String, interface_name : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_proxy_new_for_bus(bus_type, flags, info ? info.to_unsafe.as(LibGio::DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo).null, name.to_unsafe, object_path.to_unsafe, interface_name.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def call(method_name : ::String, parameters : GLib::Variant?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_proxy_call(@pointer.as(LibGio::DBusProxy*), method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, flags, Int32.new(timeout_msec), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def call_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_call_finish(@pointer.as(LibGio::DBusProxy*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_call_finish") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_sync(method_name : ::String, parameters : GLib::Variant?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_call_sync(@pointer.as(LibGio::DBusProxy*), method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, flags, Int32.new(timeout_msec), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_call_sync") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_with_unix_fd_list(method_name : ::String, parameters : GLib::Variant?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, fd_list : Gio::UnixFDList?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.d_bus_proxy_call_with_unix_fd_list(@pointer.as(LibGio::DBusProxy*), method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, flags, Int32.new(timeout_msec), fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def call_with_unix_fd_list_finish(out_fd_list : Gio::UnixFDList?, res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_call_with_unix_fd_list_finish(@pointer.as(LibGio::DBusProxy*), out_fd_list, res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_call_with_unix_fd_list_finish") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def call_with_unix_fd_list_sync(method_name : ::String, parameters : GLib::Variant?, flags : Gio::DBusCallFlags, timeout_msec : ::Int, fd_list : Gio::UnixFDList?, out_fd_list : Gio::UnixFDList?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_proxy_call_with_unix_fd_list_sync(@pointer.as(LibGio::DBusProxy*), method_name.to_unsafe, parameters ? parameters.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null, flags, Int32.new(timeout_msec), fd_list ? fd_list.to_unsafe_unixfdlist : Pointer(LibGio::UnixFDList).null, out_fd_list, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_proxy_call_with_unix_fd_list_sync") if __var1.null?
      GLib::Variant.new(__var1)
    end

    def cached_property(property_name : ::String)
      __var0 = LibGio.d_bus_proxy_get_cached_property(@pointer.as(LibGio::DBusProxy*), property_name.to_unsafe)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def cached_property_names
      __var0 = LibGio.d_bus_proxy_get_cached_property_names(@pointer.as(LibGio::DBusProxy*))
      __var2 = GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      } if __var0
      __var2
    end

    def connection
      __var0 = LibGio.d_bus_proxy_get_connection(@pointer.as(LibGio::DBusProxy*))
      GObject.raise_unexpected_null("g_dbus_proxy_get_connection") if __var0.null?
      Gio::DBusConnection.new(__var0)
    end

    def default_timeout
      __var0 = LibGio.d_bus_proxy_get_default_timeout(@pointer.as(LibGio::DBusProxy*))
      __var0
    end

    def flags
      __var0 = LibGio.d_bus_proxy_get_flags(@pointer.as(LibGio::DBusProxy*))
      Gio::DBusProxyFlags.new(__var0)
    end

    def interface_info
      __var0 = LibGio.d_bus_proxy_get_interface_info(@pointer.as(LibGio::DBusProxy*))
      __var1 = Gio::DBusInterfaceInfo.new(__var0) if __var0
      __var1
    end

    def interface_name
      __var0 = LibGio.d_bus_proxy_get_interface_name(@pointer.as(LibGio::DBusProxy*))
      GObject.raise_unexpected_null("g_dbus_proxy_get_interface_name") if __var0.null?
      ::String.new(__var0)
    end

    def name
      __var0 = LibGio.d_bus_proxy_get_name(@pointer.as(LibGio::DBusProxy*))
      GObject.raise_unexpected_null("g_dbus_proxy_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def name_owner
      __var0 = LibGio.d_bus_proxy_get_name_owner(@pointer.as(LibGio::DBusProxy*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def object_path
      __var0 = LibGio.d_bus_proxy_get_object_path(@pointer.as(LibGio::DBusProxy*))
      GObject.raise_unexpected_null("g_dbus_proxy_get_object_path") if __var0.null?
      ::String.new(__var0)
    end

    def set_cached_property(property_name : ::String, value : GLib::Variant?)
      LibGio.d_bus_proxy_set_cached_property(@pointer.as(LibGio::DBusProxy*), property_name.to_unsafe, value ? value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def default_timeout=(timeout_msec : ::Int)
      LibGio.d_bus_proxy_set_default_timeout(@pointer.as(LibGio::DBusProxy*), Int32.new(timeout_msec))
      nil
    end

    def interface_info=(info : Gio::DBusInterfaceInfo?)
      LibGio.d_bus_proxy_set_interface_info(@pointer.as(LibGio::DBusProxy*), info ? info.to_unsafe.as(LibGio::DBusInterfaceInfo*) : Pointer(LibGio::DBusInterfaceInfo).null)
      nil
    end

    def g_connection : Gio::DBusConnection
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-connection", __var0)
      Gio::DBusConnection.cast(__var0.object)
    end

    def g_default_timeout : Int32
      __var0 = GObject::Value.new(type: GObject::Type::INT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-default-timeout", __var0)
      __var0.int
    end

    def g_default_timeout=(value : Int32)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "g-default-timeout", value.to_gvalue)
    end

    def g_flags : Gio::DBusProxyFlags
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-flags", __var0)
      Gio::DBusProxyFlags.new(UInt32.new(__var0.flags))
    end

    def g_interface_info : Gio::DBusInterfaceInfo
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-interface-info", __var0)
      Gio::DBusInterfaceInfo.cast(__var0.object)
    end

    def g_interface_info=(value : Gio::DBusInterfaceInfo)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "g-interface-info", value.to_gvalue)
    end

    def g_interface_name : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-interface-name", __var0)
      __var0.string
    end

    def g_name : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-name", __var0)
      __var0.string
    end

    def g_name_owner : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-name-owner", __var0)
      __var0.string
    end

    def g_object_path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "g-object-path", __var0)
      __var0.string
    end

    alias GPropertiesChangedSignal = DBusProxy, GLib::Variant, ::Enumerable(::String) -> Nil

    def on_g_properties_changed(*, after = false, &block : GPropertiesChangedSignal)
      __var0 = ->(arg0 : LibGio::DBusProxy*, arg1 : LibGLib::Variant*, arg2 : Pointer(Pointer(UInt8)), box : Void*) {
        ::Box(GPropertiesChangedSignal).unbox(box).call(DBusProxy.new(arg0), arg1.null? ? GObject.raise_unexpected_null("changed_properties in g_properties_changed") : GLib::Variant.new(arg1), GObject::PointerIterator.new(arg2) { |__var2|
          ::String.new(__var2)
        })
      }

      __var1 = ::Box.box(GPropertiesChangedSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "g-properties-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_g_properties_changed(&block : GPropertiesChangedSignal)
      on_g_properties_changed(after: true, &block)
    end

    alias GSignalSignal = DBusProxy, ::String?, ::String, GLib::Variant -> Nil

    def on_g_signal(*, after = false, &block : GSignalSignal)
      __var0 = ->(arg0 : LibGio::DBusProxy*, arg1 : Pointer(UInt8), arg2 : Pointer(UInt8), arg3 : LibGLib::Variant*, box : Void*) {
        ::Box(GSignalSignal).unbox(box).call(DBusProxy.new(arg0), ::String.new(arg1), ::String.new(arg2), arg3.null? ? GObject.raise_unexpected_null("parameters in g_signal") : GLib::Variant.new(arg3))
      }

      __var1 = ::Box.box(GSignalSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "g-signal", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_g_signal(&block : GSignalSignal)
      on_g_signal(after: true, &block)
    end
  end

  class DBusProxyClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(408u64, 0u8).as(LibGio::DBusProxyClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusProxyClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusProxyClass*)
    end

    def to_unsafe_dbusproxyclass
      @pointer.not_nil!.as(LibGio::DBusProxyClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DBusProxyClass*).value.parent_class)
    end

    def g_properties_changed
      to_unsafe.as(LibGio::DBusProxyClass*).value.g_properties_changed
    end

    def g_signal
      to_unsafe.as(LibGio::DBusProxyClass*).value.g_signal
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusProxyClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  @[Flags]
  enum DBusProxyFlags : UInt32
    NONE                              =  0
    DO_NOT_LOAD_PROPERTIES            =  1
    DO_NOT_CONNECT_SIGNALS            =  2
    DO_NOT_AUTO_START                 =  4
    GET_INVALIDATED_PROPERTIES        =  8
    DO_NOT_AUTO_START_AT_CONSTRUCTION = 16
  end

  class DBusProxyPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DBusProxyPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusProxyPrivate*)
    end

    def to_unsafe_dbusproxyprivate
      @pointer.not_nil!.as(LibGio::DBusProxyPrivate*)
    end
  end

  alias DBusProxyTypeFunc = LibGio::DBusProxyTypeFunc

  @[Flags]
  enum DBusSendMessageFlags : UInt32
    NONE            = 0
    PRESERVE_SERIAL = 1
  end

  class DBusServer < GObject::Object
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::DBusServer*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusServer")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_server_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusServer*)
    end

    def to_unsafe_dbusserver
      @pointer.not_nil!.as(LibGio::DBusServer*)
    end

    def initialize(*, address : ::String? = nil, authentication_observer : Gio::DBusAuthObserver? = nil, flags : Gio::DBusServerFlags? = nil, guid : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless address.nil?
        __var0 << "address".to_unsafe
        __var1 << address.to_gvalue.to_unsafe.value
      end

      unless authentication_observer.nil?
        __var0 << "authentication-observer".to_unsafe
        __var1 << authentication_observer.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      unless guid.nil?
        __var0 << "guid".to_unsafe
        __var1 << guid.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_server_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_sync(address : ::String, flags : Gio::DBusServerFlags, guid : ::String, observer : Gio::DBusAuthObserver?, cancellable : Gio::Cancellable?) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.d_bus_server_new_sync(address.to_unsafe, flags, guid.to_unsafe, observer ? observer.to_unsafe_dbusauthobserver : Pointer(LibGio::DBusAuthObserver).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dbus_server_new_sync") if __var1.null?
      cast(Gio::DBusServer.new(__var1))
    end

    def client_address
      __var0 = LibGio.d_bus_server_get_client_address(@pointer.as(LibGio::DBusServer*))
      GObject.raise_unexpected_null("g_dbus_server_get_client_address") if __var0.null?
      ::String.new(__var0)
    end

    def flags
      __var0 = LibGio.d_bus_server_get_flags(@pointer.as(LibGio::DBusServer*))
      Gio::DBusServerFlags.new(__var0)
    end

    def guid
      __var0 = LibGio.d_bus_server_get_guid(@pointer.as(LibGio::DBusServer*))
      GObject.raise_unexpected_null("g_dbus_server_get_guid") if __var0.null?
      ::String.new(__var0)
    end

    def active?
      __var0 = LibGio.d_bus_server_is_active(@pointer.as(LibGio::DBusServer*))
      (__var0 == 1)
    end

    def start
      LibGio.d_bus_server_start(@pointer.as(LibGio::DBusServer*))
      nil
    end

    def stop
      LibGio.d_bus_server_stop(@pointer.as(LibGio::DBusServer*))
      nil
    end

    def active : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "active", __var0)
      __var0.boolean
    end

    def address : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "address", __var0)
      __var0.string
    end

    def authentication_observer : Gio::DBusAuthObserver
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "authentication-observer", __var0)
      Gio::DBusAuthObserver.cast(__var0.object)
    end

    alias NewConnectionSignal = DBusServer, Gio::DBusConnection -> ::Bool

    def on_new_connection(*, after = false, &block : NewConnectionSignal)
      __var0 = ->(arg0 : LibGio::DBusServer*, arg1 : LibGio::DBusConnection*, box : Void*) {
        LibC::Int.new(::Box(NewConnectionSignal).unbox(box).call(DBusServer.new(arg0), arg1.null? ? GObject.raise_unexpected_null("connection in new_connection") : Gio::DBusConnection.new(arg1)) ? 1 : 0)
      }

      __var1 = ::Box.box(NewConnectionSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "new-connection", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_new_connection(&block : NewConnectionSignal)
      on_new_connection(after: true, &block)
    end
  end

  @[Flags]
  enum DBusServerFlags : UInt32
    NONE                           = 0
    RUN_IN_THREAD                  = 1
    AUTHENTICATION_ALLOW_ANONYMOUS = 2
  end
  alias DBusSignalCallback = LibGio::DBusSignalCallback

  @[Flags]
  enum DBusSignalFlags : UInt32
    NONE                 = 0
    NO_MATCH_RULE        = 1
    MATCH_ARG0_NAMESPACE = 2
    MATCH_ARG0_PATH      = 4
  end

  class DBusSignalInfo
    include GObject::WrappedType

    def self.new(ref_count : Int32? = nil, name : ::String? = nil, args : ::Enumerable(Gio::DBusArgInfo)? = nil, annotations : ::Enumerable(Gio::DBusAnnotationInfo)? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::DBusSignalInfo*))
      __var0.ref_count = ref_count unless ref_count.nil?
      __var0.name = name unless name.nil?
      __var0.args = args unless args.nil?
      __var0.annotations = annotations unless annotations.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusSignalInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusSignalInfo*)
    end

    def to_unsafe_dbussignalinfo
      @pointer.not_nil!.as(LibGio::DBusSignalInfo*)
    end

    def ref
      __var0 = LibGio.d_bus_signal_info_ref(@pointer.as(LibGio::DBusSignalInfo*))
      GObject.raise_unexpected_null("g_dbus_signal_info_ref") if __var0.null?
      Gio::DBusSignalInfo.new(__var0)
    end

    def unref
      LibGio.d_bus_signal_info_unref(@pointer.as(LibGio::DBusSignalInfo*))
      nil
    end

    def ref_count
      to_unsafe.as(LibGio::DBusSignalInfo*).value.ref_count
    end

    def ref_count=(value : Int32)
      to_unsafe.as(LibGio::DBusSignalInfo*).value.ref_count = Int32.new(value)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::DBusSignalInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::DBusSignalInfo*).value.name = value.to_unsafe
    end

    def args
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusSignalInfo*).value.args) { |__var0|
        Gio::DBusArgInfo.new(__var0)
      }
    end

    def args=(value : ::Enumerable(Gio::DBusArgInfo))
      to_unsafe.as(LibGio::DBusSignalInfo*).value.args = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusArgInfo*) }.to_a).to_unsafe
    end

    def annotations
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusSignalInfo*).value.annotations) { |__var0|
        Gio::DBusAnnotationInfo.new(__var0)
      }
    end

    def annotations=(value : ::Enumerable(Gio::DBusAnnotationInfo))
      to_unsafe.as(LibGio::DBusSignalInfo*).value.annotations = (__value_ary = value.map { |__item| __item.to_unsafe.as(LibGio::DBusAnnotationInfo*) }.to_a).to_unsafe
    end
  end

  alias DBusSubtreeDispatchFunc = LibGio::DBusSubtreeDispatchFunc

  @[Flags]
  enum DBusSubtreeFlags : UInt32
    NONE                           = 0
    DISPATCH_TO_UNENUMERATED_NODES = 1
  end
  alias DBusSubtreeIntrospectFunc = LibGio::DBusSubtreeIntrospectFunc

  class DBusSubtreeVTable
    include GObject::WrappedType

    def self.new(enumerate : Void*? = nil, introspect : Gio::DBusSubtreeIntrospectFunc? = nil, dispatch : Gio::DBusSubtreeDispatchFunc? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(88u64, 0u8).as(LibGio::DBusSubtreeVTable*))
      __var0.enumerate = enumerate unless enumerate.nil?
      __var0.introspect = introspect unless introspect.nil?
      __var0.dispatch = dispatch unless dispatch.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DBusSubtreeVTable*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusSubtreeVTable*)
    end

    def to_unsafe_dbussubtreevtable
      @pointer.not_nil!.as(LibGio::DBusSubtreeVTable*)
    end

    def enumerate
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.enumerate
    end

    def enumerate=(value : Void*)
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.enumerate = value
    end

    def introspect
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.introspect
    end

    def introspect=(value : Gio::DBusSubtreeIntrospectFunc)
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.introspect = value
    end

    def dispatch
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.dispatch
    end

    def dispatch=(value : Gio::DBusSubtreeDispatchFunc)
      to_unsafe.as(LibGio::DBusSubtreeVTable*).value.dispatch = value
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::DBusSubtreeVTable*).value.padding) { |__var0|
        __var0
      }
    end
  end

  module Seekable
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Seekable
      @pointer : Void*

      def initialize(pointer : LibGio::Seekable*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GSeekable")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_seekable_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Seekable*)
      end

      def to_unsafe_seekable
        @pointer.not_nil!.as(LibGio::Seekable*)
      end
    end

    def to_unsafe_seekable
      @pointer.not_nil!.as(LibGio::Seekable*)
    end

    def can_seek
      __var0 = LibGio.seekable_can_seek(@pointer.as(LibGio::Seekable*))
      (__var0 == 1)
    end

    def can_truncate
      __var0 = LibGio.seekable_can_truncate(@pointer.as(LibGio::Seekable*))
      (__var0 == 1)
    end

    def seek(offset : ::Int, type : GLib::SeekType, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.seekable_seek(@pointer.as(LibGio::Seekable*), Int64.new(offset), type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def tell
      __var0 = LibGio.seekable_tell(@pointer.as(LibGio::Seekable*))
      __var0
    end

    def truncate(offset : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.seekable_truncate(@pointer.as(LibGio::Seekable*), Int64.new(offset), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class DataInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(376u64, 0u8).as(LibGio::DataInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DataInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataInputStreamClass*)
    end

    def to_unsafe_datainputstreamclass
      @pointer.not_nil!.as(LibGio::DataInputStreamClass*)
    end

    def parent_class
      Gio::BufferedInputStreamClass.new(to_unsafe.as(LibGio::DataInputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::DataInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::DataInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::DataInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::DataInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::DataInputStreamClass*).value._g_reserved5
    end
  end

  class DataInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DataInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataInputStreamPrivate*)
    end

    def to_unsafe_datainputstreamprivate
      @pointer.not_nil!.as(LibGio::DataInputStreamPrivate*)
    end
  end

  class DataOutputStream < FilterOutputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::DataOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDataOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_data_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataOutputStream*)
    end

    def to_unsafe_dataoutputstream
      @pointer.not_nil!.as(LibGio::DataOutputStream*)
    end

    def initialize(*, base_stream : Gio::OutputStream? = nil, byte_order : Gio::DataStreamByteOrder? = nil, close_base_stream : ::Bool? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless byte_order.nil?
        __var0 << "byte-order".to_unsafe
        __var1 << byte_order.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_data_output_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::OutputStream) : self
      __var0 = LibGio.data_output_stream_new(base_stream.to_unsafe_outputstream)
      GObject.raise_unexpected_null("g_data_output_stream_new") if __var0.null?
      cast(Gio::DataOutputStream.new(__var0))
    end

    def byte_order
      __var0 = LibGio.data_output_stream_get_byte_order(@pointer.as(LibGio::DataOutputStream*))
      Gio::DataStreamByteOrder.new(__var0)
    end

    def put_byte(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_byte(@pointer.as(LibGio::DataOutputStream*), UInt8.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_int16(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_int16(@pointer.as(LibGio::DataOutputStream*), Int16.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_int32(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_int32(@pointer.as(LibGio::DataOutputStream*), Int32.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_int64(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_int64(@pointer.as(LibGio::DataOutputStream*), Int64.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_string(str : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_string(@pointer.as(LibGio::DataOutputStream*), str.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_uint16(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_uint16(@pointer.as(LibGio::DataOutputStream*), UInt16.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_uint32(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_uint32(@pointer.as(LibGio::DataOutputStream*), UInt32.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def put_uint64(data : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_output_stream_put_uint64(@pointer.as(LibGio::DataOutputStream*), UInt64.new(data), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def byte_order=(order : Gio::DataStreamByteOrder)
      LibGio.data_output_stream_set_byte_order(@pointer.as(LibGio::DataOutputStream*), order)
      nil
    end
  end

  class DataOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(360u64, 0u8).as(LibGio::DataOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DataOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataOutputStreamClass*)
    end

    def to_unsafe_dataoutputstreamclass
      @pointer.not_nil!.as(LibGio::DataOutputStreamClass*)
    end

    def parent_class
      Gio::FilterOutputStreamClass.new(to_unsafe.as(LibGio::DataOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::DataOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::DataOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::DataOutputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::DataOutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::DataOutputStreamClass*).value._g_reserved5
    end
  end

  class DataOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::DataOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataOutputStreamPrivate*)
    end

    def to_unsafe_dataoutputstreamprivate
      @pointer.not_nil!.as(LibGio::DataOutputStreamPrivate*)
    end
  end

  enum DataStreamByteOrder : UInt32
    BIG_ENDIAN    = 0
    LITTLE_ENDIAN = 1
    HOST_ENDIAN   = 2
  end

  enum DataStreamNewlineType : UInt32
    LF    = 0
    CR    = 1
    CR_LF = 2
    ANY   = 3
  end

  module DatagramBased
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DatagramBased
      @pointer : Void*

      def initialize(pointer : LibGio::DatagramBased*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDatagramBased")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_datagram_based_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DatagramBased*)
      end

      def to_unsafe_datagrambased
        @pointer.not_nil!.as(LibGio::DatagramBased*)
      end
    end

    def to_unsafe_datagrambased
      @pointer.not_nil!.as(LibGio::DatagramBased*)
    end

    def condition_check(condition : GLib::IOCondition)
      __var0 = LibGio.datagram_based_condition_check(@pointer.as(LibGio::DatagramBased*), condition)
      GLib::IOCondition.new(__var0)
    end

    def condition_wait(condition : GLib::IOCondition, timeout : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.datagram_based_condition_wait(@pointer.as(LibGio::DatagramBased*), condition, Int64.new(timeout), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def create_source(condition : GLib::IOCondition, cancellable : Gio::Cancellable?)
      __var0 = LibGio.datagram_based_create_source(@pointer.as(LibGio::DatagramBased*), condition, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      GObject.raise_unexpected_null("g_datagram_based_create_source") if __var0.null?
      GLib::Source.new(__var0)
    end

    def receive_messages(messages : ::Enumerable, flags : ::Int, timeout : ::Int, cancellable : Gio::Cancellable?)
      num_messages = messages.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.datagram_based_receive_messages(@pointer.as(LibGio::DatagramBased*), (__messages_ary = messages.map { |__item| __item }.to_a).to_unsafe, UInt32.new(num_messages), Int32.new(flags), Int64.new(timeout), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_messages(messages : ::Enumerable, flags : ::Int, timeout : ::Int, cancellable : Gio::Cancellable?)
      num_messages = messages.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.datagram_based_send_messages(@pointer.as(LibGio::DatagramBased*), (__messages_ary = messages.map { |__item| __item }.to_a).to_unsafe, UInt32.new(num_messages), Int32.new(flags), Int64.new(timeout), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end
  end

  class DatagramBasedInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::DatagramBasedInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DatagramBasedInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DatagramBasedInterface*)
    end

    def to_unsafe_datagrambasedinterface
      @pointer.not_nil!.as(LibGio::DatagramBasedInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DatagramBasedInterface*).value.g_iface)
    end

    def receive_messages
      to_unsafe.as(LibGio::DatagramBasedInterface*).value.receive_messages
    end

    def send_messages
      to_unsafe.as(LibGio::DatagramBasedInterface*).value.send_messages
    end

    def create_source
      to_unsafe.as(LibGio::DatagramBasedInterface*).value.create_source
    end

    def condition_check
      to_unsafe.as(LibGio::DatagramBasedInterface*).value.condition_check
    end

    def condition_wait
      to_unsafe.as(LibGio::DatagramBasedInterface*).value.condition_wait
    end
  end

  alias DatagramBasedSourceFunc = LibGio::DatagramBasedSourceFunc

  class DesktopAppInfo < GObject::Object
    include Gio::AppInfo

    @pointer : Void*

    def initialize(pointer : LibGio::DesktopAppInfo*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDesktopAppInfo")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_desktop_app_info_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DesktopAppInfo*)
    end

    def to_unsafe_desktopappinfo
      @pointer.not_nil!.as(LibGio::DesktopAppInfo*)
    end

    def initialize(*, filename : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless filename.nil?
        __var0 << "filename".to_unsafe
        __var1 << filename.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_desktop_app_info_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(desktop_id : ::String) : self
      __var0 = LibGio.desktop_app_info_new(desktop_id.to_unsafe)
      __var1 = cast(Gio::DesktopAppInfo.new(__var0)) if __var0
      __var1
    end

    def self.new_from_filename(filename : ::String) : self
      __var0 = LibGio.desktop_app_info_new_from_filename(filename.to_unsafe)
      __var1 = cast(Gio::DesktopAppInfo.new(__var0)) if __var0
      __var1
    end

    def self.new_from_keyfile(key_file : GLib::KeyFile) : self
      __var0 = LibGio.desktop_app_info_new_from_keyfile(key_file.to_unsafe.as(LibGLib::KeyFile*))
      __var1 = cast(Gio::DesktopAppInfo.new(__var0)) if __var0
      __var1
    end

    def self.implementations(interface : ::String)
      __var0 = LibGio.desktop_app_info_get_implementations(interface.to_unsafe)
      GObject.raise_unexpected_null("g_desktop_app_info_get_implementations") if __var0.null?
      GLib::ListIterator(Gio::DesktopAppInfo, LibGio::DesktopAppInfo*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def self.search(search_string : ::String)
      __var0 = LibGio.desktop_app_info_search(search_string.to_unsafe)
      GObject.raise_unexpected_null("g_desktop_app_info_search") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        GObject::PointerIterator.new(__var1) { |__var2|
          ::String.new(__var2)
        }
      }
    end

    def self.set_desktop_env(desktop_env : ::String)
      LibGio.desktop_app_info_set_desktop_env(desktop_env.to_unsafe)
      nil
    end

    def action_name(action_name : ::String)
      __var0 = LibGio.desktop_app_info_get_action_name(@pointer.as(LibGio::DesktopAppInfo*), action_name.to_unsafe)
      GObject.raise_unexpected_null("g_desktop_app_info_get_action_name") if __var0.null?
      ::String.new(__var0)
    end

    def boolean(key : ::String)
      __var0 = LibGio.desktop_app_info_get_boolean(@pointer.as(LibGio::DesktopAppInfo*), key.to_unsafe)
      (__var0 == 1)
    end

    def categories
      __var0 = LibGio.desktop_app_info_get_categories(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_get_categories") if __var0.null?
      ::String.new(__var0)
    end

    def filename
      __var0 = LibGio.desktop_app_info_get_filename(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_get_filename") if __var0.null?
      ::String.new(__var0)
    end

    def generic_name
      __var0 = LibGio.desktop_app_info_get_generic_name(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_get_generic_name") if __var0.null?
      ::String.new(__var0)
    end

    def is_hidden
      __var0 = LibGio.desktop_app_info_get_is_hidden(@pointer.as(LibGio::DesktopAppInfo*))
      (__var0 == 1)
    end

    def keywords
      __var0 = LibGio.desktop_app_info_get_keywords(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_get_keywords") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def locale_string(key : ::String)
      __var0 = LibGio.desktop_app_info_get_locale_string(@pointer.as(LibGio::DesktopAppInfo*), key.to_unsafe)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def nodisplay
      __var0 = LibGio.desktop_app_info_get_nodisplay(@pointer.as(LibGio::DesktopAppInfo*))
      (__var0 == 1)
    end

    def show_in(desktop_env : ::String?)
      __var0 = LibGio.desktop_app_info_get_show_in(@pointer.as(LibGio::DesktopAppInfo*), desktop_env ? desktop_env.to_unsafe : Pointer(UInt8).null)
      (__var0 == 1)
    end

    def startup_wm_class
      __var0 = LibGio.desktop_app_info_get_startup_wm_class(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_get_startup_wm_class") if __var0.null?
      ::String.new(__var0)
    end

    def string(key : ::String)
      __var0 = LibGio.desktop_app_info_get_string(@pointer.as(LibGio::DesktopAppInfo*), key.to_unsafe)
      GObject.raise_unexpected_null("g_desktop_app_info_get_string") if __var0.null?
      ::String.new(__var0)
    end

    def string_list(key : ::String)
      __var0 = LibGio.desktop_app_info_get_string_list(@pointer.as(LibGio::DesktopAppInfo*), key.to_unsafe, out length)
      GObject.raise_unexpected_null("g_desktop_app_info_get_string_list") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }, length}
    end

    def has_key(key : ::String)
      __var0 = LibGio.desktop_app_info_has_key(@pointer.as(LibGio::DesktopAppInfo*), key.to_unsafe)
      (__var0 == 1)
    end

    def launch_action(action_name : ::String, launch_context : Gio::AppLaunchContext?)
      LibGio.desktop_app_info_launch_action(@pointer.as(LibGio::DesktopAppInfo*), action_name.to_unsafe, launch_context ? launch_context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null)
      nil
    end

    def launch_uris_as_manager(uris : Void*, launch_context : Gio::AppLaunchContext?, spawn_flags : GLib::SpawnFlags, user_setup : GLib::SpawnChildSetupFunc?, user_setup_data : Void*?, pid_callback : Gio::DesktopAppLaunchCallback?, pid_callback_data : Void*?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.desktop_app_info_launch_uris_as_manager(@pointer.as(LibGio::DesktopAppInfo*), uris, launch_context ? launch_context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, spawn_flags, user_setup ? user_setup : nil, user_setup_data ? user_setup_data : Pointer(Void).null, pid_callback ? pid_callback : nil, pid_callback_data ? pid_callback_data : Pointer(Void).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def launch_uris_as_manager_with_fds(uris : Void*, launch_context : Gio::AppLaunchContext?, spawn_flags : GLib::SpawnFlags, user_setup : GLib::SpawnChildSetupFunc?, user_setup_data : Void*?, pid_callback : Gio::DesktopAppLaunchCallback?, pid_callback_data : Void*?, stdin_fd : ::Int, stdout_fd : ::Int, stderr_fd : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.desktop_app_info_launch_uris_as_manager_with_fds(@pointer.as(LibGio::DesktopAppInfo*), uris, launch_context ? launch_context.to_unsafe_applaunchcontext : Pointer(LibGio::AppLaunchContext).null, spawn_flags, user_setup ? user_setup : nil, user_setup_data ? user_setup_data : Pointer(Void).null, pid_callback ? pid_callback : nil, pid_callback_data ? pid_callback_data : Pointer(Void).null, Int32.new(stdin_fd), Int32.new(stdout_fd), Int32.new(stderr_fd), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def list_actions
      __var0 = LibGio.desktop_app_info_list_actions(@pointer.as(LibGio::DesktopAppInfo*))
      GObject.raise_unexpected_null("g_desktop_app_info_list_actions") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end
  end

  class DesktopAppInfoClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::DesktopAppInfoClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DesktopAppInfoClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DesktopAppInfoClass*)
    end

    def to_unsafe_desktopappinfoclass
      @pointer.not_nil!.as(LibGio::DesktopAppInfoClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::DesktopAppInfoClass*).value.parent_class)
    end
  end

  module DesktopAppInfoLookup
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DesktopAppInfoLookup
      @pointer : Void*

      def initialize(pointer : LibGio::DesktopAppInfoLookup*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDesktopAppInfoLookup")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_desktop_app_info_lookup_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DesktopAppInfoLookup*)
      end

      def to_unsafe_desktopappinfolookup
        @pointer.not_nil!.as(LibGio::DesktopAppInfoLookup*)
      end
    end

    def to_unsafe_desktopappinfolookup
      @pointer.not_nil!.as(LibGio::DesktopAppInfoLookup*)
    end

    def default_for_uri_scheme(uri_scheme : ::String)
      __var0 = LibGio.desktop_app_info_lookup_get_default_for_uri_scheme(@pointer.as(LibGio::DesktopAppInfoLookup*), uri_scheme.to_unsafe)
      GObject.raise_unexpected_null("g_desktop_app_info_lookup_get_default_for_uri_scheme") if __var0.null?
      Gio::AppInfo::Wrapper.new(__var0)
    end
  end

  class DesktopAppInfoLookupIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(24u64, 0u8).as(LibGio::DesktopAppInfoLookupIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DesktopAppInfoLookupIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DesktopAppInfoLookupIface*)
    end

    def to_unsafe_desktopappinfolookupiface
      @pointer.not_nil!.as(LibGio::DesktopAppInfoLookupIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DesktopAppInfoLookupIface*).value.g_iface)
    end

    def get_default_for_uri_scheme
      to_unsafe.as(LibGio::DesktopAppInfoLookupIface*).value.get_default_for_uri_scheme
    end
  end

  alias DesktopAppLaunchCallback = LibGio::DesktopAppLaunchCallback

  module Drive
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Drive
      @pointer : Void*

      def initialize(pointer : LibGio::Drive*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDrive")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_drive_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Drive*)
      end

      def to_unsafe_drive
        @pointer.not_nil!.as(LibGio::Drive*)
      end
    end

    def to_unsafe_drive
      @pointer.not_nil!.as(LibGio::Drive*)
    end

    def can_eject
      __var0 = LibGio.drive_can_eject(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def can_poll_for_media
      __var0 = LibGio.drive_can_poll_for_media(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def can_start
      __var0 = LibGio.drive_can_start(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def can_start_degraded
      __var0 = LibGio.drive_can_start_degraded(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def can_stop
      __var0 = LibGio.drive_can_stop(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def eject(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.drive_eject(@pointer.as(LibGio::Drive*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.drive_eject_finish(@pointer.as(LibGio::Drive*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def eject_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.drive_eject_with_operation(@pointer.as(LibGio::Drive*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.drive_eject_with_operation_finish(@pointer.as(LibGio::Drive*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def enumerate_identifiers
      __var0 = LibGio.drive_enumerate_identifiers(@pointer.as(LibGio::Drive*))
      GObject.raise_unexpected_null("g_drive_enumerate_identifiers") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def icon
      __var0 = LibGio.drive_get_icon(@pointer.as(LibGio::Drive*))
      GObject.raise_unexpected_null("g_drive_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def identifier(kind : ::String)
      __var0 = LibGio.drive_get_identifier(@pointer.as(LibGio::Drive*), kind.to_unsafe)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def name
      __var0 = LibGio.drive_get_name(@pointer.as(LibGio::Drive*))
      GObject.raise_unexpected_null("g_drive_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def sort_key
      __var0 = LibGio.drive_get_sort_key(@pointer.as(LibGio::Drive*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def start_stop_type
      __var0 = LibGio.drive_get_start_stop_type(@pointer.as(LibGio::Drive*))
      Gio::DriveStartStopType.new(__var0)
    end

    def symbolic_icon
      __var0 = LibGio.drive_get_symbolic_icon(@pointer.as(LibGio::Drive*))
      GObject.raise_unexpected_null("g_drive_get_symbolic_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def volumes
      __var0 = LibGio.drive_get_volumes(@pointer.as(LibGio::Drive*))
      GObject.raise_unexpected_null("g_drive_get_volumes") if __var0.null?
      GLib::ListIterator(Gio::Volume, LibGio::Volume*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def has_media
      __var0 = LibGio.drive_has_media(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def has_volumes
      __var0 = LibGio.drive_has_volumes(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def media_check_automatic?
      __var0 = LibGio.drive_is_media_check_automatic(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def media_removable?
      __var0 = LibGio.drive_is_media_removable(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def removable?
      __var0 = LibGio.drive_is_removable(@pointer.as(LibGio::Drive*))
      (__var0 == 1)
    end

    def poll_for_media(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.drive_poll_for_media(@pointer.as(LibGio::Drive*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def poll_for_media_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.drive_poll_for_media_finish(@pointer.as(LibGio::Drive*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def start(flags : Gio::DriveStartFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.drive_start(@pointer.as(LibGio::Drive*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def start_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.drive_start_finish(@pointer.as(LibGio::Drive*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def stop(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.drive_stop(@pointer.as(LibGio::Drive*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def stop_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.drive_stop_finish(@pointer.as(LibGio::Drive*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    alias ChangedSignal = Drive -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::Drive*, box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(Drive::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end

    alias DisconnectedSignal = Drive -> Nil

    def on_disconnected(*, after = false, &block : DisconnectedSignal)
      __var0 = ->(arg0 : LibGio::Drive*, box : Void*) {
        ::Box(DisconnectedSignal).unbox(box).call(Drive::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(DisconnectedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "disconnected", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_disconnected(&block : DisconnectedSignal)
      on_disconnected(after: true, &block)
    end

    alias EjectButtonSignal = Drive -> Nil

    def on_eject_button(*, after = false, &block : EjectButtonSignal)
      __var0 = ->(arg0 : LibGio::Drive*, box : Void*) {
        ::Box(EjectButtonSignal).unbox(box).call(Drive::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(EjectButtonSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "eject-button", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_eject_button(&block : EjectButtonSignal)
      on_eject_button(after: true, &block)
    end

    alias StopButtonSignal = Drive -> Nil

    def on_stop_button(*, after = false, &block : StopButtonSignal)
      __var0 = ->(arg0 : LibGio::Drive*, box : Void*) {
        ::Box(StopButtonSignal).unbox(box).call(Drive::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(StopButtonSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "stop-button", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_stop_button(&block : StopButtonSignal)
      on_stop_button(after: true, &block)
    end
  end

  class DriveIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(272u64, 0u8).as(LibGio::DriveIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DriveIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DriveIface*)
    end

    def to_unsafe_driveiface
      @pointer.not_nil!.as(LibGio::DriveIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DriveIface*).value.g_iface)
    end

    def changed
      to_unsafe.as(LibGio::DriveIface*).value.changed
    end

    def disconnected
      to_unsafe.as(LibGio::DriveIface*).value.disconnected
    end

    def eject_button
      to_unsafe.as(LibGio::DriveIface*).value.eject_button
    end

    def get_name
      to_unsafe.as(LibGio::DriveIface*).value.get_name
    end

    def get_icon
      to_unsafe.as(LibGio::DriveIface*).value.get_icon
    end

    def has_volumes
      to_unsafe.as(LibGio::DriveIface*).value.has_volumes
    end

    def get_volumes
      to_unsafe.as(LibGio::DriveIface*).value.get_volumes
    end

    def is_media_removable
      to_unsafe.as(LibGio::DriveIface*).value.is_media_removable
    end

    def has_media
      to_unsafe.as(LibGio::DriveIface*).value.has_media
    end

    def is_media_check_automatic
      to_unsafe.as(LibGio::DriveIface*).value.is_media_check_automatic
    end

    def can_eject
      to_unsafe.as(LibGio::DriveIface*).value.can_eject
    end

    def can_poll_for_media
      to_unsafe.as(LibGio::DriveIface*).value.can_poll_for_media
    end

    def eject
      to_unsafe.as(LibGio::DriveIface*).value.eject
    end

    def eject_finish
      to_unsafe.as(LibGio::DriveIface*).value.eject_finish
    end

    def poll_for_media
      to_unsafe.as(LibGio::DriveIface*).value.poll_for_media
    end

    def poll_for_media_finish
      to_unsafe.as(LibGio::DriveIface*).value.poll_for_media_finish
    end

    def get_identifier
      to_unsafe.as(LibGio::DriveIface*).value.get_identifier
    end

    def enumerate_identifiers
      to_unsafe.as(LibGio::DriveIface*).value.enumerate_identifiers
    end

    def get_start_stop_type
      to_unsafe.as(LibGio::DriveIface*).value.get_start_stop_type
    end

    def can_start
      to_unsafe.as(LibGio::DriveIface*).value.can_start
    end

    def can_start_degraded
      to_unsafe.as(LibGio::DriveIface*).value.can_start_degraded
    end

    def start
      to_unsafe.as(LibGio::DriveIface*).value.start
    end

    def start_finish
      to_unsafe.as(LibGio::DriveIface*).value.start_finish
    end

    def can_stop
      to_unsafe.as(LibGio::DriveIface*).value.can_stop
    end

    def stop
      to_unsafe.as(LibGio::DriveIface*).value.stop
    end

    def stop_finish
      to_unsafe.as(LibGio::DriveIface*).value.stop_finish
    end

    def stop_button
      to_unsafe.as(LibGio::DriveIface*).value.stop_button
    end

    def eject_with_operation
      to_unsafe.as(LibGio::DriveIface*).value.eject_with_operation
    end

    def eject_with_operation_finish
      to_unsafe.as(LibGio::DriveIface*).value.eject_with_operation_finish
    end

    def get_sort_key
      to_unsafe.as(LibGio::DriveIface*).value.get_sort_key
    end

    def get_symbolic_icon
      to_unsafe.as(LibGio::DriveIface*).value.get_symbolic_icon
    end

    def is_removable
      to_unsafe.as(LibGio::DriveIface*).value.is_removable
    end
  end

  @[Flags]
  enum DriveStartFlags : UInt32
    NONE = 0
  end

  enum DriveStartStopType : UInt32
    UNKNOWN   = 0
    SHUTDOWN  = 1
    NETWORK   = 2
    MULTIDISK = 3
    PASSWORD  = 4
  end

  module DtlsClientConnection
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DtlsClientConnection
      @pointer : Void*

      def initialize(pointer : LibGio::DtlsClientConnection*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDtlsClientConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dtls_client_connection_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DtlsClientConnection*)
      end

      def to_unsafe_dtlsclientconnection
        @pointer.not_nil!.as(LibGio::DtlsClientConnection*)
      end
    end

    def to_unsafe_dtlsclientconnection
      @pointer.not_nil!.as(LibGio::DtlsClientConnection*)
    end

    def self.new(base_socket : Gio::DatagramBased, server_identity : Gio::SocketConnectable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_client_connection_new(base_socket.to_unsafe_datagrambased, server_identity ? server_identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dtls_client_connection_new") if __var1.null?
      Gio::DtlsClientConnection::Wrapper.new(__var1)
    end

    def accepted_cas
      __var0 = LibGio.dtls_client_connection_get_accepted_cas(@pointer.as(LibGio::DtlsClientConnection*))
      GObject.raise_unexpected_null("g_dtls_client_connection_get_accepted_cas") if __var0.null?
      GLib::ListIterator(::Enumerable(UInt8), Pointer(Void)*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def server_identity
      __var0 = LibGio.dtls_client_connection_get_server_identity(@pointer.as(LibGio::DtlsClientConnection*))
      GObject.raise_unexpected_null("g_dtls_client_connection_get_server_identity") if __var0.null?
      Gio::SocketConnectable::Wrapper.new(__var0)
    end

    def validation_flags
      __var0 = LibGio.dtls_client_connection_get_validation_flags(@pointer.as(LibGio::DtlsClientConnection*))
      Gio::TlsCertificateFlags.new(__var0)
    end

    def server_identity=(identity : Gio::SocketConnectable)
      LibGio.dtls_client_connection_set_server_identity(@pointer.as(LibGio::DtlsClientConnection*), identity.to_unsafe_socketconnectable)
      nil
    end

    def validation_flags=(flags : Gio::TlsCertificateFlags)
      LibGio.dtls_client_connection_set_validation_flags(@pointer.as(LibGio::DtlsClientConnection*), flags)
      nil
    end
  end

  class DtlsClientConnectionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::DtlsClientConnectionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DtlsClientConnectionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DtlsClientConnectionInterface*)
    end

    def to_unsafe_dtlsclientconnectioninterface
      @pointer.not_nil!.as(LibGio::DtlsClientConnectionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DtlsClientConnectionInterface*).value.g_iface)
    end
  end

  module DtlsConnection
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DtlsConnection
      @pointer : Void*

      def initialize(pointer : LibGio::DtlsConnection*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDtlsConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dtls_connection_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DtlsConnection*)
      end

      def to_unsafe_dtlsconnection
        @pointer.not_nil!.as(LibGio::DtlsConnection*)
      end
    end

    def to_unsafe_dtlsconnection
      @pointer.not_nil!.as(LibGio::DtlsConnection*)
    end

    def close(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_close(@pointer.as(LibGio::DtlsConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.dtls_connection_close_async(@pointer.as(LibGio::DtlsConnection*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_close_finish(@pointer.as(LibGio::DtlsConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def emit_accept_certificate(peer_cert : Gio::TlsCertificate, errors : Gio::TlsCertificateFlags)
      __var0 = LibGio.dtls_connection_emit_accept_certificate(@pointer.as(LibGio::DtlsConnection*), peer_cert.to_unsafe_tlscertificate, errors)
      (__var0 == 1)
    end

    def certificate
      __var0 = LibGio.dtls_connection_get_certificate(@pointer.as(LibGio::DtlsConnection*))
      GObject.raise_unexpected_null("g_dtls_connection_get_certificate") if __var0.null?
      Gio::TlsCertificate.new(__var0)
    end

    def database
      __var0 = LibGio.dtls_connection_get_database(@pointer.as(LibGio::DtlsConnection*))
      GObject.raise_unexpected_null("g_dtls_connection_get_database") if __var0.null?
      Gio::TlsDatabase.new(__var0)
    end

    def interaction
      __var0 = LibGio.dtls_connection_get_interaction(@pointer.as(LibGio::DtlsConnection*))
      GObject.raise_unexpected_null("g_dtls_connection_get_interaction") if __var0.null?
      Gio::TlsInteraction.new(__var0)
    end

    def negotiated_protocol
      __var0 = LibGio.dtls_connection_get_negotiated_protocol(@pointer.as(LibGio::DtlsConnection*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def peer_certificate
      __var0 = LibGio.dtls_connection_get_peer_certificate(@pointer.as(LibGio::DtlsConnection*))
      GObject.raise_unexpected_null("g_dtls_connection_get_peer_certificate") if __var0.null?
      Gio::TlsCertificate.new(__var0)
    end

    def peer_certificate_errors
      __var0 = LibGio.dtls_connection_get_peer_certificate_errors(@pointer.as(LibGio::DtlsConnection*))
      Gio::TlsCertificateFlags.new(__var0)
    end

    def rehandshake_mode
      __var0 = LibGio.dtls_connection_get_rehandshake_mode(@pointer.as(LibGio::DtlsConnection*))
      Gio::TlsRehandshakeMode.new(__var0)
    end

    def require_close_notify
      __var0 = LibGio.dtls_connection_get_require_close_notify(@pointer.as(LibGio::DtlsConnection*))
      (__var0 == 1)
    end

    def handshake(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_handshake(@pointer.as(LibGio::DtlsConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def handshake_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.dtls_connection_handshake_async(@pointer.as(LibGio::DtlsConnection*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def handshake_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_handshake_finish(@pointer.as(LibGio::DtlsConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def advertised_protocols=(protocols : ::Enumerable?)
      LibGio.dtls_connection_set_advertised_protocols(@pointer.as(LibGio::DtlsConnection*), protocols ? (__protocols_ary = protocols.map { |__item| __item.to_unsafe }.to_a).to_unsafe : Pointer(Pointer(UInt8)).null)
      nil
    end

    def certificate=(certificate : Gio::TlsCertificate)
      LibGio.dtls_connection_set_certificate(@pointer.as(LibGio::DtlsConnection*), certificate.to_unsafe_tlscertificate)
      nil
    end

    def database=(database : Gio::TlsDatabase)
      LibGio.dtls_connection_set_database(@pointer.as(LibGio::DtlsConnection*), database.to_unsafe_tlsdatabase)
      nil
    end

    def interaction=(interaction : Gio::TlsInteraction?)
      LibGio.dtls_connection_set_interaction(@pointer.as(LibGio::DtlsConnection*), interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null)
      nil
    end

    def rehandshake_mode=(mode : Gio::TlsRehandshakeMode)
      LibGio.dtls_connection_set_rehandshake_mode(@pointer.as(LibGio::DtlsConnection*), mode)
      nil
    end

    def require_close_notify=(require_close_notify : ::Bool)
      LibGio.dtls_connection_set_require_close_notify(@pointer.as(LibGio::DtlsConnection*), LibC::Int.new(require_close_notify ? 1 : 0))
      nil
    end

    def shutdown(shutdown_read : ::Bool, shutdown_write : ::Bool, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_shutdown(@pointer.as(LibGio::DtlsConnection*), LibC::Int.new(shutdown_read ? 1 : 0), LibC::Int.new(shutdown_write ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def shutdown_async(shutdown_read : ::Bool, shutdown_write : ::Bool, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.dtls_connection_shutdown_async(@pointer.as(LibGio::DtlsConnection*), LibC::Int.new(shutdown_read ? 1 : 0), LibC::Int.new(shutdown_write ? 1 : 0), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def shutdown_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_connection_shutdown_finish(@pointer.as(LibGio::DtlsConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    alias AcceptCertificateSignal = DtlsConnection, Gio::TlsCertificate, Gio::TlsCertificateFlags -> ::Bool

    def on_accept_certificate(*, after = false, &block : AcceptCertificateSignal)
      __var0 = ->(arg0 : LibGio::DtlsConnection*, arg1 : LibGio::TlsCertificate*, arg2 : LibGio::TlsCertificateFlags, box : Void*) {
        LibC::Int.new(::Box(AcceptCertificateSignal).unbox(box).call(DtlsConnection::Wrapper.new(arg0), arg1.null? ? GObject.raise_unexpected_null("peer_cert in accept_certificate") : Gio::TlsCertificate.new(arg1), Gio::TlsCertificateFlags.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(AcceptCertificateSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "accept-certificate", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_accept_certificate(&block : AcceptCertificateSignal)
      on_accept_certificate(after: true, &block)
    end
  end

  class DtlsConnectionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(88u64, 0u8).as(LibGio::DtlsConnectionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DtlsConnectionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DtlsConnectionInterface*)
    end

    def to_unsafe_dtlsconnectioninterface
      @pointer.not_nil!.as(LibGio::DtlsConnectionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DtlsConnectionInterface*).value.g_iface)
    end

    def accept_certificate
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.accept_certificate
    end

    def handshake
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.handshake
    end

    def handshake_async
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.handshake_async
    end

    def handshake_finish
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.handshake_finish
    end

    def shutdown
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.shutdown
    end

    def shutdown_async
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.shutdown_async
    end

    def shutdown_finish
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.shutdown_finish
    end

    def set_advertised_protocols
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.set_advertised_protocols
    end

    def get_negotiated_protocol
      to_unsafe.as(LibGio::DtlsConnectionInterface*).value.get_negotiated_protocol
    end
  end

  module DtlsServerConnection
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include DtlsServerConnection
      @pointer : Void*

      def initialize(pointer : LibGio::DtlsServerConnection*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GDtlsServerConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dtls_server_connection_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::DtlsServerConnection*)
      end

      def to_unsafe_dtlsserverconnection
        @pointer.not_nil!.as(LibGio::DtlsServerConnection*)
      end
    end

    def to_unsafe_dtlsserverconnection
      @pointer.not_nil!.as(LibGio::DtlsServerConnection*)
    end

    def self.new(base_socket : Gio::DatagramBased, certificate : Gio::TlsCertificate?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.dtls_server_connection_new(base_socket.to_unsafe_datagrambased, certificate ? certificate.to_unsafe_tlscertificate : Pointer(LibGio::TlsCertificate).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_dtls_server_connection_new") if __var1.null?
      Gio::DtlsServerConnection::Wrapper.new(__var1)
    end
  end

  class DtlsServerConnectionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::DtlsServerConnectionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::DtlsServerConnectionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DtlsServerConnectionInterface*)
    end

    def to_unsafe_dtlsserverconnectioninterface
      @pointer.not_nil!.as(LibGio::DtlsServerConnectionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::DtlsServerConnectionInterface*).value.g_iface)
    end
  end

  class Emblem < GObject::Object
    include Gio::Icon

    @pointer : Void*

    def initialize(pointer : LibGio::Emblem*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GEmblem")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_emblem_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Emblem*)
    end

    def to_unsafe_emblem
      @pointer.not_nil!.as(LibGio::Emblem*)
    end

    def initialize(*, icon : GObject::Object? = nil, origin : Gio::EmblemOrigin? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless icon.nil?
        __var0 << "icon".to_unsafe
        __var1 << icon.to_gvalue.to_unsafe.value
      end

      unless origin.nil?
        __var0 << "origin".to_unsafe
        __var1 << origin.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_emblem_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(icon : Gio::Icon) : self
      __var0 = LibGio.emblem_new(icon.to_unsafe_icon)
      GObject.raise_unexpected_null("g_emblem_new") if __var0.null?
      cast(Gio::Emblem.new(__var0))
    end

    def self.new_with_origin(icon : Gio::Icon, origin : Gio::EmblemOrigin) : self
      __var0 = LibGio.emblem_new_with_origin(icon.to_unsafe_icon, origin)
      GObject.raise_unexpected_null("g_emblem_new_with_origin") if __var0.null?
      cast(Gio::Emblem.new(__var0))
    end

    def icon
      __var0 = LibGio.emblem_get_icon(@pointer.as(LibGio::Emblem*))
      GObject.raise_unexpected_null("g_emblem_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def origin
      __var0 = LibGio.emblem_get_origin(@pointer.as(LibGio::Emblem*))
      Gio::EmblemOrigin.new(__var0)
    end
  end

  class EmblemClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::EmblemClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::EmblemClass*)
    end

    def to_unsafe_emblemclass
      @pointer.not_nil!.as(LibGio::EmblemClass*)
    end
  end

  enum EmblemOrigin : UInt32
    UNKNOWN      = 0
    DEVICE       = 1
    LIVEMETADATA = 2
    TAG          = 3
  end

  class EmblemedIcon < GObject::Object
    include Gio::Icon

    @pointer : Void*

    def initialize(pointer : LibGio::EmblemedIcon*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GEmblemedIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_emblemed_icon_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::EmblemedIcon*)
    end

    def to_unsafe_emblemedicon
      @pointer.not_nil!.as(LibGio::EmblemedIcon*)
    end

    def initialize(*, gicon : Gio::Icon? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless gicon.nil?
        __var0 << "gicon".to_unsafe
        __var1 << gicon.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_emblemed_icon_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(icon : Gio::Icon, emblem : Gio::Emblem?) : self
      __var0 = LibGio.emblemed_icon_new(icon.to_unsafe_icon, emblem ? emblem.to_unsafe_emblem : Pointer(LibGio::Emblem).null)
      GObject.raise_unexpected_null("g_emblemed_icon_new") if __var0.null?
      cast(Gio::EmblemedIcon.new(__var0))
    end

    def add_emblem(emblem : Gio::Emblem)
      LibGio.emblemed_icon_add_emblem(@pointer.as(LibGio::EmblemedIcon*), emblem.to_unsafe_emblem)
      nil
    end

    def clear_emblems
      LibGio.emblemed_icon_clear_emblems(@pointer.as(LibGio::EmblemedIcon*))
      nil
    end

    def emblems
      __var0 = LibGio.emblemed_icon_get_emblems(@pointer.as(LibGio::EmblemedIcon*))
      GObject.raise_unexpected_null("g_emblemed_icon_get_emblems") if __var0.null?
      GLib::ListIterator(Gio::Emblem, LibGio::Emblem*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def icon
      __var0 = LibGio.emblemed_icon_get_icon(@pointer.as(LibGio::EmblemedIcon*))
      GObject.raise_unexpected_null("g_emblemed_icon_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def gicon : Gio::Icon
      __var0 = GObject::Value.new(type: GObject::Type::INTERFACE)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "gicon", __var0)
      Gio::Icon::Wrapper.cast(__var0.instance)
    end
  end

  class EmblemedIconClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::EmblemedIconClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::EmblemedIconClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::EmblemedIconClass*)
    end

    def to_unsafe_emblemediconclass
      @pointer.not_nil!.as(LibGio::EmblemedIconClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::EmblemedIconClass*).value.parent_class)
    end
  end

  class EmblemedIconPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::EmblemedIconPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::EmblemedIconPrivate*)
    end

    def to_unsafe_emblemediconprivate
      @pointer.not_nil!.as(LibGio::EmblemedIconPrivate*)
    end
  end

  module File
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include File
      @pointer : Void*

      def initialize(pointer : LibGio::File*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GFile")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::File*)
      end

      def to_unsafe_file
        @pointer.not_nil!.as(LibGio::File*)
      end
    end

    def to_unsafe_file
      @pointer.not_nil!.as(LibGio::File*)
    end

    def self.new_for_commandline_arg(arg : ::String)
      __var0 = LibGio.file_new_for_commandline_arg(arg.to_unsafe)
      GObject.raise_unexpected_null("g_file_new_for_commandline_arg") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def self.new_for_commandline_arg_and_cwd(arg : ::String, cwd : ::String)
      __var0 = LibGio.file_new_for_commandline_arg_and_cwd(arg.to_unsafe, cwd.to_unsafe)
      GObject.raise_unexpected_null("g_file_new_for_commandline_arg_and_cwd") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def self.new_for_path(path : ::String)
      __var0 = LibGio.file_new_for_path(path.to_unsafe)
      GObject.raise_unexpected_null("g_file_new_for_path") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def self.new_for_uri(uri : ::String)
      __var0 = LibGio.file_new_for_uri(uri.to_unsafe)
      GObject.raise_unexpected_null("g_file_new_for_uri") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def self.new_tmp(tmpl : ::String?, iostream : Gio::FileIOStream)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_new_tmp(tmpl ? tmpl.to_unsafe : Pointer(UInt8).null, iostream, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_new_tmp") if __var1.null?
      Gio::File::Wrapper.new(__var1)
    end

    def self.parse_name(parse_name : ::String)
      __var0 = LibGio.file_parse_name(parse_name.to_unsafe)
      GObject.raise_unexpected_null("g_file_parse_name") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def append_to(flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_append_to(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_append_to") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def append_to_async(flags : Gio::FileCreateFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_append_to_async(@pointer.as(LibGio::File*), flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def append_to_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_append_to_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_append_to_finish") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def copy(destination : Gio::File, flags : Gio::FileCopyFlags, cancellable : Gio::Cancellable?, progress_callback : Gio::FileProgressCallback?, progress_callback_data : Void*?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_copy(@pointer.as(LibGio::File*), destination.to_unsafe_file, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, progress_callback ? progress_callback : nil, progress_callback_data ? progress_callback_data : Pointer(Void).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def copy_async(destination : Gio::File, flags : Gio::FileCopyFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, progress_callback : Gio::FileProgressCallback?, progress_callback_data : Void*?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_copy_async(@pointer.as(LibGio::File*), destination.to_unsafe_file, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, progress_callback ? progress_callback : nil, progress_callback_data ? progress_callback_data : Pointer(Void).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def copy_attributes(destination : Gio::File, flags : Gio::FileCopyFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_copy_attributes(@pointer.as(LibGio::File*), destination.to_unsafe_file, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def copy_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_copy_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def create(flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_create(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_create") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def create_async(flags : Gio::FileCreateFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_create_async(@pointer.as(LibGio::File*), flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def create_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_create_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_create_finish") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def create_readwrite(flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_create_readwrite(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_create_readwrite") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def create_readwrite_async(flags : Gio::FileCreateFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_create_readwrite_async(@pointer.as(LibGio::File*), flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def create_readwrite_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_create_readwrite_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_create_readwrite_finish") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def delete(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_delete(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def delete_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_delete_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def delete_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_delete_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def dup
      __var0 = LibGio.file_dup(@pointer.as(LibGio::File*))
      GObject.raise_unexpected_null("g_file_dup") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def eject_mountable(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_eject_mountable(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_eject_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def eject_mountable_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_eject_mountable_with_operation(@pointer.as(LibGio::File*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_mountable_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_eject_mountable_with_operation_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def enumerate_children(attributes : ::String, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerate_children(@pointer.as(LibGio::File*), attributes.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_enumerate_children") if __var1.null?
      Gio::FileEnumerator.new(__var1)
    end

    def enumerate_children_async(attributes : ::String, flags : Gio::FileQueryInfoFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_enumerate_children_async(@pointer.as(LibGio::File*), attributes.to_unsafe, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def enumerate_children_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerate_children_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_enumerate_children_finish") if __var1.null?
      Gio::FileEnumerator.new(__var1)
    end

    def equal(file2 : Gio::File)
      __var0 = LibGio.file_equal(@pointer.as(LibGio::File*), file2.to_unsafe_file)
      (__var0 == 1)
    end

    def find_enclosing_mount(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_find_enclosing_mount(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_find_enclosing_mount") if __var1.null?
      Gio::Mount::Wrapper.new(__var1)
    end

    def find_enclosing_mount_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_find_enclosing_mount_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def find_enclosing_mount_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_find_enclosing_mount_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_find_enclosing_mount_finish") if __var1.null?
      Gio::Mount::Wrapper.new(__var1)
    end

    def basename
      __var0 = LibGio.file_get_basename(@pointer.as(LibGio::File*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def child(name : ::String)
      __var0 = LibGio.file_get_child(@pointer.as(LibGio::File*), name.to_unsafe)
      GObject.raise_unexpected_null("g_file_get_child") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def child_for_display_name(display_name : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_get_child_for_display_name(@pointer.as(LibGio::File*), display_name.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_get_child_for_display_name") if __var1.null?
      Gio::File::Wrapper.new(__var1)
    end

    def parent
      __var0 = LibGio.file_get_parent(@pointer.as(LibGio::File*))
      __var1 = Gio::File::Wrapper.new(__var0) if __var0
      __var1
    end

    def parse_name
      __var0 = LibGio.file_get_parse_name(@pointer.as(LibGio::File*))
      GObject.raise_unexpected_null("g_file_get_parse_name") if __var0.null?
      ::String.new(__var0)
    end

    def path
      __var0 = LibGio.file_get_path(@pointer.as(LibGio::File*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def relative_path(descendant : Gio::File)
      __var0 = LibGio.file_get_relative_path(@pointer.as(LibGio::File*), descendant.to_unsafe_file)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def uri
      __var0 = LibGio.file_get_uri(@pointer.as(LibGio::File*))
      GObject.raise_unexpected_null("g_file_get_uri") if __var0.null?
      ::String.new(__var0)
    end

    def uri_scheme
      __var0 = LibGio.file_get_uri_scheme(@pointer.as(LibGio::File*))
      GObject.raise_unexpected_null("g_file_get_uri_scheme") if __var0.null?
      ::String.new(__var0)
    end

    def has_parent(parent : Gio::File?)
      __var0 = LibGio.file_has_parent(@pointer.as(LibGio::File*), parent ? parent.to_unsafe_file : Pointer(LibGio::File).null)
      (__var0 == 1)
    end

    def has_prefix(prefix : Gio::File)
      __var0 = LibGio.file_has_prefix(@pointer.as(LibGio::File*), prefix.to_unsafe_file)
      (__var0 == 1)
    end

    def has_uri_scheme(uri_scheme : ::String)
      __var0 = LibGio.file_has_uri_scheme(@pointer.as(LibGio::File*), uri_scheme.to_unsafe)
      (__var0 == 1)
    end

    def hash
      __var0 = LibGio.file_hash(@pointer.as(LibGio::File*))
      __var0
    end

    def native?
      __var0 = LibGio.file_is_native(@pointer.as(LibGio::File*))
      (__var0 == 1)
    end

    def load_bytes(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_load_bytes(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, out etag_out, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_load_bytes") if __var1.null?
      {GLib::Bytes.new(__var1), ::String.new(etag_out)}
    end

    def load_bytes_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_load_bytes_async(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def load_bytes_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_load_bytes_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, out etag_out, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_load_bytes_finish") if __var1.null?
      {GLib::Bytes.new(__var1), ::String.new(etag_out)}
    end

    def load_contents(cancellable : Gio::Cancellable?, contents : ::Bytes)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_load_contents(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, contents, out length, out etag_out, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), length, ::String.new(etag_out)}
    end

    def load_contents_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_load_contents_async(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def load_contents_finish(res : Gio::AsyncResult, contents : ::Bytes)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_load_contents_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, contents, out length, out etag_out, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), length, ::String.new(etag_out)}
    end

    def load_partial_contents_finish(res : Gio::AsyncResult, contents : ::Bytes)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_load_partial_contents_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, contents, out length, out etag_out, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), length, ::String.new(etag_out)}
    end

    def make_directory(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_make_directory(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def make_directory_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_make_directory_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def make_directory_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_make_directory_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def make_directory_with_parents(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_make_directory_with_parents(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def make_symbolic_link(symlink_value : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_make_symbolic_link(@pointer.as(LibGio::File*), symlink_value.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def measure_disk_usage_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_measure_disk_usage_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, out disk_usage, out num_dirs, out num_files, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), disk_usage, num_dirs, num_files}
    end

    def monitor(flags : Gio::FileMonitorFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_monitor(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_monitor") if __var1.null?
      Gio::FileMonitor.new(__var1)
    end

    def monitor_directory(flags : Gio::FileMonitorFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_monitor_directory(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_monitor_directory") if __var1.null?
      Gio::FileMonitor.new(__var1)
    end

    def monitor_file(flags : Gio::FileMonitorFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_monitor_file(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_monitor_file") if __var1.null?
      Gio::FileMonitor.new(__var1)
    end

    def mount_enclosing_volume(flags : Gio::MountMountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_mount_enclosing_volume(@pointer.as(LibGio::File*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def mount_enclosing_volume_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_mount_enclosing_volume_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def mount_mountable(flags : Gio::MountMountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_mount_mountable(@pointer.as(LibGio::File*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def mount_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_mount_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_mount_mountable_finish") if __var1.null?
      Gio::File::Wrapper.new(__var1)
    end

    def move(destination : Gio::File, flags : Gio::FileCopyFlags, cancellable : Gio::Cancellable?, progress_callback : Gio::FileProgressCallback?, progress_callback_data : Void*?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_move(@pointer.as(LibGio::File*), destination.to_unsafe_file, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, progress_callback ? progress_callback : nil, progress_callback_data ? progress_callback_data : Pointer(Void).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def open_readwrite(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_open_readwrite(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_open_readwrite") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def open_readwrite_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_open_readwrite_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def open_readwrite_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_open_readwrite_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_open_readwrite_finish") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def peek_path
      __var0 = LibGio.file_peek_path(@pointer.as(LibGio::File*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def poll_mountable(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_poll_mountable(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def poll_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_poll_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def query_default_handler(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_default_handler(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_default_handler") if __var1.null?
      Gio::AppInfo::Wrapper.new(__var1)
    end

    def query_default_handler_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_query_default_handler_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_default_handler_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_default_handler_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_default_handler_finish") if __var1.null?
      Gio::AppInfo::Wrapper.new(__var1)
    end

    def query_exists(cancellable : Gio::Cancellable?)
      __var0 = LibGio.file_query_exists(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      (__var0 == 1)
    end

    def query_file_type(flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = LibGio.file_query_file_type(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      Gio::FileType.new(__var0)
    end

    def query_filesystem_info(attributes : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_filesystem_info(@pointer.as(LibGio::File*), attributes.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_filesystem_info") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_filesystem_info_async(attributes : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_query_filesystem_info_async(@pointer.as(LibGio::File*), attributes.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_filesystem_info_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_filesystem_info_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_filesystem_info_finish") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_info(attributes : ::String, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_info(@pointer.as(LibGio::File*), attributes.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_info") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_info_async(attributes : ::String, flags : Gio::FileQueryInfoFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_query_info_async(@pointer.as(LibGio::File*), attributes.to_unsafe, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_info_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_info_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_info_finish") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_settable_attributes(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_settable_attributes(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_settable_attributes") if __var1.null?
      Gio::FileAttributeInfoList.new(__var1)
    end

    def query_writable_namespaces(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_query_writable_namespaces(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_query_writable_namespaces") if __var1.null?
      Gio::FileAttributeInfoList.new(__var1)
    end

    def read(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_read(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_read") if __var1.null?
      Gio::FileInputStream.new(__var1)
    end

    def read_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_read_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def read_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_read_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_read_finish") if __var1.null?
      Gio::FileInputStream.new(__var1)
    end

    def replace(etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace(@pointer.as(LibGio::File*), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_replace") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def replace_async(etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_replace_async(@pointer.as(LibGio::File*), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def replace_contents(contents : ::Bytes, etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      length = contents.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace_contents(@pointer.as(LibGio::File*), contents.to_unsafe, UInt64.new(length), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, out new_etag, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), ::String.new(new_etag)}
    end

    def replace_contents_async(contents : ::Bytes, etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      length = contents.size
      LibGio.file_replace_contents_async(@pointer.as(LibGio::File*), contents.to_unsafe, UInt64.new(length), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def replace_contents_bytes_async(contents : GLib::Bytes, etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_replace_contents_bytes_async(@pointer.as(LibGio::File*), contents.to_unsafe.as(LibGLib::Bytes*), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def replace_contents_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace_contents_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, out new_etag, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), ::String.new(new_etag)}
    end

    def replace_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_replace_finish") if __var1.null?
      Gio::FileOutputStream.new(__var1)
    end

    def replace_readwrite(etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace_readwrite(@pointer.as(LibGio::File*), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_replace_readwrite") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def replace_readwrite_async(etag : ::String?, make_backup : ::Bool, flags : Gio::FileCreateFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_replace_readwrite_async(@pointer.as(LibGio::File*), etag ? etag.to_unsafe : Pointer(UInt8).null, LibC::Int.new(make_backup ? 1 : 0), flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def replace_readwrite_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_replace_readwrite_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_replace_readwrite_finish") if __var1.null?
      Gio::FileIOStream.new(__var1)
    end

    def resolve_relative_path(relative_path : ::String)
      __var0 = LibGio.file_resolve_relative_path(@pointer.as(LibGio::File*), relative_path.to_unsafe)
      GObject.raise_unexpected_null("g_file_resolve_relative_path") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def set_attribute(attribute : ::String, type : Gio::FileAttributeType, value_p : Void*?, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute(@pointer.as(LibGio::File*), attribute.to_unsafe, type, value_p ? value_p : Pointer(Void).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_byte_string(attribute : ::String, value : ::String, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_byte_string(@pointer.as(LibGio::File*), attribute.to_unsafe, value.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_int32(attribute : ::String, value : ::Int, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_int32(@pointer.as(LibGio::File*), attribute.to_unsafe, Int32.new(value), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_int64(attribute : ::String, value : ::Int, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_int64(@pointer.as(LibGio::File*), attribute.to_unsafe, Int64.new(value), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_string(attribute : ::String, value : ::String, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_string(@pointer.as(LibGio::File*), attribute.to_unsafe, value.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_uint32(attribute : ::String, value : ::Int, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_uint32(@pointer.as(LibGio::File*), attribute.to_unsafe, UInt32.new(value), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attribute_uint64(attribute : ::String, value : ::Int, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attribute_uint64(@pointer.as(LibGio::File*), attribute.to_unsafe, UInt64.new(value), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attributes_async(info : Gio::FileInfo, flags : Gio::FileQueryInfoFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_set_attributes_async(@pointer.as(LibGio::File*), info.to_unsafe_fileinfo, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def set_attributes_finish(result : Gio::AsyncResult, info : Gio::FileInfo)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attributes_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, info, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_attributes_from_info(info : Gio::FileInfo, flags : Gio::FileQueryInfoFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_attributes_from_info(@pointer.as(LibGio::File*), info.to_unsafe_fileinfo, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def set_display_name(display_name : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_display_name(@pointer.as(LibGio::File*), display_name.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_set_display_name") if __var1.null?
      Gio::File::Wrapper.new(__var1)
    end

    def set_display_name_async(display_name : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_set_display_name_async(@pointer.as(LibGio::File*), display_name.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def set_display_name_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_set_display_name_finish(@pointer.as(LibGio::File*), res.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_set_display_name_finish") if __var1.null?
      Gio::File::Wrapper.new(__var1)
    end

    def start_mountable(flags : Gio::DriveStartFlags, start_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_start_mountable(@pointer.as(LibGio::File*), flags, start_operation ? start_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def start_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_start_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def stop_mountable(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_stop_mountable(@pointer.as(LibGio::File*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def stop_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_stop_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def supports_thread_contexts
      __var0 = LibGio.file_supports_thread_contexts(@pointer.as(LibGio::File*))
      (__var0 == 1)
    end

    def trash(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_trash(@pointer.as(LibGio::File*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def trash_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_trash_async(@pointer.as(LibGio::File*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def trash_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_trash_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def unmount_mountable(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_unmount_mountable(@pointer.as(LibGio::File*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def unmount_mountable_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_unmount_mountable_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def unmount_mountable_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_unmount_mountable_with_operation(@pointer.as(LibGio::File*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def unmount_mountable_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_unmount_mountable_with_operation_finish(@pointer.as(LibGio::File*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class FileAttributeInfo
    include GObject::WrappedType

    def self.new(name : ::String? = nil, type : Gio::FileAttributeType? = nil, flags : Gio::FileAttributeInfoFlags? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::FileAttributeInfo*))
      __var0.name = name unless name.nil?
      __var0.type = type unless type.nil?
      __var0.flags = flags unless flags.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileAttributeInfo*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileAttributeInfo*)
    end

    def to_unsafe_fileattributeinfo
      @pointer.not_nil!.as(LibGio::FileAttributeInfo*)
    end

    def name
      ::String.new(to_unsafe.as(LibGio::FileAttributeInfo*).value.name)
    end

    def name=(value : ::String)
      to_unsafe.as(LibGio::FileAttributeInfo*).value.name = value.to_unsafe
    end

    def type
      Gio::FileAttributeType.new(to_unsafe.as(LibGio::FileAttributeInfo*).value.type)
    end

    def type=(value : Gio::FileAttributeType)
      to_unsafe.as(LibGio::FileAttributeInfo*).value.type = value
    end

    def flags
      Gio::FileAttributeInfoFlags.new(to_unsafe.as(LibGio::FileAttributeInfo*).value.flags)
    end

    def flags=(value : Gio::FileAttributeInfoFlags)
      to_unsafe.as(LibGio::FileAttributeInfo*).value.flags = value
    end
  end

  @[Flags]
  enum FileAttributeInfoFlags : UInt32
    NONE            = 0
    COPY_WITH_FILE  = 1
    COPY_WHEN_MOVED = 2
  end

  class FileAttributeInfoList
    include GObject::WrappedType

    def self.new(infos : Gio::FileAttributeInfo? = nil, n_infos : Int32? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::FileAttributeInfoList*))
      __var0.infos = infos unless infos.nil?
      __var0.n_infos = n_infos unless n_infos.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileAttributeInfoList*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileAttributeInfoList*)
    end

    def to_unsafe_fileattributeinfolist
      @pointer.not_nil!.as(LibGio::FileAttributeInfoList*)
    end

    def self.new : self
      __var0 = LibGio.file_attribute_info_list_new
      GObject.raise_unexpected_null("g_file_attribute_info_list_new") if __var0.null?
      cast(Gio::FileAttributeInfoList.new(__var0))
    end

    def add(name : ::String, type : Gio::FileAttributeType, flags : Gio::FileAttributeInfoFlags)
      LibGio.file_attribute_info_list_add(@pointer.as(LibGio::FileAttributeInfoList*), name.to_unsafe, type, flags)
      nil
    end

    def dup
      __var0 = LibGio.file_attribute_info_list_dup(@pointer.as(LibGio::FileAttributeInfoList*))
      GObject.raise_unexpected_null("g_file_attribute_info_list_dup") if __var0.null?
      Gio::FileAttributeInfoList.new(__var0)
    end

    def lookup(name : ::String)
      __var0 = LibGio.file_attribute_info_list_lookup(@pointer.as(LibGio::FileAttributeInfoList*), name.to_unsafe)
      GObject.raise_unexpected_null("g_file_attribute_info_list_lookup") if __var0.null?
      Gio::FileAttributeInfo.new(__var0)
    end

    def ref
      __var0 = LibGio.file_attribute_info_list_ref(@pointer.as(LibGio::FileAttributeInfoList*))
      GObject.raise_unexpected_null("g_file_attribute_info_list_ref") if __var0.null?
      Gio::FileAttributeInfoList.new(__var0)
    end

    def unref
      LibGio.file_attribute_info_list_unref(@pointer.as(LibGio::FileAttributeInfoList*))
      nil
    end

    def infos
      Gio::FileAttributeInfo.new(to_unsafe.as(LibGio::FileAttributeInfoList*).value.infos)
    end

    def infos=(value : Gio::FileAttributeInfo)
      to_unsafe.as(LibGio::FileAttributeInfoList*).value.infos = value.to_unsafe.as(LibGio::FileAttributeInfo*)
    end

    def n_infos
      to_unsafe.as(LibGio::FileAttributeInfoList*).value.n_infos
    end

    def n_infos=(value : Int32)
      to_unsafe.as(LibGio::FileAttributeInfoList*).value.n_infos = Int32.new(value)
    end
  end

  class FileAttributeMatcher
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileAttributeMatcher*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileAttributeMatcher*)
    end

    def to_unsafe_fileattributematcher
      @pointer.not_nil!.as(LibGio::FileAttributeMatcher*)
    end

    def self.new(attributes : ::String) : self
      __var0 = LibGio.file_attribute_matcher_new(attributes.to_unsafe)
      GObject.raise_unexpected_null("g_file_attribute_matcher_new") if __var0.null?
      cast(Gio::FileAttributeMatcher.new(__var0))
    end

    def enumerate_namespace(ns : ::String)
      __var0 = LibGio.file_attribute_matcher_enumerate_namespace(@pointer.as(LibGio::FileAttributeMatcher*), ns.to_unsafe)
      (__var0 == 1)
    end

    def enumerate_next
      __var0 = LibGio.file_attribute_matcher_enumerate_next(@pointer.as(LibGio::FileAttributeMatcher*))
      GObject.raise_unexpected_null("g_file_attribute_matcher_enumerate_next") if __var0.null?
      ::String.new(__var0)
    end

    def matches(attribute : ::String)
      __var0 = LibGio.file_attribute_matcher_matches(@pointer.as(LibGio::FileAttributeMatcher*), attribute.to_unsafe)
      (__var0 == 1)
    end

    def matches_only(attribute : ::String)
      __var0 = LibGio.file_attribute_matcher_matches_only(@pointer.as(LibGio::FileAttributeMatcher*), attribute.to_unsafe)
      (__var0 == 1)
    end

    def ref
      __var0 = LibGio.file_attribute_matcher_ref(@pointer.as(LibGio::FileAttributeMatcher*))
      GObject.raise_unexpected_null("g_file_attribute_matcher_ref") if __var0.null?
      Gio::FileAttributeMatcher.new(__var0)
    end

    def subtract(subtract : Gio::FileAttributeMatcher)
      __var0 = LibGio.file_attribute_matcher_subtract(@pointer.as(LibGio::FileAttributeMatcher*), subtract.to_unsafe.as(LibGio::FileAttributeMatcher*))
      GObject.raise_unexpected_null("g_file_attribute_matcher_subtract") if __var0.null?
      Gio::FileAttributeMatcher.new(__var0)
    end

    def to_string
      __var0 = LibGio.file_attribute_matcher_to_string(@pointer.as(LibGio::FileAttributeMatcher*))
      GObject.raise_unexpected_null("g_file_attribute_matcher_to_string") if __var0.null?
      ::String.new(__var0)
    end

    def unref
      LibGio.file_attribute_matcher_unref(@pointer.as(LibGio::FileAttributeMatcher*))
      nil
    end
  end

  enum FileAttributeStatus : UInt32
    UNSET         = 0
    SET           = 1
    ERROR_SETTING = 2
  end

  enum FileAttributeType : UInt32
    INVALID     = 0
    STRING      = 1
    BYTE_STRING = 2
    BOOLEAN     = 3
    UINT32      = 4
    INT32       = 5
    UINT64      = 6
    INT64       = 7
    OBJECT      = 8
    STRINGV     = 9
  end

  @[Flags]
  enum FileCopyFlags : UInt32
    NONE                 =  0
    OVERWRITE            =  1
    BACKUP               =  2
    NOFOLLOW_SYMLINKS    =  4
    ALL_METADATA         =  8
    NO_FALLBACK_FOR_MOVE = 16
    TARGET_DEFAULT_PERMS = 32
  end

  @[Flags]
  enum FileCreateFlags : UInt32
    NONE                = 0
    PRIVATE             = 1
    REPLACE_DESTINATION = 2
  end

  module FileDescriptorBased
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include FileDescriptorBased
      @pointer : Void*

      def initialize(pointer : LibGio::FileDescriptorBased*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GFileDescriptorBased")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_descriptor_based_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::FileDescriptorBased*)
      end

      def to_unsafe_filedescriptorbased
        @pointer.not_nil!.as(LibGio::FileDescriptorBased*)
      end
    end

    def to_unsafe_filedescriptorbased
      @pointer.not_nil!.as(LibGio::FileDescriptorBased*)
    end

    def fd
      __var0 = LibGio.file_descriptor_based_get_fd(@pointer.as(LibGio::FileDescriptorBased*))
      __var0
    end
  end

  class FileDescriptorBasedIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(24u64, 0u8).as(LibGio::FileDescriptorBasedIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileDescriptorBasedIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileDescriptorBasedIface*)
    end

    def to_unsafe_filedescriptorbasediface
      @pointer.not_nil!.as(LibGio::FileDescriptorBasedIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::FileDescriptorBasedIface*).value.g_iface)
    end

    def get_fd
      to_unsafe.as(LibGio::FileDescriptorBasedIface*).value.get_fd
    end
  end

  class FileEnumerator < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::FileEnumerator*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileEnumerator")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_enumerator_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileEnumerator*)
    end

    def to_unsafe_fileenumerator
      @pointer.not_nil!.as(LibGio::FileEnumerator*)
    end

    def initialize(*, container : Gio::File? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless container.nil?
        __var0 << "container".to_unsafe
        __var1 << container.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_file_enumerator_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def close(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerator_close(@pointer.as(LibGio::FileEnumerator*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_enumerator_close_async(@pointer.as(LibGio::FileEnumerator*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerator_close_finish(@pointer.as(LibGio::FileEnumerator*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def child(info : Gio::FileInfo)
      __var0 = LibGio.file_enumerator_get_child(@pointer.as(LibGio::FileEnumerator*), info.to_unsafe_fileinfo)
      GObject.raise_unexpected_null("g_file_enumerator_get_child") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def container
      __var0 = LibGio.file_enumerator_get_container(@pointer.as(LibGio::FileEnumerator*))
      GObject.raise_unexpected_null("g_file_enumerator_get_container") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def has_pending
      __var0 = LibGio.file_enumerator_has_pending(@pointer.as(LibGio::FileEnumerator*))
      (__var0 == 1)
    end

    def closed?
      __var0 = LibGio.file_enumerator_is_closed(@pointer.as(LibGio::FileEnumerator*))
      (__var0 == 1)
    end

    def iterate(out_info : Gio::FileInfo?, out_child : Gio::File?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerator_iterate(@pointer.as(LibGio::FileEnumerator*), out_info, out_child, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def next_file(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerator_next_file(@pointer.as(LibGio::FileEnumerator*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var2 = Gio::FileInfo.new(__var1) if __var1
      __var2
    end

    def next_files_async(num_files : ::Int, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_enumerator_next_files_async(@pointer.as(LibGio::FileEnumerator*), Int32.new(num_files), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def next_files_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_enumerator_next_files_finish(@pointer.as(LibGio::FileEnumerator*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_enumerator_next_files_finish") if __var1.null?
      GLib::ListIterator(Gio::FileInfo, LibGio::FileInfo*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def pending=(pending : ::Bool)
      LibGio.file_enumerator_set_pending(@pointer.as(LibGio::FileEnumerator*), LibC::Int.new(pending ? 1 : 0))
      nil
    end
  end

  class FileEnumeratorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(240u64, 0u8).as(LibGio::FileEnumeratorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileEnumeratorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileEnumeratorClass*)
    end

    def to_unsafe_fileenumeratorclass
      @pointer.not_nil!.as(LibGio::FileEnumeratorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::FileEnumeratorClass*).value.parent_class)
    end

    def next_file
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.next_file
    end

    def close_fn
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.close_fn
    end

    def next_files_async
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.next_files_async
    end

    def next_files_finish
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.next_files_finish
    end

    def close_async
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.close_async
    end

    def close_finish
      to_unsafe.as(LibGio::FileEnumeratorClass*).value.close_finish
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::FileEnumeratorClass*).value._g_reserved7
    end
  end

  class FileEnumeratorPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileEnumeratorPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileEnumeratorPrivate*)
    end

    def to_unsafe_fileenumeratorprivate
      @pointer.not_nil!.as(LibGio::FileEnumeratorPrivate*)
    end
  end

  class IOStream < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::IOStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GIOStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_io_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOStream*)
    end

    def to_unsafe_iostream
      @pointer.not_nil!.as(LibGio::IOStream*)
    end

    def self.splice_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.i_o_stream_splice_finish(result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def clear_pending
      LibGio.i_o_stream_clear_pending(@pointer.as(LibGio::IOStream*))
      nil
    end

    def close(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.i_o_stream_close(@pointer.as(LibGio::IOStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.i_o_stream_close_async(@pointer.as(LibGio::IOStream*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def close_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.i_o_stream_close_finish(@pointer.as(LibGio::IOStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def input_stream
      __var0 = LibGio.i_o_stream_get_input_stream(@pointer.as(LibGio::IOStream*))
      GObject.raise_unexpected_null("g_io_stream_get_input_stream") if __var0.null?
      Gio::InputStream.new(__var0)
    end

    def output_stream
      __var0 = LibGio.i_o_stream_get_output_stream(@pointer.as(LibGio::IOStream*))
      GObject.raise_unexpected_null("g_io_stream_get_output_stream") if __var0.null?
      Gio::OutputStream.new(__var0)
    end

    def has_pending
      __var0 = LibGio.i_o_stream_has_pending(@pointer.as(LibGio::IOStream*))
      (__var0 == 1)
    end

    def closed?
      __var0 = LibGio.i_o_stream_is_closed(@pointer.as(LibGio::IOStream*))
      (__var0 == 1)
    end

    def pending=
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.i_o_stream_set_pending(@pointer.as(LibGio::IOStream*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def splice_async(stream2 : Gio::IOStream, flags : Gio::IOStreamSpliceFlags, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.i_o_stream_splice_async(@pointer.as(LibGio::IOStream*), stream2.to_unsafe_iostream, flags, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def closed : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "closed", __var0)
      __var0.boolean
    end
  end

  class FileIOStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(368u64, 0u8).as(LibGio::FileIOStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileIOStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIOStreamClass*)
    end

    def to_unsafe_fileiostreamclass
      @pointer.not_nil!.as(LibGio::FileIOStreamClass*)
    end

    def parent_class
      Gio::IOStreamClass.new(to_unsafe.as(LibGio::FileIOStreamClass*).value.parent_class)
    end

    def tell
      to_unsafe.as(LibGio::FileIOStreamClass*).value.tell
    end

    def can_seek
      to_unsafe.as(LibGio::FileIOStreamClass*).value.can_seek
    end

    def seek
      to_unsafe.as(LibGio::FileIOStreamClass*).value.seek
    end

    def can_truncate
      to_unsafe.as(LibGio::FileIOStreamClass*).value.can_truncate
    end

    def truncate_fn
      to_unsafe.as(LibGio::FileIOStreamClass*).value.truncate_fn
    end

    def query_info
      to_unsafe.as(LibGio::FileIOStreamClass*).value.query_info
    end

    def query_info_async
      to_unsafe.as(LibGio::FileIOStreamClass*).value.query_info_async
    end

    def query_info_finish
      to_unsafe.as(LibGio::FileIOStreamClass*).value.query_info_finish
    end

    def get_etag
      to_unsafe.as(LibGio::FileIOStreamClass*).value.get_etag
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FileIOStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FileIOStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FileIOStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::FileIOStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::FileIOStreamClass*).value._g_reserved5
    end
  end

  class FileIOStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileIOStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIOStreamPrivate*)
    end

    def to_unsafe_fileiostreamprivate
      @pointer.not_nil!.as(LibGio::FileIOStreamPrivate*)
    end
  end

  module LoadableIcon
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include LoadableIcon
      @pointer : Void*

      def initialize(pointer : LibGio::LoadableIcon*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GLoadableIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_loadable_icon_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::LoadableIcon*)
      end

      def to_unsafe_loadableicon
        @pointer.not_nil!.as(LibGio::LoadableIcon*)
      end
    end

    def to_unsafe_loadableicon
      @pointer.not_nil!.as(LibGio::LoadableIcon*)
    end

    def load(size : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.loadable_icon_load(@pointer.as(LibGio::LoadableIcon*), Int32.new(size), out type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_loadable_icon_load") if __var1.null?
      {Gio::InputStream.new(__var1), ::String.new(type)}
    end

    def load_async(size : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.loadable_icon_load_async(@pointer.as(LibGio::LoadableIcon*), Int32.new(size), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def load_finish(res : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.loadable_icon_load_finish(@pointer.as(LibGio::LoadableIcon*), res.to_unsafe_asyncresult, out type, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_loadable_icon_load_finish") if __var1.null?
      {Gio::InputStream.new(__var1), ::String.new(type)}
    end
  end

  class FileIconClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileIconClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIconClass*)
    end

    def to_unsafe_fileiconclass
      @pointer.not_nil!.as(LibGio::FileIconClass*)
    end
  end

  class FileIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(840u64, 0u8).as(LibGio::FileIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIface*)
    end

    def to_unsafe_fileiface
      @pointer.not_nil!.as(LibGio::FileIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::FileIface*).value.g_iface)
    end

    def dup
      to_unsafe.as(LibGio::FileIface*).value.dup
    end

    def hash
      to_unsafe.as(LibGio::FileIface*).value.hash
    end

    def equal
      to_unsafe.as(LibGio::FileIface*).value.equal
    end

    def is_native
      to_unsafe.as(LibGio::FileIface*).value.is_native
    end

    def has_uri_scheme
      to_unsafe.as(LibGio::FileIface*).value.has_uri_scheme
    end

    def get_uri_scheme
      to_unsafe.as(LibGio::FileIface*).value.get_uri_scheme
    end

    def get_basename
      to_unsafe.as(LibGio::FileIface*).value.get_basename
    end

    def get_path
      to_unsafe.as(LibGio::FileIface*).value.get_path
    end

    def get_uri
      to_unsafe.as(LibGio::FileIface*).value.get_uri
    end

    def get_parse_name
      to_unsafe.as(LibGio::FileIface*).value.get_parse_name
    end

    def get_parent
      to_unsafe.as(LibGio::FileIface*).value.get_parent
    end

    def prefix_matches
      to_unsafe.as(LibGio::FileIface*).value.prefix_matches
    end

    def get_relative_path
      to_unsafe.as(LibGio::FileIface*).value.get_relative_path
    end

    def resolve_relative_path
      to_unsafe.as(LibGio::FileIface*).value.resolve_relative_path
    end

    def get_child_for_display_name
      to_unsafe.as(LibGio::FileIface*).value.get_child_for_display_name
    end

    def enumerate_children
      to_unsafe.as(LibGio::FileIface*).value.enumerate_children
    end

    def enumerate_children_async
      to_unsafe.as(LibGio::FileIface*).value.enumerate_children_async
    end

    def enumerate_children_finish
      to_unsafe.as(LibGio::FileIface*).value.enumerate_children_finish
    end

    def query_info
      to_unsafe.as(LibGio::FileIface*).value.query_info
    end

    def query_info_async
      to_unsafe.as(LibGio::FileIface*).value.query_info_async
    end

    def query_info_finish
      to_unsafe.as(LibGio::FileIface*).value.query_info_finish
    end

    def query_filesystem_info
      to_unsafe.as(LibGio::FileIface*).value.query_filesystem_info
    end

    def query_filesystem_info_async
      to_unsafe.as(LibGio::FileIface*).value.query_filesystem_info_async
    end

    def query_filesystem_info_finish
      to_unsafe.as(LibGio::FileIface*).value.query_filesystem_info_finish
    end

    def find_enclosing_mount
      to_unsafe.as(LibGio::FileIface*).value.find_enclosing_mount
    end

    def find_enclosing_mount_async
      to_unsafe.as(LibGio::FileIface*).value.find_enclosing_mount_async
    end

    def find_enclosing_mount_finish
      to_unsafe.as(LibGio::FileIface*).value.find_enclosing_mount_finish
    end

    def set_display_name
      to_unsafe.as(LibGio::FileIface*).value.set_display_name
    end

    def set_display_name_async
      to_unsafe.as(LibGio::FileIface*).value.set_display_name_async
    end

    def set_display_name_finish
      to_unsafe.as(LibGio::FileIface*).value.set_display_name_finish
    end

    def query_settable_attributes
      to_unsafe.as(LibGio::FileIface*).value.query_settable_attributes
    end

    def _query_settable_attributes_async
      to_unsafe.as(LibGio::FileIface*).value._query_settable_attributes_async
    end

    def _query_settable_attributes_finish
      to_unsafe.as(LibGio::FileIface*).value._query_settable_attributes_finish
    end

    def query_writable_namespaces
      to_unsafe.as(LibGio::FileIface*).value.query_writable_namespaces
    end

    def _query_writable_namespaces_async
      to_unsafe.as(LibGio::FileIface*).value._query_writable_namespaces_async
    end

    def _query_writable_namespaces_finish
      to_unsafe.as(LibGio::FileIface*).value._query_writable_namespaces_finish
    end

    def set_attribute
      to_unsafe.as(LibGio::FileIface*).value.set_attribute
    end

    def set_attributes_from_info
      to_unsafe.as(LibGio::FileIface*).value.set_attributes_from_info
    end

    def set_attributes_async
      to_unsafe.as(LibGio::FileIface*).value.set_attributes_async
    end

    def set_attributes_finish
      to_unsafe.as(LibGio::FileIface*).value.set_attributes_finish
    end

    def read_fn
      to_unsafe.as(LibGio::FileIface*).value.read_fn
    end

    def read_async
      to_unsafe.as(LibGio::FileIface*).value.read_async
    end

    def read_finish
      to_unsafe.as(LibGio::FileIface*).value.read_finish
    end

    def append_to
      to_unsafe.as(LibGio::FileIface*).value.append_to
    end

    def append_to_async
      to_unsafe.as(LibGio::FileIface*).value.append_to_async
    end

    def append_to_finish
      to_unsafe.as(LibGio::FileIface*).value.append_to_finish
    end

    def create
      to_unsafe.as(LibGio::FileIface*).value.create
    end

    def create_async
      to_unsafe.as(LibGio::FileIface*).value.create_async
    end

    def create_finish
      to_unsafe.as(LibGio::FileIface*).value.create_finish
    end

    def replace
      to_unsafe.as(LibGio::FileIface*).value.replace
    end

    def replace_async
      to_unsafe.as(LibGio::FileIface*).value.replace_async
    end

    def replace_finish
      to_unsafe.as(LibGio::FileIface*).value.replace_finish
    end

    def delete_file
      to_unsafe.as(LibGio::FileIface*).value.delete_file
    end

    def delete_file_async
      to_unsafe.as(LibGio::FileIface*).value.delete_file_async
    end

    def delete_file_finish
      to_unsafe.as(LibGio::FileIface*).value.delete_file_finish
    end

    def trash
      to_unsafe.as(LibGio::FileIface*).value.trash
    end

    def trash_async
      to_unsafe.as(LibGio::FileIface*).value.trash_async
    end

    def trash_finish
      to_unsafe.as(LibGio::FileIface*).value.trash_finish
    end

    def make_directory
      to_unsafe.as(LibGio::FileIface*).value.make_directory
    end

    def make_directory_async
      to_unsafe.as(LibGio::FileIface*).value.make_directory_async
    end

    def make_directory_finish
      to_unsafe.as(LibGio::FileIface*).value.make_directory_finish
    end

    def make_symbolic_link
      to_unsafe.as(LibGio::FileIface*).value.make_symbolic_link
    end

    def _make_symbolic_link_async
      to_unsafe.as(LibGio::FileIface*).value._make_symbolic_link_async
    end

    def _make_symbolic_link_finish
      to_unsafe.as(LibGio::FileIface*).value._make_symbolic_link_finish
    end

    def copy
      to_unsafe.as(LibGio::FileIface*).value.copy
    end

    def copy_async
      to_unsafe.as(LibGio::FileIface*).value.copy_async
    end

    def copy_finish
      to_unsafe.as(LibGio::FileIface*).value.copy_finish
    end

    def move
      to_unsafe.as(LibGio::FileIface*).value.move
    end

    def _move_async
      to_unsafe.as(LibGio::FileIface*).value._move_async
    end

    def _move_finish
      to_unsafe.as(LibGio::FileIface*).value._move_finish
    end

    def mount_mountable
      to_unsafe.as(LibGio::FileIface*).value.mount_mountable
    end

    def mount_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.mount_mountable_finish
    end

    def unmount_mountable
      to_unsafe.as(LibGio::FileIface*).value.unmount_mountable
    end

    def unmount_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.unmount_mountable_finish
    end

    def eject_mountable
      to_unsafe.as(LibGio::FileIface*).value.eject_mountable
    end

    def eject_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.eject_mountable_finish
    end

    def mount_enclosing_volume
      to_unsafe.as(LibGio::FileIface*).value.mount_enclosing_volume
    end

    def mount_enclosing_volume_finish
      to_unsafe.as(LibGio::FileIface*).value.mount_enclosing_volume_finish
    end

    def monitor_dir
      to_unsafe.as(LibGio::FileIface*).value.monitor_dir
    end

    def monitor_file
      to_unsafe.as(LibGio::FileIface*).value.monitor_file
    end

    def open_readwrite
      to_unsafe.as(LibGio::FileIface*).value.open_readwrite
    end

    def open_readwrite_async
      to_unsafe.as(LibGio::FileIface*).value.open_readwrite_async
    end

    def open_readwrite_finish
      to_unsafe.as(LibGio::FileIface*).value.open_readwrite_finish
    end

    def create_readwrite
      to_unsafe.as(LibGio::FileIface*).value.create_readwrite
    end

    def create_readwrite_async
      to_unsafe.as(LibGio::FileIface*).value.create_readwrite_async
    end

    def create_readwrite_finish
      to_unsafe.as(LibGio::FileIface*).value.create_readwrite_finish
    end

    def replace_readwrite
      to_unsafe.as(LibGio::FileIface*).value.replace_readwrite
    end

    def replace_readwrite_async
      to_unsafe.as(LibGio::FileIface*).value.replace_readwrite_async
    end

    def replace_readwrite_finish
      to_unsafe.as(LibGio::FileIface*).value.replace_readwrite_finish
    end

    def start_mountable
      to_unsafe.as(LibGio::FileIface*).value.start_mountable
    end

    def start_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.start_mountable_finish
    end

    def stop_mountable
      to_unsafe.as(LibGio::FileIface*).value.stop_mountable
    end

    def stop_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.stop_mountable_finish
    end

    def supports_thread_contexts
      (to_unsafe.as(LibGio::FileIface*).value.supports_thread_contexts == 1)
    end

    def unmount_mountable_with_operation
      to_unsafe.as(LibGio::FileIface*).value.unmount_mountable_with_operation
    end

    def unmount_mountable_with_operation_finish
      to_unsafe.as(LibGio::FileIface*).value.unmount_mountable_with_operation_finish
    end

    def eject_mountable_with_operation
      to_unsafe.as(LibGio::FileIface*).value.eject_mountable_with_operation
    end

    def eject_mountable_with_operation_finish
      to_unsafe.as(LibGio::FileIface*).value.eject_mountable_with_operation_finish
    end

    def poll_mountable
      to_unsafe.as(LibGio::FileIface*).value.poll_mountable
    end

    def poll_mountable_finish
      to_unsafe.as(LibGio::FileIface*).value.poll_mountable_finish
    end

    def measure_disk_usage
      to_unsafe.as(LibGio::FileIface*).value.measure_disk_usage
    end

    def measure_disk_usage_async
      to_unsafe.as(LibGio::FileIface*).value.measure_disk_usage_async
    end

    def measure_disk_usage_finish
      to_unsafe.as(LibGio::FileIface*).value.measure_disk_usage_finish
    end
  end

  class FileInfo < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::FileInfo*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileInfo")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_info_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileInfo*)
    end

    def to_unsafe_fileinfo
      @pointer.not_nil!.as(LibGio::FileInfo*)
    end

    def self.new : self
      __var0 = LibGio.file_info_new
      GObject.raise_unexpected_null("g_file_info_new") if __var0.null?
      cast(Gio::FileInfo.new(__var0))
    end

    def clear_status
      LibGio.file_info_clear_status(@pointer.as(LibGio::FileInfo*))
      nil
    end

    def copy_into(dest_info : Gio::FileInfo)
      LibGio.file_info_copy_into(@pointer.as(LibGio::FileInfo*), dest_info.to_unsafe_fileinfo)
      nil
    end

    def dup
      __var0 = LibGio.file_info_dup(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_dup") if __var0.null?
      Gio::FileInfo.new(__var0)
    end

    def attribute_as_string(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_as_string(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def attribute_boolean(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_boolean(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      (__var0 == 1)
    end

    def attribute_byte_string(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_byte_string(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      GObject.raise_unexpected_null("g_file_info_get_attribute_byte_string") if __var0.null?
      ::String.new(__var0)
    end

    def attribute_data(attribute : ::String, type : Gio::FileAttributeType?, value_pp : Void*?, status : Gio::FileAttributeStatus?)
      __var0 = LibGio.file_info_get_attribute_data(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, type, value_pp, status)
      (__var0 == 1)
    end

    def attribute_int32(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_int32(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      __var0
    end

    def attribute_int64(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_int64(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      __var0
    end

    def attribute_object(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_object(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      GObject.raise_unexpected_null("g_file_info_get_attribute_object") if __var0.null?
      GObject::Object.new(__var0)
    end

    def attribute_status(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_status(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      Gio::FileAttributeStatus.new(__var0)
    end

    def attribute_string(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_string(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      GObject.raise_unexpected_null("g_file_info_get_attribute_string") if __var0.null?
      ::String.new(__var0)
    end

    def attribute_stringv(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_stringv(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      GObject.raise_unexpected_null("g_file_info_get_attribute_stringv") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def attribute_type(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_type(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      Gio::FileAttributeType.new(__var0)
    end

    def attribute_uint32(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_uint32(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      __var0
    end

    def attribute_uint64(attribute : ::String)
      __var0 = LibGio.file_info_get_attribute_uint64(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      __var0
    end

    def content_type
      __var0 = LibGio.file_info_get_content_type(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_content_type") if __var0.null?
      ::String.new(__var0)
    end

    def deletion_date
      __var0 = LibGio.file_info_get_deletion_date(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_deletion_date") if __var0.null?
      GLib::DateTime.new(__var0)
    end

    def display_name
      __var0 = LibGio.file_info_get_display_name(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_display_name") if __var0.null?
      ::String.new(__var0)
    end

    def edit_name
      __var0 = LibGio.file_info_get_edit_name(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_edit_name") if __var0.null?
      ::String.new(__var0)
    end

    def etag
      __var0 = LibGio.file_info_get_etag(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_etag") if __var0.null?
      ::String.new(__var0)
    end

    def file_type
      __var0 = LibGio.file_info_get_file_type(@pointer.as(LibGio::FileInfo*))
      Gio::FileType.new(__var0)
    end

    def icon
      __var0 = LibGio.file_info_get_icon(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def is_backup
      __var0 = LibGio.file_info_get_is_backup(@pointer.as(LibGio::FileInfo*))
      (__var0 == 1)
    end

    def is_hidden
      __var0 = LibGio.file_info_get_is_hidden(@pointer.as(LibGio::FileInfo*))
      (__var0 == 1)
    end

    def is_symlink
      __var0 = LibGio.file_info_get_is_symlink(@pointer.as(LibGio::FileInfo*))
      (__var0 == 1)
    end

    def modification_date_time
      __var0 = LibGio.file_info_get_modification_date_time(@pointer.as(LibGio::FileInfo*))
      __var1 = GLib::DateTime.new(__var0) if __var0
      __var1
    end

    def modification_time(result : GLib::TimeVal)
      LibGio.file_info_get_modification_time(@pointer.as(LibGio::FileInfo*), result)
      nil
    end

    def name
      __var0 = LibGio.file_info_get_name(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def size
      __var0 = LibGio.file_info_get_size(@pointer.as(LibGio::FileInfo*))
      __var0
    end

    def sort_order
      __var0 = LibGio.file_info_get_sort_order(@pointer.as(LibGio::FileInfo*))
      __var0
    end

    def symbolic_icon
      __var0 = LibGio.file_info_get_symbolic_icon(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_symbolic_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def symlink_target
      __var0 = LibGio.file_info_get_symlink_target(@pointer.as(LibGio::FileInfo*))
      GObject.raise_unexpected_null("g_file_info_get_symlink_target") if __var0.null?
      ::String.new(__var0)
    end

    def has_attribute(attribute : ::String)
      __var0 = LibGio.file_info_has_attribute(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      (__var0 == 1)
    end

    def has_namespace(name_space : ::String)
      __var0 = LibGio.file_info_has_namespace(@pointer.as(LibGio::FileInfo*), name_space.to_unsafe)
      (__var0 == 1)
    end

    def list_attributes(name_space : ::String?)
      __var0 = LibGio.file_info_list_attributes(@pointer.as(LibGio::FileInfo*), name_space ? name_space.to_unsafe : Pointer(UInt8).null)
      __var2 = GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      } if __var0
      __var2
    end

    def remove_attribute(attribute : ::String)
      LibGio.file_info_remove_attribute(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe)
      nil
    end

    def set_attribute(attribute : ::String, type : Gio::FileAttributeType, value_p : Void*)
      LibGio.file_info_set_attribute(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, type, value_p)
      nil
    end

    def set_attribute_boolean(attribute : ::String, attr_value : ::Bool)
      LibGio.file_info_set_attribute_boolean(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, LibC::Int.new(attr_value ? 1 : 0))
      nil
    end

    def set_attribute_byte_string(attribute : ::String, attr_value : ::String)
      LibGio.file_info_set_attribute_byte_string(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, attr_value.to_unsafe)
      nil
    end

    def set_attribute_int32(attribute : ::String, attr_value : ::Int)
      LibGio.file_info_set_attribute_int32(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, Int32.new(attr_value))
      nil
    end

    def set_attribute_int64(attribute : ::String, attr_value : ::Int)
      LibGio.file_info_set_attribute_int64(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, Int64.new(attr_value))
      nil
    end

    def attribute_mask=(mask : Gio::FileAttributeMatcher)
      LibGio.file_info_set_attribute_mask(@pointer.as(LibGio::FileInfo*), mask.to_unsafe.as(LibGio::FileAttributeMatcher*))
      nil
    end

    def set_attribute_object(attribute : ::String, attr_value : GObject::Object)
      LibGio.file_info_set_attribute_object(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, attr_value.to_unsafe_object)
      nil
    end

    def set_attribute_status(attribute : ::String, status : Gio::FileAttributeStatus)
      __var0 = LibGio.file_info_set_attribute_status(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, status)
      (__var0 == 1)
    end

    def set_attribute_string(attribute : ::String, attr_value : ::String)
      LibGio.file_info_set_attribute_string(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, attr_value.to_unsafe)
      nil
    end

    def set_attribute_stringv(attribute : ::String, attr_value : ::Enumerable)
      LibGio.file_info_set_attribute_stringv(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, (__attr_value_ary = attr_value.map { |__item| __item.to_unsafe }.to_a).to_unsafe)
      nil
    end

    def set_attribute_uint32(attribute : ::String, attr_value : ::Int)
      LibGio.file_info_set_attribute_uint32(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, UInt32.new(attr_value))
      nil
    end

    def set_attribute_uint64(attribute : ::String, attr_value : ::Int)
      LibGio.file_info_set_attribute_uint64(@pointer.as(LibGio::FileInfo*), attribute.to_unsafe, UInt64.new(attr_value))
      nil
    end

    def content_type=(content_type : ::String)
      LibGio.file_info_set_content_type(@pointer.as(LibGio::FileInfo*), content_type.to_unsafe)
      nil
    end

    def display_name=(display_name : ::String)
      LibGio.file_info_set_display_name(@pointer.as(LibGio::FileInfo*), display_name.to_unsafe)
      nil
    end

    def edit_name=(edit_name : ::String)
      LibGio.file_info_set_edit_name(@pointer.as(LibGio::FileInfo*), edit_name.to_unsafe)
      nil
    end

    def file_type=(type : Gio::FileType)
      LibGio.file_info_set_file_type(@pointer.as(LibGio::FileInfo*), type)
      nil
    end

    def icon=(icon : Gio::Icon)
      LibGio.file_info_set_icon(@pointer.as(LibGio::FileInfo*), icon.to_unsafe_icon)
      nil
    end

    def is_hidden=(is_hidden : ::Bool)
      LibGio.file_info_set_is_hidden(@pointer.as(LibGio::FileInfo*), LibC::Int.new(is_hidden ? 1 : 0))
      nil
    end

    def is_symlink=(is_symlink : ::Bool)
      LibGio.file_info_set_is_symlink(@pointer.as(LibGio::FileInfo*), LibC::Int.new(is_symlink ? 1 : 0))
      nil
    end

    def modification_date_time=(mtime : GLib::DateTime)
      LibGio.file_info_set_modification_date_time(@pointer.as(LibGio::FileInfo*), mtime.to_unsafe.as(LibGLib::DateTime*))
      nil
    end

    def modification_time=(mtime : GLib::TimeVal)
      LibGio.file_info_set_modification_time(@pointer.as(LibGio::FileInfo*), mtime.to_unsafe.as(LibGLib::TimeVal*))
      nil
    end

    def name=(name : ::String)
      LibGio.file_info_set_name(@pointer.as(LibGio::FileInfo*), name.to_unsafe)
      nil
    end

    def size=(size : ::Int)
      LibGio.file_info_set_size(@pointer.as(LibGio::FileInfo*), Int64.new(size))
      nil
    end

    def sort_order=(sort_order : ::Int)
      LibGio.file_info_set_sort_order(@pointer.as(LibGio::FileInfo*), Int32.new(sort_order))
      nil
    end

    def symbolic_icon=(icon : Gio::Icon)
      LibGio.file_info_set_symbolic_icon(@pointer.as(LibGio::FileInfo*), icon.to_unsafe_icon)
      nil
    end

    def symlink_target=(symlink_target : ::String)
      LibGio.file_info_set_symlink_target(@pointer.as(LibGio::FileInfo*), symlink_target.to_unsafe)
      nil
    end

    def unset_attribute_mask
      LibGio.file_info_unset_attribute_mask(@pointer.as(LibGio::FileInfo*))
      nil
    end
  end

  class FileInfoClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileInfoClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileInfoClass*)
    end

    def to_unsafe_fileinfoclass
      @pointer.not_nil!.as(LibGio::FileInfoClass*)
    end
  end

  class FileInputStream < InputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::FileInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileInputStream*)
    end

    def to_unsafe_fileinputstream
      @pointer.not_nil!.as(LibGio::FileInputStream*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_file_input_stream_get_type, 0, nil, nil).as(Void*)
    end

    def query_info(attributes : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_input_stream_query_info(@pointer.as(LibGio::FileInputStream*), attributes.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_input_stream_query_info") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_info_async(attributes : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_input_stream_query_info_async(@pointer.as(LibGio::FileInputStream*), attributes.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_info_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_input_stream_query_info_finish(@pointer.as(LibGio::FileInputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_input_stream_query_info_finish") if __var1.null?
      Gio::FileInfo.new(__var1)
    end
  end

  class FileInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::FileInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileInputStreamClass*)
    end

    def to_unsafe_fileinputstreamclass
      @pointer.not_nil!.as(LibGio::FileInputStreamClass*)
    end

    def parent_class
      Gio::InputStreamClass.new(to_unsafe.as(LibGio::FileInputStreamClass*).value.parent_class)
    end

    def tell
      to_unsafe.as(LibGio::FileInputStreamClass*).value.tell
    end

    def can_seek
      to_unsafe.as(LibGio::FileInputStreamClass*).value.can_seek
    end

    def seek
      to_unsafe.as(LibGio::FileInputStreamClass*).value.seek
    end

    def query_info
      to_unsafe.as(LibGio::FileInputStreamClass*).value.query_info
    end

    def query_info_async
      to_unsafe.as(LibGio::FileInputStreamClass*).value.query_info_async
    end

    def query_info_finish
      to_unsafe.as(LibGio::FileInputStreamClass*).value.query_info_finish
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FileInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FileInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FileInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::FileInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::FileInputStreamClass*).value._g_reserved5
    end
  end

  class FileInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileInputStreamPrivate*)
    end

    def to_unsafe_fileinputstreamprivate
      @pointer.not_nil!.as(LibGio::FileInputStreamPrivate*)
    end
  end

  @[Flags]
  enum FileMeasureFlags : UInt32
    NONE             = 0
    REPORT_ANY_ERROR = 2
    APPARENT_SIZE    = 4
    NO_XDEV          = 8
  end
  alias FileMeasureProgressCallback = LibGio::FileMeasureProgressCallback

  class FileMonitor < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::FileMonitor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_monitor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileMonitor*)
    end

    def to_unsafe_filemonitor
      @pointer.not_nil!.as(LibGio::FileMonitor*)
    end

    def cancel
      __var0 = LibGio.file_monitor_cancel(@pointer.as(LibGio::FileMonitor*))
      (__var0 == 1)
    end

    def emit_event(child : Gio::File, other_file : Gio::File, event_type : Gio::FileMonitorEvent)
      LibGio.file_monitor_emit_event(@pointer.as(LibGio::FileMonitor*), child.to_unsafe_file, other_file.to_unsafe_file, event_type)
      nil
    end

    def cancelled?
      __var0 = LibGio.file_monitor_is_cancelled(@pointer.as(LibGio::FileMonitor*))
      (__var0 == 1)
    end

    def rate_limit=(limit_msecs : ::Int)
      LibGio.file_monitor_set_rate_limit(@pointer.as(LibGio::FileMonitor*), Int32.new(limit_msecs))
      nil
    end

    def cancelled : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "cancelled", __var0)
      __var0.boolean
    end

    alias ChangedSignal = FileMonitor, Gio::File, Gio::File?, Gio::FileMonitorEvent -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::FileMonitor*, arg1 : LibGio::File*, arg2 : LibGio::File*, arg3 : LibGio::FileMonitorEvent, box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(FileMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("file in changed") : Gio::File::Wrapper.new(arg1), arg2.null? ? nil : Gio::File::Wrapper.new(arg2), Gio::FileMonitorEvent.new(arg3))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end
  end

  class FileMonitorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(192u64, 0u8).as(LibGio::FileMonitorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileMonitorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileMonitorClass*)
    end

    def to_unsafe_filemonitorclass
      @pointer.not_nil!.as(LibGio::FileMonitorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::FileMonitorClass*).value.parent_class)
    end

    def changed
      to_unsafe.as(LibGio::FileMonitorClass*).value.changed
    end

    def cancel
      to_unsafe.as(LibGio::FileMonitorClass*).value.cancel
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FileMonitorClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FileMonitorClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FileMonitorClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::FileMonitorClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::FileMonitorClass*).value._g_reserved5
    end
  end

  enum FileMonitorEvent : UInt32
    CHANGED           =  0
    CHANGES_DONE_HINT =  1
    DELETED           =  2
    CREATED           =  3
    ATTRIBUTE_CHANGED =  4
    PRE_UNMOUNT       =  5
    UNMOUNTED         =  6
    MOVED             =  7
    RENAMED           =  8
    MOVED_IN          =  9
    MOVED_OUT         = 10
  end

  @[Flags]
  enum FileMonitorFlags : UInt32
    NONE             = 0
    WATCH_MOUNTS     = 1
    SEND_MOVED       = 2
    WATCH_HARD_LINKS = 4
    WATCH_MOVES      = 8
  end

  class FileMonitorPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileMonitorPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileMonitorPrivate*)
    end

    def to_unsafe_filemonitorprivate
      @pointer.not_nil!.as(LibGio::FileMonitorPrivate*)
    end
  end

  class FileOutputStream < OutputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::FileOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileOutputStream*)
    end

    def to_unsafe_fileoutputstream
      @pointer.not_nil!.as(LibGio::FileOutputStream*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_file_output_stream_get_type, 0, nil, nil).as(Void*)
    end

    def etag
      __var0 = LibGio.file_output_stream_get_etag(@pointer.as(LibGio::FileOutputStream*))
      GObject.raise_unexpected_null("g_file_output_stream_get_etag") if __var0.null?
      ::String.new(__var0)
    end

    def query_info(attributes : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_output_stream_query_info(@pointer.as(LibGio::FileOutputStream*), attributes.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_output_stream_query_info") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_info_async(attributes : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_output_stream_query_info_async(@pointer.as(LibGio::FileOutputStream*), attributes.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_info_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_output_stream_query_info_finish(@pointer.as(LibGio::FileOutputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_output_stream_query_info_finish") if __var1.null?
      Gio::FileInfo.new(__var1)
    end
  end

  class FileOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(408u64, 0u8).as(LibGio::FileOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FileOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileOutputStreamClass*)
    end

    def to_unsafe_fileoutputstreamclass
      @pointer.not_nil!.as(LibGio::FileOutputStreamClass*)
    end

    def parent_class
      Gio::OutputStreamClass.new(to_unsafe.as(LibGio::FileOutputStreamClass*).value.parent_class)
    end

    def tell
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.tell
    end

    def can_seek
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.can_seek
    end

    def seek
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.seek
    end

    def can_truncate
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.can_truncate
    end

    def truncate_fn
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.truncate_fn
    end

    def query_info
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.query_info
    end

    def query_info_async
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.query_info_async
    end

    def query_info_finish
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.query_info_finish
    end

    def get_etag
      to_unsafe.as(LibGio::FileOutputStreamClass*).value.get_etag
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FileOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FileOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FileOutputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::FileOutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::FileOutputStreamClass*).value._g_reserved5
    end
  end

  class FileOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::FileOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileOutputStreamPrivate*)
    end

    def to_unsafe_fileoutputstreamprivate
      @pointer.not_nil!.as(LibGio::FileOutputStreamPrivate*)
    end
  end

  alias FileProgressCallback = LibGio::FileProgressCallback

  @[Flags]
  enum FileQueryInfoFlags : UInt32
    NONE              = 0
    NOFOLLOW_SYMLINKS = 1
  end
  alias FileReadMoreCallback = LibGio::FileReadMoreCallback

  enum FileType : UInt32
    UNKNOWN       = 0
    REGULAR       = 1
    DIRECTORY     = 2
    SYMBOLIC_LINK = 3
    SPECIAL       = 4
    SHORTCUT      = 5
    MOUNTABLE     = 6
  end

  class FilenameCompleter < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::FilenameCompleter*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFilenameCompleter")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_filename_completer_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilenameCompleter*)
    end

    def to_unsafe_filenamecompleter
      @pointer.not_nil!.as(LibGio::FilenameCompleter*)
    end

    def self.new : self
      __var0 = LibGio.filename_completer_new
      GObject.raise_unexpected_null("g_filename_completer_new") if __var0.null?
      cast(Gio::FilenameCompleter.new(__var0))
    end

    def completion_suffix(initial_text : ::String)
      __var0 = LibGio.filename_completer_get_completion_suffix(@pointer.as(LibGio::FilenameCompleter*), initial_text.to_unsafe)
      GObject.raise_unexpected_null("g_filename_completer_get_completion_suffix") if __var0.null?
      ::String.new(__var0)
    end

    def completions(initial_text : ::String)
      __var0 = LibGio.filename_completer_get_completions(@pointer.as(LibGio::FilenameCompleter*), initial_text.to_unsafe)
      GObject.raise_unexpected_null("g_filename_completer_get_completions") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def dirs_only=(dirs_only : ::Bool)
      LibGio.filename_completer_set_dirs_only(@pointer.as(LibGio::FilenameCompleter*), LibC::Int.new(dirs_only ? 1 : 0))
      nil
    end

    alias GotCompletionDataSignal = FilenameCompleter -> Nil

    def on_got_completion_data(*, after = false, &block : GotCompletionDataSignal)
      __var0 = ->(arg0 : LibGio::FilenameCompleter*, box : Void*) {
        ::Box(GotCompletionDataSignal).unbox(box).call(FilenameCompleter.new(arg0))
      }

      __var1 = ::Box.box(GotCompletionDataSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "got-completion-data", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_got_completion_data(&block : GotCompletionDataSignal)
      on_got_completion_data(after: true, &block)
    end
  end

  class FilenameCompleterClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(168u64, 0u8).as(LibGio::FilenameCompleterClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FilenameCompleterClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilenameCompleterClass*)
    end

    def to_unsafe_filenamecompleterclass
      @pointer.not_nil!.as(LibGio::FilenameCompleterClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::FilenameCompleterClass*).value.parent_class)
    end

    def got_completion_data
      to_unsafe.as(LibGio::FilenameCompleterClass*).value.got_completion_data
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FilenameCompleterClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FilenameCompleterClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FilenameCompleterClass*).value._g_reserved3
    end
  end

  enum FilesystemPreviewType : UInt32
    IF_ALWAYS = 0
    IF_LOCAL  = 1
    NEVER     = 2
  end

  class BufferedInputStream < FilterInputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GBufferedInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_buffered_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedInputStream*)
    end

    def to_unsafe_bufferedinputstream
      @pointer.not_nil!.as(LibGio::BufferedInputStream*)
    end

    def initialize(*, base_stream : Gio::InputStream? = nil, buffer_size : UInt32? = nil, close_base_stream : ::Bool? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless buffer_size.nil?
        __var0 << "buffer-size".to_unsafe
        __var1 << buffer_size.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_buffered_input_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::InputStream) : self
      __var0 = LibGio.buffered_input_stream_new(base_stream.to_unsafe_inputstream)
      GObject.raise_unexpected_null("g_buffered_input_stream_new") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def self.new_sized(base_stream : Gio::InputStream, size : ::Int) : self
      __var0 = LibGio.buffered_input_stream_new_sized(base_stream.to_unsafe_inputstream, UInt64.new(size))
      GObject.raise_unexpected_null("g_buffered_input_stream_new_sized") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def fill(count : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.buffered_input_stream_fill(@pointer.as(LibGio::BufferedInputStream*), Int64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def fill_async(count : ::Int, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.buffered_input_stream_fill_async(@pointer.as(LibGio::BufferedInputStream*), Int64.new(count), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def fill_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.buffered_input_stream_fill_finish(@pointer.as(LibGio::BufferedInputStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def available
      __var0 = LibGio.buffered_input_stream_get_available(@pointer.as(LibGio::BufferedInputStream*))
      __var0
    end

    def buffer_size
      __var0 = LibGio.buffered_input_stream_get_buffer_size(@pointer.as(LibGio::BufferedInputStream*))
      __var0
    end

    def peek(buffer : ::Bytes, offset : ::Int)
      count = buffer.size
      __var0 = LibGio.buffered_input_stream_peek(@pointer.as(LibGio::BufferedInputStream*), buffer.to_unsafe, UInt64.new(offset), UInt64.new(count))
      __var0
    end

    def peek_buffer
      __var0 = LibGio.buffered_input_stream_peek_buffer(@pointer.as(LibGio::BufferedInputStream*), out count)
      GObject.raise_unexpected_null("g_buffered_input_stream_peek_buffer") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        __var1
      }, count}
    end

    def read_byte(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.buffered_input_stream_read_byte(@pointer.as(LibGio::BufferedInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def buffer_size=(size : ::Int)
      LibGio.buffered_input_stream_set_buffer_size(@pointer.as(LibGio::BufferedInputStream*), UInt64.new(size))
      nil
    end
  end

  class FilterInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(272u64, 0u8).as(LibGio::FilterInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FilterInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilterInputStreamClass*)
    end

    def to_unsafe_filterinputstreamclass
      @pointer.not_nil!.as(LibGio::FilterInputStreamClass*)
    end

    def parent_class
      Gio::InputStreamClass.new(to_unsafe.as(LibGio::FilterInputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FilterInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FilterInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FilterInputStreamClass*).value._g_reserved3
    end
  end

  class BufferedOutputStream < FilterOutputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::BufferedOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GBufferedOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_buffered_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BufferedOutputStream*)
    end

    def to_unsafe_bufferedoutputstream
      @pointer.not_nil!.as(LibGio::BufferedOutputStream*)
    end

    def initialize(*, auto_grow : ::Bool? = nil, base_stream : Gio::OutputStream? = nil, buffer_size : UInt32? = nil, close_base_stream : ::Bool? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless auto_grow.nil?
        __var0 << "auto-grow".to_unsafe
        __var1 << auto_grow.to_gvalue.to_unsafe.value
      end

      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless buffer_size.nil?
        __var0 << "buffer-size".to_unsafe
        __var1 << buffer_size.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_buffered_output_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::OutputStream) : self
      __var0 = LibGio.buffered_output_stream_new(base_stream.to_unsafe_outputstream)
      GObject.raise_unexpected_null("g_buffered_output_stream_new") if __var0.null?
      cast(Gio::OutputStream.new(__var0))
    end

    def self.new_sized(base_stream : Gio::OutputStream, size : ::Int) : self
      __var0 = LibGio.buffered_output_stream_new_sized(base_stream.to_unsafe_outputstream, UInt64.new(size))
      GObject.raise_unexpected_null("g_buffered_output_stream_new_sized") if __var0.null?
      cast(Gio::OutputStream.new(__var0))
    end

    def auto_grow
      __var0 = LibGio.buffered_output_stream_get_auto_grow(@pointer.as(LibGio::BufferedOutputStream*))
      (__var0 == 1)
    end

    def buffer_size
      __var0 = LibGio.buffered_output_stream_get_buffer_size(@pointer.as(LibGio::BufferedOutputStream*))
      __var0
    end

    def auto_grow=(auto_grow : ::Bool)
      LibGio.buffered_output_stream_set_auto_grow(@pointer.as(LibGio::BufferedOutputStream*), LibC::Int.new(auto_grow ? 1 : 0))
      nil
    end

    def buffer_size=(size : ::Int)
      LibGio.buffered_output_stream_set_buffer_size(@pointer.as(LibGio::BufferedOutputStream*), UInt64.new(size))
      nil
    end
  end

  class FilterOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(320u64, 0u8).as(LibGio::FilterOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::FilterOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FilterOutputStreamClass*)
    end

    def to_unsafe_filteroutputstreamclass
      @pointer.not_nil!.as(LibGio::FilterOutputStreamClass*)
    end

    def parent_class
      Gio::OutputStreamClass.new(to_unsafe.as(LibGio::FilterOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::FilterOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::FilterOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::FilterOutputStreamClass*).value._g_reserved3
    end
  end

  enum IOErrorEnum : UInt32
    FAILED              =  0
    NOT_FOUND           =  1
    EXISTS              =  2
    IS_DIRECTORY        =  3
    NOT_DIRECTORY       =  4
    NOT_EMPTY           =  5
    NOT_REGULAR_FILE    =  6
    NOT_SYMBOLIC_LINK   =  7
    NOT_MOUNTABLE_FILE  =  8
    FILENAME_TOO_LONG   =  9
    INVALID_FILENAME    = 10
    TOO_MANY_LINKS      = 11
    NO_SPACE            = 12
    INVALID_ARGUMENT    = 13
    PERMISSION_DENIED   = 14
    NOT_SUPPORTED       = 15
    NOT_MOUNTED         = 16
    ALREADY_MOUNTED     = 17
    CLOSED              = 18
    CANCELLED           = 19
    PENDING             = 20
    READ_ONLY           = 21
    CANT_CREATE_BACKUP  = 22
    WRONG_ETAG          = 23
    TIMED_OUT           = 24
    WOULD_RECURSE       = 25
    BUSY                = 26
    WOULD_BLOCK         = 27
    HOST_NOT_FOUND      = 28
    WOULD_MERGE         = 29
    FAILED_HANDLED      = 30
    TOO_MANY_OPEN_FILES = 31
    NOT_INITIALIZED     = 32
    ADDRESS_IN_USE      = 33
    PARTIAL_INPUT       = 34
    INVALID_DATA        = 35
    DBUS_ERROR          = 36
    HOST_UNREACHABLE    = 37
    NETWORK_UNREACHABLE = 38
    CONNECTION_REFUSED  = 39
    PROXY_FAILED        = 40
    PROXY_AUTH_FAILED   = 41
    PROXY_NEED_AUTH     = 42
    PROXY_NOT_ALLOWED   = 43
    BROKEN_PIPE         = 44
    CONNECTION_CLOSED   = 44
    NOT_CONNECTED       = 45
    MESSAGE_TOO_LARGE   = 46
  end

  class IOExtension
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOExtension*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOExtension*)
    end

    def to_unsafe_ioextension
      @pointer.not_nil!.as(LibGio::IOExtension*)
    end

    def name
      __var0 = LibGio.i_o_extension_get_name(@pointer.as(LibGio::IOExtension*))
      GObject.raise_unexpected_null("g_io_extension_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def priority
      __var0 = LibGio.i_o_extension_get_priority(@pointer.as(LibGio::IOExtension*))
      __var0
    end

    def type
      __var0 = LibGio.i_o_extension_get_type(@pointer.as(LibGio::IOExtension*))
      __var0
    end
  end

  class IOExtensionPoint
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOExtensionPoint*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOExtensionPoint*)
    end

    def to_unsafe_ioextensionpoint
      @pointer.not_nil!.as(LibGio::IOExtensionPoint*)
    end

    def extension_by_name(name : ::String)
      __var0 = LibGio.i_o_extension_point_get_extension_by_name(@pointer.as(LibGio::IOExtensionPoint*), name.to_unsafe)
      GObject.raise_unexpected_null("g_io_extension_point_get_extension_by_name") if __var0.null?
      Gio::IOExtension.new(__var0)
    end

    def extensions
      __var0 = LibGio.i_o_extension_point_get_extensions(@pointer.as(LibGio::IOExtensionPoint*))
      GObject.raise_unexpected_null("g_io_extension_point_get_extensions") if __var0.null?
      GLib::ListIterator(Gio::IOExtension, Pointer(LibGio::IOExtension)*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def required_type
      __var0 = LibGio.i_o_extension_point_get_required_type(@pointer.as(LibGio::IOExtensionPoint*))
      __var0
    end

    def required_type=(type : UInt64)
      LibGio.i_o_extension_point_set_required_type(@pointer.as(LibGio::IOExtensionPoint*), UInt64.new(type))
      nil
    end

    def self.implement(extension_point_name : ::String, type : UInt64, extension_name : ::String, priority : ::Int)
      __var0 = LibGio.i_o_extension_point_implement(extension_point_name.to_unsafe, UInt64.new(type), extension_name.to_unsafe, Int32.new(priority))
      GObject.raise_unexpected_null("g_io_extension_point_implement") if __var0.null?
      Gio::IOExtension.new(__var0)
    end

    def self.lookup(name : ::String)
      __var0 = LibGio.i_o_extension_point_lookup(name.to_unsafe)
      GObject.raise_unexpected_null("g_io_extension_point_lookup") if __var0.null?
      Gio::IOExtensionPoint.new(__var0)
    end

    def self.register(name : ::String)
      __var0 = LibGio.i_o_extension_point_register(name.to_unsafe)
      GObject.raise_unexpected_null("g_io_extension_point_register") if __var0.null?
      Gio::IOExtensionPoint.new(__var0)
    end
  end

  class IOModule < GObject::TypeModule
    include GObject::TypePlugin

    @pointer : Void*

    def initialize(pointer : LibGio::IOModule*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GIOModule")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_io_module_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOModule*)
    end

    def to_unsafe_iomodule
      @pointer.not_nil!.as(LibGio::IOModule*)
    end

    def self.new(filename : ::String) : self
      __var0 = LibGio.i_o_module_new(filename.to_unsafe)
      GObject.raise_unexpected_null("g_io_module_new") if __var0.null?
      cast(Gio::IOModule.new(__var0))
    end

    def self.query
      __var0 = LibGio.i_o_module_query
      GObject.raise_unexpected_null("g_io_module_query") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def load
      LibGio.i_o_module_load(@pointer.as(LibGio::IOModule*))
      nil
    end

    def unload
      LibGio.i_o_module_unload(@pointer.as(LibGio::IOModule*))
      nil
    end
  end

  class IOModuleClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOModuleClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOModuleClass*)
    end

    def to_unsafe_iomoduleclass
      @pointer.not_nil!.as(LibGio::IOModuleClass*)
    end
  end

  class IOModuleScope
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOModuleScope*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOModuleScope*)
    end

    def to_unsafe_iomodulescope
      @pointer.not_nil!.as(LibGio::IOModuleScope*)
    end

    def block(basename : ::String)
      LibGio.i_o_module_scope_block(@pointer.as(LibGio::IOModuleScope*), basename.to_unsafe)
      nil
    end

    def free
      LibGio.i_o_module_scope_free(@pointer.as(LibGio::IOModuleScope*))
      nil
    end
  end

  enum IOModuleScopeFlags : UInt32
    NONE             = 0
    BLOCK_DUPLICATES = 1
  end

  class IOSchedulerJob
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOSchedulerJob*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOSchedulerJob*)
    end

    def to_unsafe_ioschedulerjob
      @pointer.not_nil!.as(LibGio::IOSchedulerJob*)
    end

    def send_to_mainloop(func : GLib::SourceFunc, user_data : Void*?, notify : GLib::DestroyNotify?)
      __var0 = LibGio.i_o_scheduler_job_send_to_mainloop(@pointer.as(LibGio::IOSchedulerJob*), func, user_data ? user_data : Pointer(Void).null, notify ? notify : nil)
      (__var0 == 1)
    end

    def send_to_mainloop_async(func : GLib::SourceFunc, user_data : Void*?, notify : GLib::DestroyNotify?)
      LibGio.i_o_scheduler_job_send_to_mainloop_async(@pointer.as(LibGio::IOSchedulerJob*), func, user_data ? user_data : Pointer(Void).null, notify ? notify : nil)
      nil
    end
  end

  alias IOSchedulerJobFunc = LibGio::IOSchedulerJobFunc

  class FileIOStream < IOStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::FileIOStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileIOStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_io_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIOStream*)
    end

    def to_unsafe_fileiostream
      @pointer.not_nil!.as(LibGio::FileIOStream*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_file_io_stream_get_type, 0, nil, nil).as(Void*)
    end

    def etag
      __var0 = LibGio.file_i_o_stream_get_etag(@pointer.as(LibGio::FileIOStream*))
      GObject.raise_unexpected_null("g_file_io_stream_get_etag") if __var0.null?
      ::String.new(__var0)
    end

    def query_info(attributes : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_i_o_stream_query_info(@pointer.as(LibGio::FileIOStream*), attributes.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_io_stream_query_info") if __var1.null?
      Gio::FileInfo.new(__var1)
    end

    def query_info_async(attributes : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.file_i_o_stream_query_info_async(@pointer.as(LibGio::FileIOStream*), attributes.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def query_info_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.file_i_o_stream_query_info_finish(@pointer.as(LibGio::FileIOStream*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_file_io_stream_query_info_finish") if __var1.null?
      Gio::FileInfo.new(__var1)
    end
  end

  class IOStreamAdapter
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOStreamAdapter*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOStreamAdapter*)
    end

    def to_unsafe_iostreamadapter
      @pointer.not_nil!.as(LibGio::IOStreamAdapter*)
    end
  end

  class IOStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(256u64, 0u8).as(LibGio::IOStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::IOStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOStreamClass*)
    end

    def to_unsafe_iostreamclass
      @pointer.not_nil!.as(LibGio::IOStreamClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::IOStreamClass*).value.parent_class)
    end

    def get_input_stream
      to_unsafe.as(LibGio::IOStreamClass*).value.get_input_stream
    end

    def get_output_stream
      to_unsafe.as(LibGio::IOStreamClass*).value.get_output_stream
    end

    def close_fn
      to_unsafe.as(LibGio::IOStreamClass*).value.close_fn
    end

    def close_async
      to_unsafe.as(LibGio::IOStreamClass*).value.close_async
    end

    def close_finish
      to_unsafe.as(LibGio::IOStreamClass*).value.close_finish
    end

    def _g_reserved1
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved7
    end

    def _g_reserved8
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved8
    end

    def _g_reserved9
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved9
    end

    def _g_reserved10
      to_unsafe.as(LibGio::IOStreamClass*).value._g_reserved10
    end
  end

  class IOStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::IOStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IOStreamPrivate*)
    end

    def to_unsafe_iostreamprivate
      @pointer.not_nil!.as(LibGio::IOStreamPrivate*)
    end
  end

  @[Flags]
  enum IOStreamSpliceFlags : UInt32
    NONE          = 0
    CLOSE_STREAM1 = 1
    CLOSE_STREAM2 = 2
    WAIT_FOR_BOTH = 4
  end

  class BytesIcon < GObject::Object
    include Gio::Icon
    include Gio::LoadableIcon

    @pointer : Void*

    def initialize(pointer : LibGio::BytesIcon*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GBytesIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_bytes_icon_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::BytesIcon*)
    end

    def to_unsafe_bytesicon
      @pointer.not_nil!.as(LibGio::BytesIcon*)
    end

    def initialize(*, bytes : GLib::Bytes? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless bytes.nil?
        __var0 << "bytes".to_unsafe
        __var1 << bytes.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_bytes_icon_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(bytes : GLib::Bytes) : self
      __var0 = LibGio.bytes_icon_new(bytes.to_unsafe.as(LibGLib::Bytes*))
      GObject.raise_unexpected_null("g_bytes_icon_new") if __var0.null?
      cast(Gio::BytesIcon.new(__var0))
    end

    def bytes
      __var0 = LibGio.bytes_icon_get_bytes(@pointer.as(LibGio::BytesIcon*))
      GObject.raise_unexpected_null("g_bytes_icon_get_bytes") if __var0.null?
      GLib::Bytes.new(__var0)
    end
  end

  class IconIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::IconIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::IconIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::IconIface*)
    end

    def to_unsafe_iconiface
      @pointer.not_nil!.as(LibGio::IconIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::IconIface*).value.g_iface)
    end

    def hash
      to_unsafe.as(LibGio::IconIface*).value.hash
    end

    def equal
      to_unsafe.as(LibGio::IconIface*).value.equal
    end

    def to_tokens
      to_unsafe.as(LibGio::IconIface*).value.to_tokens
    end

    def from_tokens
      to_unsafe.as(LibGio::IconIface*).value.from_tokens
    end

    def serialize
      to_unsafe.as(LibGio::IconIface*).value.serialize
    end
  end

  class InetAddress < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::InetAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GInetAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_inet_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddress*)
    end

    def to_unsafe_inetaddress
      @pointer.not_nil!.as(LibGio::InetAddress*)
    end

    def initialize(*, bytes : Void*? = nil, family : Gio::SocketFamily? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless bytes.nil?
        __var0 << "bytes".to_unsafe
        __var1 << bytes.to_gvalue.to_unsafe.value
      end

      unless family.nil?
        __var0 << "family".to_unsafe
        __var1 << family.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_inet_address_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_any(family : Gio::SocketFamily) : self
      __var0 = LibGio.inet_address_new_any(family)
      GObject.raise_unexpected_null("g_inet_address_new_any") if __var0.null?
      cast(Gio::InetAddress.new(__var0))
    end

    def self.new_from_bytes(bytes : ::Bytes, family : Gio::SocketFamily) : self
      __var0 = LibGio.inet_address_new_from_bytes(bytes.to_unsafe, family)
      GObject.raise_unexpected_null("g_inet_address_new_from_bytes") if __var0.null?
      cast(Gio::InetAddress.new(__var0))
    end

    def self.new_from_string(string : ::String) : self
      __var0 = LibGio.inet_address_new_from_string(string.to_unsafe)
      GObject.raise_unexpected_null("g_inet_address_new_from_string") if __var0.null?
      cast(Gio::InetAddress.new(__var0))
    end

    def self.new_loopback(family : Gio::SocketFamily) : self
      __var0 = LibGio.inet_address_new_loopback(family)
      GObject.raise_unexpected_null("g_inet_address_new_loopback") if __var0.null?
      cast(Gio::InetAddress.new(__var0))
    end

    def equal(other_address : Gio::InetAddress)
      __var0 = LibGio.inet_address_equal(@pointer.as(LibGio::InetAddress*), other_address.to_unsafe_inetaddress)
      (__var0 == 1)
    end

    def family
      __var0 = LibGio.inet_address_get_family(@pointer.as(LibGio::InetAddress*))
      Gio::SocketFamily.new(__var0)
    end

    def is_any
      __var0 = LibGio.inet_address_get_is_any(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_link_local
      __var0 = LibGio.inet_address_get_is_link_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_loopback
      __var0 = LibGio.inet_address_get_is_loopback(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_mc_global
      __var0 = LibGio.inet_address_get_is_mc_global(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_mc_link_local
      __var0 = LibGio.inet_address_get_is_mc_link_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_mc_node_local
      __var0 = LibGio.inet_address_get_is_mc_node_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_mc_org_local
      __var0 = LibGio.inet_address_get_is_mc_org_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_mc_site_local
      __var0 = LibGio.inet_address_get_is_mc_site_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_multicast
      __var0 = LibGio.inet_address_get_is_multicast(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def is_site_local
      __var0 = LibGio.inet_address_get_is_site_local(@pointer.as(LibGio::InetAddress*))
      (__var0 == 1)
    end

    def native_size
      __var0 = LibGio.inet_address_get_native_size(@pointer.as(LibGio::InetAddress*))
      __var0
    end

    def to_string
      __var0 = LibGio.inet_address_to_string(@pointer.as(LibGio::InetAddress*))
      GObject.raise_unexpected_null("g_inet_address_to_string") if __var0.null?
      ::String.new(__var0)
    end

    def bytes : Void*
      __var0 = GObject::Value.new(type: GObject::Type::VOID)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "bytes", __var0)
      __var0
    end
  end

  class InetAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(152u64, 0u8).as(LibGio::InetAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InetAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddressClass*)
    end

    def to_unsafe_inetaddressclass
      @pointer.not_nil!.as(LibGio::InetAddressClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::InetAddressClass*).value.parent_class)
    end

    def to_string
      to_unsafe.as(LibGio::InetAddressClass*).value.to_string
    end

    def to_bytes
      to_unsafe.as(LibGio::InetAddressClass*).value.to_bytes
    end
  end

  class InetAddressMask < GObject::Object
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::InetAddressMask*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GInetAddressMask")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_inet_address_mask_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddressMask*)
    end

    def to_unsafe_inetaddressmask
      @pointer.not_nil!.as(LibGio::InetAddressMask*)
    end

    def initialize(*, address : Gio::InetAddress? = nil, length : UInt32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless address.nil?
        __var0 << "address".to_unsafe
        __var1 << address.to_gvalue.to_unsafe.value
      end

      unless length.nil?
        __var0 << "length".to_unsafe
        __var1 << length.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_inet_address_mask_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(addr : Gio::InetAddress, length : ::Int) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.inet_address_mask_new(addr.to_unsafe_inetaddress, UInt32.new(length), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_inet_address_mask_new") if __var1.null?
      cast(Gio::InetAddressMask.new(__var1))
    end

    def self.new_from_string(mask_string : ::String) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.inet_address_mask_new_from_string(mask_string.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_inet_address_mask_new_from_string") if __var1.null?
      cast(Gio::InetAddressMask.new(__var1))
    end

    def equal(mask2 : Gio::InetAddressMask)
      __var0 = LibGio.inet_address_mask_equal(@pointer.as(LibGio::InetAddressMask*), mask2.to_unsafe_inetaddressmask)
      (__var0 == 1)
    end

    def address
      __var0 = LibGio.inet_address_mask_get_address(@pointer.as(LibGio::InetAddressMask*))
      GObject.raise_unexpected_null("g_inet_address_mask_get_address") if __var0.null?
      Gio::InetAddress.new(__var0)
    end

    def family
      __var0 = LibGio.inet_address_mask_get_family(@pointer.as(LibGio::InetAddressMask*))
      Gio::SocketFamily.new(__var0)
    end

    def length
      __var0 = LibGio.inet_address_mask_get_length(@pointer.as(LibGio::InetAddressMask*))
      __var0
    end

    def matches(address : Gio::InetAddress)
      __var0 = LibGio.inet_address_mask_matches(@pointer.as(LibGio::InetAddressMask*), address.to_unsafe_inetaddress)
      (__var0 == 1)
    end

    def to_string
      __var0 = LibGio.inet_address_mask_to_string(@pointer.as(LibGio::InetAddressMask*))
      GObject.raise_unexpected_null("g_inet_address_mask_to_string") if __var0.null?
      ::String.new(__var0)
    end
  end

  class InetAddressMaskClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::InetAddressMaskClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InetAddressMaskClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddressMaskClass*)
    end

    def to_unsafe_inetaddressmaskclass
      @pointer.not_nil!.as(LibGio::InetAddressMaskClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::InetAddressMaskClass*).value.parent_class)
    end
  end

  class InetAddressMaskPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::InetAddressMaskPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddressMaskPrivate*)
    end

    def to_unsafe_inetaddressmaskprivate
      @pointer.not_nil!.as(LibGio::InetAddressMaskPrivate*)
    end
  end

  class InetAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::InetAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetAddressPrivate*)
    end

    def to_unsafe_inetaddressprivate
      @pointer.not_nil!.as(LibGio::InetAddressPrivate*)
    end
  end

  module SocketConnectable
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include SocketConnectable
      @pointer : Void*

      def initialize(pointer : LibGio::SocketConnectable*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GSocketConnectable")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_connectable_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::SocketConnectable*)
      end

      def to_unsafe_socketconnectable
        @pointer.not_nil!.as(LibGio::SocketConnectable*)
      end
    end

    def to_unsafe_socketconnectable
      @pointer.not_nil!.as(LibGio::SocketConnectable*)
    end

    def enumerate
      __var0 = LibGio.socket_connectable_enumerate(@pointer.as(LibGio::SocketConnectable*))
      GObject.raise_unexpected_null("g_socket_connectable_enumerate") if __var0.null?
      Gio::SocketAddressEnumerator.new(__var0)
    end

    def proxy_enumerate
      __var0 = LibGio.socket_connectable_proxy_enumerate(@pointer.as(LibGio::SocketConnectable*))
      GObject.raise_unexpected_null("g_socket_connectable_proxy_enumerate") if __var0.null?
      Gio::SocketAddressEnumerator.new(__var0)
    end

    def to_string
      __var0 = LibGio.socket_connectable_to_string(@pointer.as(LibGio::SocketConnectable*))
      GObject.raise_unexpected_null("g_socket_connectable_to_string") if __var0.null?
      ::String.new(__var0)
    end
  end

  class InetSocketAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::InetSocketAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InetSocketAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetSocketAddressClass*)
    end

    def to_unsafe_inetsocketaddressclass
      @pointer.not_nil!.as(LibGio::InetSocketAddressClass*)
    end

    def parent_class
      Gio::SocketAddressClass.new(to_unsafe.as(LibGio::InetSocketAddressClass*).value.parent_class)
    end
  end

  class InetSocketAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::InetSocketAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetSocketAddressPrivate*)
    end

    def to_unsafe_inetsocketaddressprivate
      @pointer.not_nil!.as(LibGio::InetSocketAddressPrivate*)
    end
  end

  class CharsetConverter < GObject::Object
    include Gio::Converter
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::CharsetConverter*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GCharsetConverter")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_charset_converter_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::CharsetConverter*)
    end

    def to_unsafe_charsetconverter
      @pointer.not_nil!.as(LibGio::CharsetConverter*)
    end

    def initialize(*, from_charset : ::String? = nil, to_charset : ::String? = nil, use_fallback : ::Bool? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless from_charset.nil?
        __var0 << "from-charset".to_unsafe
        __var1 << from_charset.to_gvalue.to_unsafe.value
      end

      unless to_charset.nil?
        __var0 << "to-charset".to_unsafe
        __var1 << to_charset.to_gvalue.to_unsafe.value
      end

      unless use_fallback.nil?
        __var0 << "use-fallback".to_unsafe
        __var1 << use_fallback.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_charset_converter_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(to_charset : ::String, from_charset : ::String) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.charset_converter_new(to_charset.to_unsafe, from_charset.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_charset_converter_new") if __var1.null?
      cast(Gio::CharsetConverter.new(__var1))
    end

    def num_fallbacks
      __var0 = LibGio.charset_converter_get_num_fallbacks(@pointer.as(LibGio::CharsetConverter*))
      __var0
    end

    def use_fallback
      __var0 = LibGio.charset_converter_get_use_fallback(@pointer.as(LibGio::CharsetConverter*))
      (__var0 == 1)
    end

    def use_fallback=(use_fallback : ::Bool)
      LibGio.charset_converter_set_use_fallback(@pointer.as(LibGio::CharsetConverter*), LibC::Int.new(use_fallback ? 1 : 0))
      nil
    end

    def from_charset : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "from-charset", __var0)
      __var0.string
    end

    def to_charset : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "to-charset", __var0)
      __var0.string
    end
  end

  class InitableIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(24u64, 0u8).as(LibGio::InitableIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InitableIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InitableIface*)
    end

    def to_unsafe_initableiface
      @pointer.not_nil!.as(LibGio::InitableIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::InitableIface*).value.g_iface)
    end

    def init
      to_unsafe.as(LibGio::InitableIface*).value.init
    end
  end

  class InputMessage
    include GObject::WrappedType

    def self.new(address : Gio::SocketAddress? = nil, vectors : ::Enumerable(Gio::InputVector)? = nil, num_vectors : UInt32? = nil, bytes_received : UInt64? = nil, flags : Int32? = nil, control_messages : ::Enumerable(Gio::SocketControlMessage)? = nil, num_control_messages : UInt32? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::InputMessage*))
      __var0.address = address unless address.nil?
      __var0.vectors = vectors unless vectors.nil?
      __var0.num_vectors = num_vectors unless num_vectors.nil?
      __var0.bytes_received = bytes_received unless bytes_received.nil?
      __var0.flags = flags unless flags.nil?
      __var0.control_messages = control_messages unless control_messages.nil?
      __var0.num_control_messages = num_control_messages unless num_control_messages.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InputMessage*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InputMessage*)
    end

    def to_unsafe_inputmessage
      @pointer.not_nil!.as(LibGio::InputMessage*)
    end

    def address
      Gio::SocketAddress.new(to_unsafe.as(LibGio::InputMessage*).value.address)
    end

    def address=(value : Gio::SocketAddress)
      to_unsafe.as(LibGio::InputMessage*).value.address = value.to_unsafe_socketaddress
    end

    def vectors
      GObject::PointerIterator.new(to_unsafe.as(LibGio::InputMessage*).value.vectors) { |__var0|
        Gio::InputVector.new(__var0)
      }
    end

    def vectors=(value : ::Enumerable(Gio::InputVector))
      to_unsafe.as(LibGio::InputMessage*).value.vectors = (__value_ary = value.map { |__item| __item }.to_a).to_unsafe
    end

    def num_vectors
      to_unsafe.as(LibGio::InputMessage*).value.num_vectors
    end

    def num_vectors=(value : UInt32)
      to_unsafe.as(LibGio::InputMessage*).value.num_vectors = UInt32.new(value)
    end

    def bytes_received
      to_unsafe.as(LibGio::InputMessage*).value.bytes_received
    end

    def bytes_received=(value : UInt64)
      to_unsafe.as(LibGio::InputMessage*).value.bytes_received = UInt64.new(value)
    end

    def flags
      to_unsafe.as(LibGio::InputMessage*).value.flags
    end

    def flags=(value : Int32)
      to_unsafe.as(LibGio::InputMessage*).value.flags = Int32.new(value)
    end

    def control_messages
      GObject::PointerIterator.new(to_unsafe.as(LibGio::InputMessage*).value.control_messages) { |__var0|
        Gio::SocketControlMessage.new(__var0)
      }
    end

    def control_messages=(value : ::Enumerable(Gio::SocketControlMessage))
      to_unsafe.as(LibGio::InputMessage*).value.control_messages = (__value_ary = value.map { |__item| __item.to_unsafe_socketcontrolmessage }.to_a).to_unsafe
    end

    def num_control_messages
      to_unsafe.as(LibGio::InputMessage*).value.num_control_messages
    end

    def num_control_messages=(value : UInt32)
      to_unsafe.as(LibGio::InputMessage*).value.num_control_messages = value
    end
  end

  module PollableInputStream
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include PollableInputStream
      @pointer : Void*

      def initialize(pointer : LibGio::PollableInputStream*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GPollableInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_pollable_input_stream_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::PollableInputStream*)
      end

      def to_unsafe_pollableinputstream
        @pointer.not_nil!.as(LibGio::PollableInputStream*)
      end
    end

    def to_unsafe_pollableinputstream
      @pointer.not_nil!.as(LibGio::PollableInputStream*)
    end

    def can_poll
      __var0 = LibGio.pollable_input_stream_can_poll(@pointer.as(LibGio::PollableInputStream*))
      (__var0 == 1)
    end

    def create_source(cancellable : Gio::Cancellable?)
      __var0 = LibGio.pollable_input_stream_create_source(@pointer.as(LibGio::PollableInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      GObject.raise_unexpected_null("g_pollable_input_stream_create_source") if __var0.null?
      GLib::Source.new(__var0)
    end

    def readable?
      __var0 = LibGio.pollable_input_stream_is_readable(@pointer.as(LibGio::PollableInputStream*))
      (__var0 == 1)
    end

    def read_nonblocking(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      count = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.pollable_input_stream_read_nonblocking(@pointer.as(LibGio::PollableInputStream*), buffer.to_unsafe, UInt64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end
  end

  class InputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(248u64, 0u8).as(LibGio::InputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InputStreamClass*)
    end

    def to_unsafe_inputstreamclass
      @pointer.not_nil!.as(LibGio::InputStreamClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::InputStreamClass*).value.parent_class)
    end

    def read_fn
      to_unsafe.as(LibGio::InputStreamClass*).value.read_fn
    end

    def skip
      to_unsafe.as(LibGio::InputStreamClass*).value.skip
    end

    def close_fn
      to_unsafe.as(LibGio::InputStreamClass*).value.close_fn
    end

    def read_async
      to_unsafe.as(LibGio::InputStreamClass*).value.read_async
    end

    def read_finish
      to_unsafe.as(LibGio::InputStreamClass*).value.read_finish
    end

    def skip_async
      to_unsafe.as(LibGio::InputStreamClass*).value.skip_async
    end

    def skip_finish
      to_unsafe.as(LibGio::InputStreamClass*).value.skip_finish
    end

    def close_async
      to_unsafe.as(LibGio::InputStreamClass*).value.close_async
    end

    def close_finish
      to_unsafe.as(LibGio::InputStreamClass*).value.close_finish
    end

    def _g_reserved1
      to_unsafe.as(LibGio::InputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::InputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::InputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::InputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::InputStreamClass*).value._g_reserved5
    end
  end

  class InputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::InputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InputStreamPrivate*)
    end

    def to_unsafe_inputstreamprivate
      @pointer.not_nil!.as(LibGio::InputStreamPrivate*)
    end
  end

  class InputVector
    include GObject::WrappedType

    def self.new(buffer : Void*? = nil, size : UInt64? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::InputVector*))
      __var0.buffer = buffer unless buffer.nil?
      __var0.size = size unless size.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::InputVector*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InputVector*)
    end

    def to_unsafe_inputvector
      @pointer.not_nil!.as(LibGio::InputVector*)
    end

    def buffer
      to_unsafe.as(LibGio::InputVector*).value.buffer
    end

    def buffer=(value : Void*)
      to_unsafe.as(LibGio::InputVector*).value.buffer = value
    end

    def size
      to_unsafe.as(LibGio::InputVector*).value.size
    end

    def size=(value : UInt64)
      to_unsafe.as(LibGio::InputVector*).value.size = UInt64.new(value)
    end
  end

  module ListModel
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include ListModel
      @pointer : Void*

      def initialize(pointer : LibGio::ListModel*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GListModel")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_list_model_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::ListModel*)
      end

      def to_unsafe_listmodel
        @pointer.not_nil!.as(LibGio::ListModel*)
      end
    end

    def to_unsafe_listmodel
      @pointer.not_nil!.as(LibGio::ListModel*)
    end

    def item_type
      __var0 = LibGio.list_model_get_item_type(@pointer.as(LibGio::ListModel*))
      __var0
    end

    def n_items
      __var0 = LibGio.list_model_get_n_items(@pointer.as(LibGio::ListModel*))
      __var0
    end

    def item(position : ::Int)
      __var0 = LibGio.list_model_get_item(@pointer.as(LibGio::ListModel*), UInt32.new(position))
      __var1 = GObject::Object.new(__var0) if __var0
      __var1
    end

    def items_changed(position : ::Int, removed : ::Int, added : ::Int)
      LibGio.list_model_items_changed(@pointer.as(LibGio::ListModel*), UInt32.new(position), UInt32.new(removed), UInt32.new(added))
      nil
    end

    alias ItemsChangedSignal = ListModel, UInt32, UInt32, UInt32 -> Nil

    def on_items_changed(*, after = false, &block : ItemsChangedSignal)
      __var0 = ->(arg0 : LibGio::ListModel*, arg1 : UInt32, arg2 : UInt32, arg3 : UInt32, box : Void*) {
        ::Box(ItemsChangedSignal).unbox(box).call(ListModel::Wrapper.new(arg0), arg1, arg2, arg3)
      }

      __var1 = ::Box.box(ItemsChangedSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "items-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_items_changed(&block : ItemsChangedSignal)
      on_items_changed(after: true, &block)
    end
  end

  class ListModelInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::ListModelInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ListModelInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ListModelInterface*)
    end

    def to_unsafe_listmodelinterface
      @pointer.not_nil!.as(LibGio::ListModelInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ListModelInterface*).value.g_iface)
    end

    def get_item_type
      to_unsafe.as(LibGio::ListModelInterface*).value.get_item_type
    end

    def get_n_items
      to_unsafe.as(LibGio::ListModelInterface*).value.get_n_items
    end

    def get_item
      to_unsafe.as(LibGio::ListModelInterface*).value.get_item
    end
  end

  class ListStore < GObject::Object
    include Gio::ListModel

    @pointer : Void*

    def initialize(pointer : LibGio::ListStore*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GListStore")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_list_store_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ListStore*)
    end

    def to_unsafe_liststore
      @pointer.not_nil!.as(LibGio::ListStore*)
    end

    def initialize(*, item_type : UInt64? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless item_type.nil?
        __var0 << "item-type".to_unsafe
        __var1 << item_type.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_list_store_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(item_type : UInt64) : self
      __var0 = LibGio.list_store_new(UInt64.new(item_type))
      GObject.raise_unexpected_null("g_list_store_new") if __var0.null?
      cast(Gio::ListStore.new(__var0))
    end

    def append(item : GObject::Object)
      LibGio.list_store_append(@pointer.as(LibGio::ListStore*), item.to_unsafe_object)
      nil
    end

    def find(item : GObject::Object)
      __var0 = LibGio.list_store_find(@pointer.as(LibGio::ListStore*), item.to_unsafe_object, out position)
      {(__var0 == 1), position}
    end

    def find_with_equal_func(item : GObject::Object, equal_func : GLib::EqualFunc)
      __var0 = LibGio.list_store_find_with_equal_func(@pointer.as(LibGio::ListStore*), item.to_unsafe_object, equal_func, out position)
      {(__var0 == 1), position}
    end

    def insert(position : ::Int, item : GObject::Object)
      LibGio.list_store_insert(@pointer.as(LibGio::ListStore*), UInt32.new(position), item.to_unsafe_object)
      nil
    end

    def insert_sorted(item : GObject::Object, compare_func : GLib::CompareDataFunc, user_data : Void*?)
      __var0 = LibGio.list_store_insert_sorted(@pointer.as(LibGio::ListStore*), item.to_unsafe_object, compare_func, user_data ? user_data : Pointer(Void).null)
      __var0
    end

    def remove(position : ::Int)
      LibGio.list_store_remove(@pointer.as(LibGio::ListStore*), UInt32.new(position))
      nil
    end

    def remove_all
      LibGio.list_store_remove_all(@pointer.as(LibGio::ListStore*))
      nil
    end

    def sort(compare_func : GLib::CompareDataFunc, user_data : Void*?)
      LibGio.list_store_sort(@pointer.as(LibGio::ListStore*), compare_func, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def splice(position : ::Int, n_removals : ::Int, additions : ::Enumerable)
      n_additions = additions.size
      __additions = (__additions_ary = additions.map { |__item| __item }.to_a).to_unsafe
      n_additions = __additions_ary.size
      LibGio.list_store_splice(@pointer.as(LibGio::ListStore*), UInt32.new(position), UInt32.new(n_removals), __additions, UInt32.new(n_additions))
      nil
    end

    def item_type : UInt64
      __var0 = GObject::Value.new(type: GObject::Type::GTYPE)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "item-type", __var0)
      __var0
    end
  end

  class ListStoreClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::ListStoreClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ListStoreClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ListStoreClass*)
    end

    def to_unsafe_liststoreclass
      @pointer.not_nil!.as(LibGio::ListStoreClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ListStoreClass*).value.parent_class)
    end
  end

  class FileIcon < GObject::Object
    include Gio::Icon
    include Gio::LoadableIcon

    @pointer : Void*

    def initialize(pointer : LibGio::FileIcon*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GFileIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_file_icon_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::FileIcon*)
    end

    def to_unsafe_fileicon
      @pointer.not_nil!.as(LibGio::FileIcon*)
    end

    def initialize(*, file : Gio::File? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless file.nil?
        __var0 << "file".to_unsafe
        __var1 << file.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_file_icon_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(file : Gio::File) : self
      __var0 = LibGio.file_icon_new(file.to_unsafe_file)
      GObject.raise_unexpected_null("g_file_icon_new") if __var0.null?
      cast(Gio::FileIcon.new(__var0))
    end

    def file
      __var0 = LibGio.file_icon_get_file(@pointer.as(LibGio::FileIcon*))
      GObject.raise_unexpected_null("g_file_icon_get_file") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end
  end

  class LoadableIconIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::LoadableIconIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::LoadableIconIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::LoadableIconIface*)
    end

    def to_unsafe_loadableiconiface
      @pointer.not_nil!.as(LibGio::LoadableIconIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::LoadableIconIface*).value.g_iface)
    end

    def load
      to_unsafe.as(LibGio::LoadableIconIface*).value.load
    end

    def load_async
      to_unsafe.as(LibGio::LoadableIconIface*).value.load_async
    end

    def load_finish
      to_unsafe.as(LibGio::LoadableIconIface*).value.load_finish
    end
  end

  class MemoryInputStream < InputStream
    include Gio::PollableInputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMemoryInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_memory_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryInputStream*)
    end

    def to_unsafe_memoryinputstream
      @pointer.not_nil!.as(LibGio::MemoryInputStream*)
    end

    def self.new : self
      __var0 = LibGio.memory_input_stream_new
      GObject.raise_unexpected_null("g_memory_input_stream_new") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def self.new_from_bytes(bytes : GLib::Bytes) : self
      __var0 = LibGio.memory_input_stream_new_from_bytes(bytes.to_unsafe.as(LibGLib::Bytes*))
      GObject.raise_unexpected_null("g_memory_input_stream_new_from_bytes") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def self.new_from_data(data : ::Bytes, destroy : GLib::DestroyNotify?) : self
      len = data.size
      __var0 = LibGio.memory_input_stream_new_from_data(data.to_unsafe, Int64.new(len), destroy ? destroy : nil)
      GObject.raise_unexpected_null("g_memory_input_stream_new_from_data") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def add_bytes(bytes : GLib::Bytes)
      LibGio.memory_input_stream_add_bytes(@pointer.as(LibGio::MemoryInputStream*), bytes.to_unsafe.as(LibGLib::Bytes*))
      nil
    end

    def add_data(data : ::Bytes, destroy : GLib::DestroyNotify?)
      len = data.size
      LibGio.memory_input_stream_add_data(@pointer.as(LibGio::MemoryInputStream*), data.to_unsafe, Int64.new(len), destroy ? destroy : nil)
      nil
    end
  end

  class MemoryInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(288u64, 0u8).as(LibGio::MemoryInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryInputStreamClass*)
    end

    def to_unsafe_memoryinputstreamclass
      @pointer.not_nil!.as(LibGio::MemoryInputStreamClass*)
    end

    def parent_class
      Gio::InputStreamClass.new(to_unsafe.as(LibGio::MemoryInputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::MemoryInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::MemoryInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::MemoryInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::MemoryInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::MemoryInputStreamClass*).value._g_reserved5
    end
  end

  class MemoryInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryInputStreamPrivate*)
    end

    def to_unsafe_memoryinputstreamprivate
      @pointer.not_nil!.as(LibGio::MemoryInputStreamPrivate*)
    end
  end

  module MemoryMonitor
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include MemoryMonitor
      @pointer : Void*

      def initialize(pointer : LibGio::MemoryMonitor*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GMemoryMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_memory_monitor_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::MemoryMonitor*)
      end

      def to_unsafe_memorymonitor
        @pointer.not_nil!.as(LibGio::MemoryMonitor*)
      end
    end

    def to_unsafe_memorymonitor
      @pointer.not_nil!.as(LibGio::MemoryMonitor*)
    end

    def self.dup_default
      __var0 = LibGio.memory_monitor_dup_default
      GObject.raise_unexpected_null("g_memory_monitor_dup_default") if __var0.null?
      Gio::MemoryMonitor::Wrapper.new(__var0)
    end

    alias LowMemoryWarningSignal = MemoryMonitor, Gio::MemoryMonitorWarningLevel -> Nil

    def on_low_memory_warning(*, after = false, &block : LowMemoryWarningSignal)
      __var0 = ->(arg0 : LibGio::MemoryMonitor*, arg1 : LibGio::MemoryMonitorWarningLevel, box : Void*) {
        ::Box(LowMemoryWarningSignal).unbox(box).call(MemoryMonitor::Wrapper.new(arg0), Gio::MemoryMonitorWarningLevel.new(arg1))
      }

      __var1 = ::Box.box(LowMemoryWarningSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "low-memory-warning", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_low_memory_warning(&block : LowMemoryWarningSignal)
      on_low_memory_warning(after: true, &block)
    end
  end

  class MemoryMonitorInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(24u64, 0u8).as(LibGio::MemoryMonitorInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryMonitorInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryMonitorInterface*)
    end

    def to_unsafe_memorymonitorinterface
      @pointer.not_nil!.as(LibGio::MemoryMonitorInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::MemoryMonitorInterface*).value.g_iface)
    end

    def low_memory_warning
      to_unsafe.as(LibGio::MemoryMonitorInterface*).value.low_memory_warning
    end
  end

  enum MemoryMonitorWarningLevel : UInt32
    ZERO_NONE =   0
    LOW       =  50
    MEDIUM    = 100
    CRITICAL  = 255
  end

  module PollableOutputStream
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include PollableOutputStream
      @pointer : Void*

      def initialize(pointer : LibGio::PollableOutputStream*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GPollableOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_pollable_output_stream_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::PollableOutputStream*)
      end

      def to_unsafe_pollableoutputstream
        @pointer.not_nil!.as(LibGio::PollableOutputStream*)
      end
    end

    def to_unsafe_pollableoutputstream
      @pointer.not_nil!.as(LibGio::PollableOutputStream*)
    end

    def can_poll
      __var0 = LibGio.pollable_output_stream_can_poll(@pointer.as(LibGio::PollableOutputStream*))
      (__var0 == 1)
    end

    def create_source(cancellable : Gio::Cancellable?)
      __var0 = LibGio.pollable_output_stream_create_source(@pointer.as(LibGio::PollableOutputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      GObject.raise_unexpected_null("g_pollable_output_stream_create_source") if __var0.null?
      GLib::Source.new(__var0)
    end

    def writable?
      __var0 = LibGio.pollable_output_stream_is_writable(@pointer.as(LibGio::PollableOutputStream*))
      (__var0 == 1)
    end

    def write_nonblocking(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      count = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.pollable_output_stream_write_nonblocking(@pointer.as(LibGio::PollableOutputStream*), buffer.to_unsafe, UInt64.new(count), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def writev_nonblocking(vectors : ::Enumerable, cancellable : Gio::Cancellable?)
      n_vectors = vectors.size
      __vectors = (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe
      n_vectors = __vectors_ary.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.pollable_output_stream_writev_nonblocking(@pointer.as(LibGio::PollableOutputStream*), __vectors, UInt64.new(n_vectors), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {Gio::PollableReturn.new(__var1), bytes_written}
    end
  end

  class MemoryOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::MemoryOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryOutputStreamClass*)
    end

    def to_unsafe_memoryoutputstreamclass
      @pointer.not_nil!.as(LibGio::MemoryOutputStreamClass*)
    end

    def parent_class
      Gio::OutputStreamClass.new(to_unsafe.as(LibGio::MemoryOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::MemoryOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::MemoryOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::MemoryOutputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::MemoryOutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::MemoryOutputStreamClass*).value._g_reserved5
    end
  end

  class MemoryOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryOutputStreamPrivate*)
    end

    def to_unsafe_memoryoutputstreamprivate
      @pointer.not_nil!.as(LibGio::MemoryOutputStreamPrivate*)
    end
  end

  class Menu < MenuModel
    @pointer : Void*

    def initialize(pointer : LibGio::Menu*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMenu")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_menu_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Menu*)
    end

    def to_unsafe_menu
      @pointer.not_nil!.as(LibGio::Menu*)
    end

    def self.new : self
      __var0 = LibGio.menu_new
      GObject.raise_unexpected_null("g_menu_new") if __var0.null?
      cast(Gio::Menu.new(__var0))
    end

    def append(label : ::String?, detailed_action : ::String?)
      LibGio.menu_append(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, detailed_action ? detailed_action.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def append_item(item : Gio::MenuItem)
      LibGio.menu_append_item(@pointer.as(LibGio::Menu*), item.to_unsafe_menuitem)
      nil
    end

    def append_section(label : ::String?, section : Gio::MenuModel)
      LibGio.menu_append_section(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, section.to_unsafe_menumodel)
      nil
    end

    def append_submenu(label : ::String?, submenu : Gio::MenuModel)
      LibGio.menu_append_submenu(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, submenu.to_unsafe_menumodel)
      nil
    end

    def freeze
      LibGio.menu_freeze(@pointer.as(LibGio::Menu*))
      nil
    end

    def insert(position : ::Int, label : ::String?, detailed_action : ::String?)
      LibGio.menu_insert(@pointer.as(LibGio::Menu*), Int32.new(position), label ? label.to_unsafe : Pointer(UInt8).null, detailed_action ? detailed_action.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def insert_item(position : ::Int, item : Gio::MenuItem)
      LibGio.menu_insert_item(@pointer.as(LibGio::Menu*), Int32.new(position), item.to_unsafe_menuitem)
      nil
    end

    def insert_section(position : ::Int, label : ::String?, section : Gio::MenuModel)
      LibGio.menu_insert_section(@pointer.as(LibGio::Menu*), Int32.new(position), label ? label.to_unsafe : Pointer(UInt8).null, section.to_unsafe_menumodel)
      nil
    end

    def insert_submenu(position : ::Int, label : ::String?, submenu : Gio::MenuModel)
      LibGio.menu_insert_submenu(@pointer.as(LibGio::Menu*), Int32.new(position), label ? label.to_unsafe : Pointer(UInt8).null, submenu.to_unsafe_menumodel)
      nil
    end

    def prepend(label : ::String?, detailed_action : ::String?)
      LibGio.menu_prepend(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, detailed_action ? detailed_action.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def prepend_item(item : Gio::MenuItem)
      LibGio.menu_prepend_item(@pointer.as(LibGio::Menu*), item.to_unsafe_menuitem)
      nil
    end

    def prepend_section(label : ::String?, section : Gio::MenuModel)
      LibGio.menu_prepend_section(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, section.to_unsafe_menumodel)
      nil
    end

    def prepend_submenu(label : ::String?, submenu : Gio::MenuModel)
      LibGio.menu_prepend_submenu(@pointer.as(LibGio::Menu*), label ? label.to_unsafe : Pointer(UInt8).null, submenu.to_unsafe_menumodel)
      nil
    end

    def remove(position : ::Int)
      LibGio.menu_remove(@pointer.as(LibGio::Menu*), Int32.new(position))
      nil
    end

    def remove_all
      LibGio.menu_remove_all(@pointer.as(LibGio::Menu*))
      nil
    end
  end

  class MenuAttributeIter < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::MenuAttributeIter*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMenuAttributeIter")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_menu_attribute_iter_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuAttributeIter*)
    end

    def to_unsafe_menuattributeiter
      @pointer.not_nil!.as(LibGio::MenuAttributeIter*)
    end

    def name
      __var0 = LibGio.menu_attribute_iter_get_name(@pointer.as(LibGio::MenuAttributeIter*))
      GObject.raise_unexpected_null("g_menu_attribute_iter_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def next(value : GLib::Variant?)
      __var0 = LibGio.menu_attribute_iter_get_next(@pointer.as(LibGio::MenuAttributeIter*), out out_name, value)
      {(__var0 == 1), ::String.new(out_name)}
    end

    def value
      __var0 = LibGio.menu_attribute_iter_get_value(@pointer.as(LibGio::MenuAttributeIter*))
      GObject.raise_unexpected_null("g_menu_attribute_iter_get_value") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def next
      __var0 = LibGio.menu_attribute_iter_next(@pointer.as(LibGio::MenuAttributeIter*))
      (__var0 == 1)
    end
  end

  class MenuAttributeIterClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(144u64, 0u8).as(LibGio::MenuAttributeIterClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MenuAttributeIterClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuAttributeIterClass*)
    end

    def to_unsafe_menuattributeiterclass
      @pointer.not_nil!.as(LibGio::MenuAttributeIterClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::MenuAttributeIterClass*).value.parent_class)
    end

    def get_next
      to_unsafe.as(LibGio::MenuAttributeIterClass*).value.get_next
    end
  end

  class MenuAttributeIterPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MenuAttributeIterPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuAttributeIterPrivate*)
    end

    def to_unsafe_menuattributeiterprivate
      @pointer.not_nil!.as(LibGio::MenuAttributeIterPrivate*)
    end
  end

  class MenuItem < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::MenuItem*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMenuItem")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_menu_item_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuItem*)
    end

    def to_unsafe_menuitem
      @pointer.not_nil!.as(LibGio::MenuItem*)
    end

    def self.new(label : ::String?, detailed_action : ::String?) : self
      __var0 = LibGio.menu_item_new(label ? label.to_unsafe : Pointer(UInt8).null, detailed_action ? detailed_action.to_unsafe : Pointer(UInt8).null)
      GObject.raise_unexpected_null("g_menu_item_new") if __var0.null?
      cast(Gio::MenuItem.new(__var0))
    end

    def self.new_from_model(model : Gio::MenuModel, item_index : ::Int) : self
      __var0 = LibGio.menu_item_new_from_model(model.to_unsafe_menumodel, Int32.new(item_index))
      GObject.raise_unexpected_null("g_menu_item_new_from_model") if __var0.null?
      cast(Gio::MenuItem.new(__var0))
    end

    def self.new_section(label : ::String?, section : Gio::MenuModel) : self
      __var0 = LibGio.menu_item_new_section(label ? label.to_unsafe : Pointer(UInt8).null, section.to_unsafe_menumodel)
      GObject.raise_unexpected_null("g_menu_item_new_section") if __var0.null?
      cast(Gio::MenuItem.new(__var0))
    end

    def self.new_submenu(label : ::String?, submenu : Gio::MenuModel) : self
      __var0 = LibGio.menu_item_new_submenu(label ? label.to_unsafe : Pointer(UInt8).null, submenu.to_unsafe_menumodel)
      GObject.raise_unexpected_null("g_menu_item_new_submenu") if __var0.null?
      cast(Gio::MenuItem.new(__var0))
    end

    def attribute_value(attribute : ::String, expected_type : GLib::VariantType?)
      __var0 = LibGio.menu_item_get_attribute_value(@pointer.as(LibGio::MenuItem*), attribute.to_unsafe, expected_type ? expected_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null)
      GObject.raise_unexpected_null("g_menu_item_get_attribute_value") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def link(link : ::String)
      __var0 = LibGio.menu_item_get_link(@pointer.as(LibGio::MenuItem*), link.to_unsafe)
      GObject.raise_unexpected_null("g_menu_item_get_link") if __var0.null?
      Gio::MenuModel.new(__var0)
    end

    def set_action_and_target_value(action : ::String?, target_value : GLib::Variant?)
      LibGio.menu_item_set_action_and_target_value(@pointer.as(LibGio::MenuItem*), action ? action.to_unsafe : Pointer(UInt8).null, target_value ? target_value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def set_attribute_value(attribute : ::String, value : GLib::Variant?)
      LibGio.menu_item_set_attribute_value(@pointer.as(LibGio::MenuItem*), attribute.to_unsafe, value ? value.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def detailed_action=(detailed_action : ::String)
      LibGio.menu_item_set_detailed_action(@pointer.as(LibGio::MenuItem*), detailed_action.to_unsafe)
      nil
    end

    def icon=(icon : Gio::Icon)
      LibGio.menu_item_set_icon(@pointer.as(LibGio::MenuItem*), icon.to_unsafe_icon)
      nil
    end

    def label=(label : ::String?)
      LibGio.menu_item_set_label(@pointer.as(LibGio::MenuItem*), label ? label.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def set_link(link : ::String, model : Gio::MenuModel?)
      LibGio.menu_item_set_link(@pointer.as(LibGio::MenuItem*), link.to_unsafe, model ? model.to_unsafe_menumodel : Pointer(LibGio::MenuModel).null)
      nil
    end

    def section=(section : Gio::MenuModel?)
      LibGio.menu_item_set_section(@pointer.as(LibGio::MenuItem*), section ? section.to_unsafe_menumodel : Pointer(LibGio::MenuModel).null)
      nil
    end

    def submenu=(submenu : Gio::MenuModel?)
      LibGio.menu_item_set_submenu(@pointer.as(LibGio::MenuItem*), submenu ? submenu.to_unsafe_menumodel : Pointer(LibGio::MenuModel).null)
      nil
    end
  end

  class MenuLinkIter < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::MenuLinkIter*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMenuLinkIter")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_menu_link_iter_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuLinkIter*)
    end

    def to_unsafe_menulinkiter
      @pointer.not_nil!.as(LibGio::MenuLinkIter*)
    end

    def name
      __var0 = LibGio.menu_link_iter_get_name(@pointer.as(LibGio::MenuLinkIter*))
      GObject.raise_unexpected_null("g_menu_link_iter_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def next(value : Gio::MenuModel?)
      __var0 = LibGio.menu_link_iter_get_next(@pointer.as(LibGio::MenuLinkIter*), out out_link, value)
      {(__var0 == 1), ::String.new(out_link)}
    end

    def value
      __var0 = LibGio.menu_link_iter_get_value(@pointer.as(LibGio::MenuLinkIter*))
      GObject.raise_unexpected_null("g_menu_link_iter_get_value") if __var0.null?
      Gio::MenuModel.new(__var0)
    end

    def next
      __var0 = LibGio.menu_link_iter_next(@pointer.as(LibGio::MenuLinkIter*))
      (__var0 == 1)
    end
  end

  class MenuLinkIterClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(144u64, 0u8).as(LibGio::MenuLinkIterClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MenuLinkIterClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuLinkIterClass*)
    end

    def to_unsafe_menulinkiterclass
      @pointer.not_nil!.as(LibGio::MenuLinkIterClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::MenuLinkIterClass*).value.parent_class)
    end

    def get_next
      to_unsafe.as(LibGio::MenuLinkIterClass*).value.get_next
    end
  end

  class MenuLinkIterPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MenuLinkIterPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuLinkIterPrivate*)
    end

    def to_unsafe_menulinkiterprivate
      @pointer.not_nil!.as(LibGio::MenuLinkIterPrivate*)
    end
  end

  class DBusMenuModel < MenuModel
    @pointer : Void*

    def initialize(pointer : LibGio::DBusMenuModel*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusMenuModel")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_menu_model_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusMenuModel*)
    end

    def to_unsafe_dbusmenumodel
      @pointer.not_nil!.as(LibGio::DBusMenuModel*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_menu_model_get_type, 0, nil, nil).as(Void*)
    end

    def self.get(connection : Gio::DBusConnection, bus_name : ::String?, object_path : ::String)
      __var0 = LibGio.d_bus_menu_model_get(connection.to_unsafe_dbusconnection, bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_menu_model_get") if __var0.null?
      Gio::DBusMenuModel.new(__var0)
    end
  end

  class MenuModelClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(200u64, 0u8).as(LibGio::MenuModelClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MenuModelClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuModelClass*)
    end

    def to_unsafe_menumodelclass
      @pointer.not_nil!.as(LibGio::MenuModelClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::MenuModelClass*).value.parent_class)
    end

    def is_mutable
      to_unsafe.as(LibGio::MenuModelClass*).value.is_mutable
    end

    def get_n_items
      to_unsafe.as(LibGio::MenuModelClass*).value.get_n_items
    end

    def get_item_attributes
      to_unsafe.as(LibGio::MenuModelClass*).value.get_item_attributes
    end

    def iterate_item_attributes
      to_unsafe.as(LibGio::MenuModelClass*).value.iterate_item_attributes
    end

    def get_item_attribute_value
      to_unsafe.as(LibGio::MenuModelClass*).value.get_item_attribute_value
    end

    def get_item_links
      to_unsafe.as(LibGio::MenuModelClass*).value.get_item_links
    end

    def iterate_item_links
      to_unsafe.as(LibGio::MenuModelClass*).value.iterate_item_links
    end

    def get_item_link
      to_unsafe.as(LibGio::MenuModelClass*).value.get_item_link
    end
  end

  class MenuModelPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MenuModelPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MenuModelPrivate*)
    end

    def to_unsafe_menumodelprivate
      @pointer.not_nil!.as(LibGio::MenuModelPrivate*)
    end
  end

  module Mount
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Mount
      @pointer : Void*

      def initialize(pointer : LibGio::Mount*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GMount")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_mount_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Mount*)
      end

      def to_unsafe_mount
        @pointer.not_nil!.as(LibGio::Mount*)
      end
    end

    def to_unsafe_mount
      @pointer.not_nil!.as(LibGio::Mount*)
    end

    def can_eject
      __var0 = LibGio.mount_can_eject(@pointer.as(LibGio::Mount*))
      (__var0 == 1)
    end

    def can_unmount
      __var0 = LibGio.mount_can_unmount(@pointer.as(LibGio::Mount*))
      (__var0 == 1)
    end

    def eject(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_eject(@pointer.as(LibGio::Mount*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_eject_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def eject_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_eject_with_operation(@pointer.as(LibGio::Mount*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_eject_with_operation_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def default_location
      __var0 = LibGio.mount_get_default_location(@pointer.as(LibGio::Mount*))
      GObject.raise_unexpected_null("g_mount_get_default_location") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def drive
      __var0 = LibGio.mount_get_drive(@pointer.as(LibGio::Mount*))
      __var1 = Gio::Drive::Wrapper.new(__var0) if __var0
      __var1
    end

    def icon
      __var0 = LibGio.mount_get_icon(@pointer.as(LibGio::Mount*))
      GObject.raise_unexpected_null("g_mount_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def name
      __var0 = LibGio.mount_get_name(@pointer.as(LibGio::Mount*))
      GObject.raise_unexpected_null("g_mount_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def root
      __var0 = LibGio.mount_get_root(@pointer.as(LibGio::Mount*))
      GObject.raise_unexpected_null("g_mount_get_root") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def sort_key
      __var0 = LibGio.mount_get_sort_key(@pointer.as(LibGio::Mount*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def symbolic_icon
      __var0 = LibGio.mount_get_symbolic_icon(@pointer.as(LibGio::Mount*))
      GObject.raise_unexpected_null("g_mount_get_symbolic_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def uuid
      __var0 = LibGio.mount_get_uuid(@pointer.as(LibGio::Mount*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def volume
      __var0 = LibGio.mount_get_volume(@pointer.as(LibGio::Mount*))
      __var1 = Gio::Volume::Wrapper.new(__var0) if __var0
      __var1
    end

    def guess_content_type(force_rescan : ::Bool, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_guess_content_type(@pointer.as(LibGio::Mount*), LibC::Int.new(force_rescan ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def guess_content_type_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_guess_content_type_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_mount_guess_content_type_finish") if __var1.null?
      GObject::PointerIterator.new(__var1) { |__var2|
        ::String.new(__var2)
      }
    end

    def guess_content_type_sync(force_rescan : ::Bool, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_guess_content_type_sync(@pointer.as(LibGio::Mount*), LibC::Int.new(force_rescan ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_mount_guess_content_type_sync") if __var1.null?
      GObject::PointerIterator.new(__var1) { |__var2|
        ::String.new(__var2)
      }
    end

    def shadowed?
      __var0 = LibGio.mount_is_shadowed(@pointer.as(LibGio::Mount*))
      (__var0 == 1)
    end

    def remount(flags : Gio::MountMountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_remount(@pointer.as(LibGio::Mount*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def remount_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_remount_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def shadow
      LibGio.mount_shadow(@pointer.as(LibGio::Mount*))
      nil
    end

    def unmount(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_unmount(@pointer.as(LibGio::Mount*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def unmount_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_unmount_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def unmount_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.mount_unmount_with_operation(@pointer.as(LibGio::Mount*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def unmount_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.mount_unmount_with_operation_finish(@pointer.as(LibGio::Mount*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def unshadow
      LibGio.mount_unshadow(@pointer.as(LibGio::Mount*))
      nil
    end

    alias ChangedSignal = Mount -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::Mount*, box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(Mount::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end

    alias PreUnmountSignal = Mount -> Nil

    def on_pre_unmount(*, after = false, &block : PreUnmountSignal)
      __var0 = ->(arg0 : LibGio::Mount*, box : Void*) {
        ::Box(PreUnmountSignal).unbox(box).call(Mount::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(PreUnmountSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "pre-unmount", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_pre_unmount(&block : PreUnmountSignal)
      on_pre_unmount(after: true, &block)
    end

    alias UnmountedSignal = Mount -> Nil

    def on_unmounted(*, after = false, &block : UnmountedSignal)
      __var0 = ->(arg0 : LibGio::Mount*, box : Void*) {
        ::Box(UnmountedSignal).unbox(box).call(Mount::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(UnmountedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "unmounted", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_unmounted(&block : UnmountedSignal)
      on_unmounted(after: true, &block)
    end
  end

  class MountIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(232u64, 0u8).as(LibGio::MountIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MountIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MountIface*)
    end

    def to_unsafe_mountiface
      @pointer.not_nil!.as(LibGio::MountIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::MountIface*).value.g_iface)
    end

    def changed
      to_unsafe.as(LibGio::MountIface*).value.changed
    end

    def unmounted
      to_unsafe.as(LibGio::MountIface*).value.unmounted
    end

    def get_root
      to_unsafe.as(LibGio::MountIface*).value.get_root
    end

    def get_name
      to_unsafe.as(LibGio::MountIface*).value.get_name
    end

    def get_icon
      to_unsafe.as(LibGio::MountIface*).value.get_icon
    end

    def get_uuid
      to_unsafe.as(LibGio::MountIface*).value.get_uuid
    end

    def get_volume
      to_unsafe.as(LibGio::MountIface*).value.get_volume
    end

    def get_drive
      to_unsafe.as(LibGio::MountIface*).value.get_drive
    end

    def can_unmount
      to_unsafe.as(LibGio::MountIface*).value.can_unmount
    end

    def can_eject
      to_unsafe.as(LibGio::MountIface*).value.can_eject
    end

    def unmount
      to_unsafe.as(LibGio::MountIface*).value.unmount
    end

    def unmount_finish
      to_unsafe.as(LibGio::MountIface*).value.unmount_finish
    end

    def eject
      to_unsafe.as(LibGio::MountIface*).value.eject
    end

    def eject_finish
      to_unsafe.as(LibGio::MountIface*).value.eject_finish
    end

    def remount
      to_unsafe.as(LibGio::MountIface*).value.remount
    end

    def remount_finish
      to_unsafe.as(LibGio::MountIface*).value.remount_finish
    end

    def guess_content_type
      to_unsafe.as(LibGio::MountIface*).value.guess_content_type
    end

    def guess_content_type_finish
      to_unsafe.as(LibGio::MountIface*).value.guess_content_type_finish
    end

    def guess_content_type_sync
      to_unsafe.as(LibGio::MountIface*).value.guess_content_type_sync
    end

    def pre_unmount
      to_unsafe.as(LibGio::MountIface*).value.pre_unmount
    end

    def unmount_with_operation
      to_unsafe.as(LibGio::MountIface*).value.unmount_with_operation
    end

    def unmount_with_operation_finish
      to_unsafe.as(LibGio::MountIface*).value.unmount_with_operation_finish
    end

    def eject_with_operation
      to_unsafe.as(LibGio::MountIface*).value.eject_with_operation
    end

    def eject_with_operation_finish
      to_unsafe.as(LibGio::MountIface*).value.eject_with_operation_finish
    end

    def get_default_location
      to_unsafe.as(LibGio::MountIface*).value.get_default_location
    end

    def get_sort_key
      to_unsafe.as(LibGio::MountIface*).value.get_sort_key
    end

    def get_symbolic_icon
      to_unsafe.as(LibGio::MountIface*).value.get_symbolic_icon
    end
  end

  @[Flags]
  enum MountMountFlags : UInt32
    NONE = 0
  end

  class MountOperation < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::MountOperation*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMountOperation")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_mount_operation_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MountOperation*)
    end

    def to_unsafe_mountoperation
      @pointer.not_nil!.as(LibGio::MountOperation*)
    end

    def initialize(*, anonymous : ::Bool? = nil, choice : Int32? = nil, domain : ::String? = nil, is_tcrypt_hidden_volume : ::Bool? = nil, is_tcrypt_system_volume : ::Bool? = nil, password : ::String? = nil, password_save : Gio::PasswordSave? = nil, pim : UInt32? = nil, username : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless anonymous.nil?
        __var0 << "anonymous".to_unsafe
        __var1 << anonymous.to_gvalue.to_unsafe.value
      end

      unless choice.nil?
        __var0 << "choice".to_unsafe
        __var1 << choice.to_gvalue.to_unsafe.value
      end

      unless domain.nil?
        __var0 << "domain".to_unsafe
        __var1 << domain.to_gvalue.to_unsafe.value
      end

      unless is_tcrypt_hidden_volume.nil?
        __var0 << "is-tcrypt-hidden-volume".to_unsafe
        __var1 << is_tcrypt_hidden_volume.to_gvalue.to_unsafe.value
      end

      unless is_tcrypt_system_volume.nil?
        __var0 << "is-tcrypt-system-volume".to_unsafe
        __var1 << is_tcrypt_system_volume.to_gvalue.to_unsafe.value
      end

      unless password.nil?
        __var0 << "password".to_unsafe
        __var1 << password.to_gvalue.to_unsafe.value
      end

      unless password_save.nil?
        __var0 << "password-save".to_unsafe
        __var1 << password_save.to_gvalue.to_unsafe.value
      end

      unless pim.nil?
        __var0 << "pim".to_unsafe
        __var1 << pim.to_gvalue.to_unsafe.value
      end

      unless username.nil?
        __var0 << "username".to_unsafe
        __var1 << username.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_mount_operation_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.mount_operation_new
      GObject.raise_unexpected_null("g_mount_operation_new") if __var0.null?
      cast(Gio::MountOperation.new(__var0))
    end

    def anonymous
      __var0 = LibGio.mount_operation_get_anonymous(@pointer.as(LibGio::MountOperation*))
      (__var0 == 1)
    end

    def choice
      __var0 = LibGio.mount_operation_get_choice(@pointer.as(LibGio::MountOperation*))
      __var0
    end

    def domain
      __var0 = LibGio.mount_operation_get_domain(@pointer.as(LibGio::MountOperation*))
      GObject.raise_unexpected_null("g_mount_operation_get_domain") if __var0.null?
      ::String.new(__var0)
    end

    def is_tcrypt_hidden_volume
      __var0 = LibGio.mount_operation_get_is_tcrypt_hidden_volume(@pointer.as(LibGio::MountOperation*))
      (__var0 == 1)
    end

    def is_tcrypt_system_volume
      __var0 = LibGio.mount_operation_get_is_tcrypt_system_volume(@pointer.as(LibGio::MountOperation*))
      (__var0 == 1)
    end

    def password
      __var0 = LibGio.mount_operation_get_password(@pointer.as(LibGio::MountOperation*))
      GObject.raise_unexpected_null("g_mount_operation_get_password") if __var0.null?
      ::String.new(__var0)
    end

    def password_save
      __var0 = LibGio.mount_operation_get_password_save(@pointer.as(LibGio::MountOperation*))
      Gio::PasswordSave.new(__var0)
    end

    def pim
      __var0 = LibGio.mount_operation_get_pim(@pointer.as(LibGio::MountOperation*))
      __var0
    end

    def username
      __var0 = LibGio.mount_operation_get_username(@pointer.as(LibGio::MountOperation*))
      GObject.raise_unexpected_null("g_mount_operation_get_username") if __var0.null?
      ::String.new(__var0)
    end

    def reply(result : Gio::MountOperationResult)
      LibGio.mount_operation_reply(@pointer.as(LibGio::MountOperation*), result)
      nil
    end

    def anonymous=(anonymous : ::Bool)
      LibGio.mount_operation_set_anonymous(@pointer.as(LibGio::MountOperation*), LibC::Int.new(anonymous ? 1 : 0))
      nil
    end

    def choice=(choice : ::Int)
      LibGio.mount_operation_set_choice(@pointer.as(LibGio::MountOperation*), Int32.new(choice))
      nil
    end

    def domain=(domain : ::String)
      LibGio.mount_operation_set_domain(@pointer.as(LibGio::MountOperation*), domain.to_unsafe)
      nil
    end

    def is_tcrypt_hidden_volume=(hidden_volume : ::Bool)
      LibGio.mount_operation_set_is_tcrypt_hidden_volume(@pointer.as(LibGio::MountOperation*), LibC::Int.new(hidden_volume ? 1 : 0))
      nil
    end

    def is_tcrypt_system_volume=(system_volume : ::Bool)
      LibGio.mount_operation_set_is_tcrypt_system_volume(@pointer.as(LibGio::MountOperation*), LibC::Int.new(system_volume ? 1 : 0))
      nil
    end

    def password=(password : ::String)
      LibGio.mount_operation_set_password(@pointer.as(LibGio::MountOperation*), password.to_unsafe)
      nil
    end

    def password_save=(save : Gio::PasswordSave)
      LibGio.mount_operation_set_password_save(@pointer.as(LibGio::MountOperation*), save)
      nil
    end

    def pim=(pim : ::Int)
      LibGio.mount_operation_set_pim(@pointer.as(LibGio::MountOperation*), UInt32.new(pim))
      nil
    end

    def username=(username : ::String)
      LibGio.mount_operation_set_username(@pointer.as(LibGio::MountOperation*), username.to_unsafe)
      nil
    end

    alias AbortedSignal = MountOperation -> Nil

    def on_aborted(*, after = false, &block : AbortedSignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, box : Void*) {
        ::Box(AbortedSignal).unbox(box).call(MountOperation.new(arg0))
      }

      __var1 = ::Box.box(AbortedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "aborted", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_aborted(&block : AbortedSignal)
      on_aborted(after: true, &block)
    end

    alias AskPasswordSignal = MountOperation, ::String, ::String, ::String, Gio::AskPasswordFlags -> Nil

    def on_ask_password(*, after = false, &block : AskPasswordSignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, arg1 : Pointer(UInt8), arg2 : Pointer(UInt8), arg3 : Pointer(UInt8), arg4 : LibGio::AskPasswordFlags, box : Void*) {
        ::Box(AskPasswordSignal).unbox(box).call(MountOperation.new(arg0), ::String.new(arg1), ::String.new(arg2), ::String.new(arg3), Gio::AskPasswordFlags.new(arg4))
      }

      __var1 = ::Box.box(AskPasswordSignal.new { |arg0, arg1, arg2, arg3, arg4|
        block.call(arg0, arg1, arg2, arg3, arg4)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "ask-password", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_ask_password(&block : AskPasswordSignal)
      on_ask_password(after: true, &block)
    end

    alias AskQuestionSignal = MountOperation, ::String, ::Enumerable(::String) -> Nil

    def on_ask_question(*, after = false, &block : AskQuestionSignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, arg1 : Pointer(UInt8), arg2 : Pointer(Pointer(UInt8)), box : Void*) {
        ::Box(AskQuestionSignal).unbox(box).call(MountOperation.new(arg0), ::String.new(arg1), GObject::PointerIterator.new(arg2) { |__var3|
          ::String.new(__var3)
        })
      }

      __var1 = ::Box.box(AskQuestionSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "ask-question", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_ask_question(&block : AskQuestionSignal)
      on_ask_question(after: true, &block)
    end

    alias ReplySignal = MountOperation, Gio::MountOperationResult -> Nil

    def on_reply(*, after = false, &block : ReplySignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, arg1 : LibGio::MountOperationResult, box : Void*) {
        ::Box(ReplySignal).unbox(box).call(MountOperation.new(arg0), Gio::MountOperationResult.new(arg1))
      }

      __var1 = ::Box.box(ReplySignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "reply", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_reply(&block : ReplySignal)
      on_reply(after: true, &block)
    end

    alias ShowProcessesSignal = MountOperation, ::String, ::Enumerable(Int32), ::Enumerable(::String) -> Nil

    def on_show_processes(*, after = false, &block : ShowProcessesSignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, arg1 : Pointer(UInt8), arg2 : Pointer(Void), arg3 : Pointer(Pointer(UInt8)), box : Void*) {
        ::Box(ShowProcessesSignal).unbox(box).call(MountOperation.new(arg0), ::String.new(arg1), arg2, GObject::PointerIterator.new(arg3) { |__var4|
          ::String.new(__var4)
        })
      }

      __var1 = ::Box.box(ShowProcessesSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "show-processes", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_show_processes(&block : ShowProcessesSignal)
      on_show_processes(after: true, &block)
    end

    alias ShowUnmountProgressSignal = MountOperation, ::String, Int64, Int64 -> Nil

    def on_show_unmount_progress(*, after = false, &block : ShowUnmountProgressSignal)
      __var0 = ->(arg0 : LibGio::MountOperation*, arg1 : Pointer(UInt8), arg2 : Int64, arg3 : Int64, box : Void*) {
        ::Box(ShowUnmountProgressSignal).unbox(box).call(MountOperation.new(arg0), ::String.new(arg1), arg2, arg3)
      }

      __var1 = ::Box.box(ShowUnmountProgressSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "show-unmount-progress", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_show_unmount_progress(&block : ShowUnmountProgressSignal)
      on_show_unmount_progress(after: true, &block)
    end
  end

  class MountOperationClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(256u64, 0u8).as(LibGio::MountOperationClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::MountOperationClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MountOperationClass*)
    end

    def to_unsafe_mountoperationclass
      @pointer.not_nil!.as(LibGio::MountOperationClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::MountOperationClass*).value.parent_class)
    end

    def ask_password
      to_unsafe.as(LibGio::MountOperationClass*).value.ask_password
    end

    def ask_question
      to_unsafe.as(LibGio::MountOperationClass*).value.ask_question
    end

    def reply
      to_unsafe.as(LibGio::MountOperationClass*).value.reply
    end

    def aborted
      to_unsafe.as(LibGio::MountOperationClass*).value.aborted
    end

    def show_processes
      to_unsafe.as(LibGio::MountOperationClass*).value.show_processes
    end

    def show_unmount_progress
      to_unsafe.as(LibGio::MountOperationClass*).value.show_unmount_progress
    end

    def _g_reserved1
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved7
    end

    def _g_reserved8
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved8
    end

    def _g_reserved9
      to_unsafe.as(LibGio::MountOperationClass*).value._g_reserved9
    end
  end

  class MountOperationPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::MountOperationPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MountOperationPrivate*)
    end

    def to_unsafe_mountoperationprivate
      @pointer.not_nil!.as(LibGio::MountOperationPrivate*)
    end
  end

  enum MountOperationResult : UInt32
    HANDLED   = 0
    ABORTED   = 1
    UNHANDLED = 2
  end

  @[Flags]
  enum MountUnmountFlags : UInt32
    NONE  = 0
    FORCE = 1
  end

  class SocketAddress < GObject::Object
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::SocketAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketAddress*)
    end

    def to_unsafe_socketaddress
      @pointer.not_nil!.as(LibGio::SocketAddress*)
    end

    def self.new_from_native(native : Void*, len : ::Int) : self
      __var0 = LibGio.socket_address_new_from_native(native, UInt64.new(len))
      GObject.raise_unexpected_null("g_socket_address_new_from_native") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def family
      __var0 = LibGio.socket_address_get_family(@pointer.as(LibGio::SocketAddress*))
      Gio::SocketFamily.new(__var0)
    end

    def native_size
      __var0 = LibGio.socket_address_get_native_size(@pointer.as(LibGio::SocketAddress*))
      __var0
    end

    def to_native(dest : Void*?, destlen : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_address_to_native(@pointer.as(LibGio::SocketAddress*), dest ? dest : Pointer(Void).null, UInt64.new(destlen), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class NativeSocketAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::NativeSocketAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::NativeSocketAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NativeSocketAddressClass*)
    end

    def to_unsafe_nativesocketaddressclass
      @pointer.not_nil!.as(LibGio::NativeSocketAddressClass*)
    end

    def parent_class
      Gio::SocketAddressClass.new(to_unsafe.as(LibGio::NativeSocketAddressClass*).value.parent_class)
    end
  end

  class NativeSocketAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::NativeSocketAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NativeSocketAddressPrivate*)
    end

    def to_unsafe_nativesocketaddressprivate
      @pointer.not_nil!.as(LibGio::NativeSocketAddressPrivate*)
    end
  end

  class VolumeMonitor < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::VolumeMonitor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GVolumeMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_volume_monitor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::VolumeMonitor*)
    end

    def to_unsafe_volumemonitor
      @pointer.not_nil!.as(LibGio::VolumeMonitor*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_volume_monitor_get_type, 0, nil, nil).as(Void*)
    end

    def self.adopt_orphan_mount(mount : Gio::Mount)
      __var0 = LibGio.volume_monitor_adopt_orphan_mount(mount.to_unsafe_mount)
      GObject.raise_unexpected_null("g_volume_monitor_adopt_orphan_mount") if __var0.null?
      Gio::Volume::Wrapper.new(__var0)
    end

    def self.get
      __var0 = LibGio.volume_monitor_get
      GObject.raise_unexpected_null("g_volume_monitor_get") if __var0.null?
      Gio::VolumeMonitor.new(__var0)
    end

    def connected_drives
      __var0 = LibGio.volume_monitor_get_connected_drives(@pointer.as(LibGio::VolumeMonitor*))
      GObject.raise_unexpected_null("g_volume_monitor_get_connected_drives") if __var0.null?
      GLib::ListIterator(Gio::Drive, LibGio::Drive*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def mount_for_uuid(uuid : ::String)
      __var0 = LibGio.volume_monitor_get_mount_for_uuid(@pointer.as(LibGio::VolumeMonitor*), uuid.to_unsafe)
      GObject.raise_unexpected_null("g_volume_monitor_get_mount_for_uuid") if __var0.null?
      Gio::Mount::Wrapper.new(__var0)
    end

    def mounts
      __var0 = LibGio.volume_monitor_get_mounts(@pointer.as(LibGio::VolumeMonitor*))
      GObject.raise_unexpected_null("g_volume_monitor_get_mounts") if __var0.null?
      GLib::ListIterator(Gio::Mount, LibGio::Mount*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def volume_for_uuid(uuid : ::String)
      __var0 = LibGio.volume_monitor_get_volume_for_uuid(@pointer.as(LibGio::VolumeMonitor*), uuid.to_unsafe)
      GObject.raise_unexpected_null("g_volume_monitor_get_volume_for_uuid") if __var0.null?
      Gio::Volume::Wrapper.new(__var0)
    end

    def volumes
      __var0 = LibGio.volume_monitor_get_volumes(@pointer.as(LibGio::VolumeMonitor*))
      GObject.raise_unexpected_null("g_volume_monitor_get_volumes") if __var0.null?
      GLib::ListIterator(Gio::Volume, LibGio::Volume*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    alias DriveChangedSignal = VolumeMonitor, Gio::Drive -> Nil

    def on_drive_changed(*, after = false, &block : DriveChangedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Drive*, box : Void*) {
        ::Box(DriveChangedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("drive in drive_changed") : Gio::Drive::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(DriveChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "drive-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_drive_changed(&block : DriveChangedSignal)
      on_drive_changed(after: true, &block)
    end

    alias DriveConnectedSignal = VolumeMonitor, Gio::Drive -> Nil

    def on_drive_connected(*, after = false, &block : DriveConnectedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Drive*, box : Void*) {
        ::Box(DriveConnectedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("drive in drive_connected") : Gio::Drive::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(DriveConnectedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "drive-connected", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_drive_connected(&block : DriveConnectedSignal)
      on_drive_connected(after: true, &block)
    end

    alias DriveDisconnectedSignal = VolumeMonitor, Gio::Drive -> Nil

    def on_drive_disconnected(*, after = false, &block : DriveDisconnectedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Drive*, box : Void*) {
        ::Box(DriveDisconnectedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("drive in drive_disconnected") : Gio::Drive::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(DriveDisconnectedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "drive-disconnected", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_drive_disconnected(&block : DriveDisconnectedSignal)
      on_drive_disconnected(after: true, &block)
    end

    alias DriveEjectButtonSignal = VolumeMonitor, Gio::Drive -> Nil

    def on_drive_eject_button(*, after = false, &block : DriveEjectButtonSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Drive*, box : Void*) {
        ::Box(DriveEjectButtonSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("drive in drive_eject_button") : Gio::Drive::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(DriveEjectButtonSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "drive-eject-button", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_drive_eject_button(&block : DriveEjectButtonSignal)
      on_drive_eject_button(after: true, &block)
    end

    alias DriveStopButtonSignal = VolumeMonitor, Gio::Drive -> Nil

    def on_drive_stop_button(*, after = false, &block : DriveStopButtonSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Drive*, box : Void*) {
        ::Box(DriveStopButtonSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("drive in drive_stop_button") : Gio::Drive::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(DriveStopButtonSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "drive-stop-button", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_drive_stop_button(&block : DriveStopButtonSignal)
      on_drive_stop_button(after: true, &block)
    end

    alias MountAddedSignal = VolumeMonitor, Gio::Mount -> Nil

    def on_mount_added(*, after = false, &block : MountAddedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Mount*, box : Void*) {
        ::Box(MountAddedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("mount in mount_added") : Gio::Mount::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(MountAddedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mount-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mount_added(&block : MountAddedSignal)
      on_mount_added(after: true, &block)
    end

    alias MountChangedSignal = VolumeMonitor, Gio::Mount -> Nil

    def on_mount_changed(*, after = false, &block : MountChangedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Mount*, box : Void*) {
        ::Box(MountChangedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("mount in mount_changed") : Gio::Mount::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(MountChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mount-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mount_changed(&block : MountChangedSignal)
      on_mount_changed(after: true, &block)
    end

    alias MountPreUnmountSignal = VolumeMonitor, Gio::Mount -> Nil

    def on_mount_pre_unmount(*, after = false, &block : MountPreUnmountSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Mount*, box : Void*) {
        ::Box(MountPreUnmountSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("mount in mount_pre_unmount") : Gio::Mount::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(MountPreUnmountSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mount-pre-unmount", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mount_pre_unmount(&block : MountPreUnmountSignal)
      on_mount_pre_unmount(after: true, &block)
    end

    alias MountRemovedSignal = VolumeMonitor, Gio::Mount -> Nil

    def on_mount_removed(*, after = false, &block : MountRemovedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Mount*, box : Void*) {
        ::Box(MountRemovedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("mount in mount_removed") : Gio::Mount::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(MountRemovedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mount-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mount_removed(&block : MountRemovedSignal)
      on_mount_removed(after: true, &block)
    end

    alias VolumeAddedSignal = VolumeMonitor, Gio::Volume -> Nil

    def on_volume_added(*, after = false, &block : VolumeAddedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Volume*, box : Void*) {
        ::Box(VolumeAddedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("volume in volume_added") : Gio::Volume::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(VolumeAddedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "volume-added", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_volume_added(&block : VolumeAddedSignal)
      on_volume_added(after: true, &block)
    end

    alias VolumeChangedSignal = VolumeMonitor, Gio::Volume -> Nil

    def on_volume_changed(*, after = false, &block : VolumeChangedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Volume*, box : Void*) {
        ::Box(VolumeChangedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("volume in volume_changed") : Gio::Volume::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(VolumeChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "volume-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_volume_changed(&block : VolumeChangedSignal)
      on_volume_changed(after: true, &block)
    end

    alias VolumeRemovedSignal = VolumeMonitor, Gio::Volume -> Nil

    def on_volume_removed(*, after = false, &block : VolumeRemovedSignal)
      __var0 = ->(arg0 : LibGio::VolumeMonitor*, arg1 : LibGio::Volume*, box : Void*) {
        ::Box(VolumeRemovedSignal).unbox(box).call(VolumeMonitor.new(arg0), arg1.null? ? GObject.raise_unexpected_null("volume in volume_removed") : Gio::Volume::Wrapper.new(arg1))
      }

      __var1 = ::Box.box(VolumeRemovedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "volume-removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_volume_removed(&block : VolumeRemovedSignal)
      on_volume_removed(after: true, &block)
    end
  end

  class NativeVolumeMonitorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(344u64, 0u8).as(LibGio::NativeVolumeMonitorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::NativeVolumeMonitorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NativeVolumeMonitorClass*)
    end

    def to_unsafe_nativevolumemonitorclass
      @pointer.not_nil!.as(LibGio::NativeVolumeMonitorClass*)
    end

    def parent_class
      Gio::VolumeMonitorClass.new(to_unsafe.as(LibGio::NativeVolumeMonitorClass*).value.parent_class)
    end

    def get_mount_for_mount_path
      to_unsafe.as(LibGio::NativeVolumeMonitorClass*).value.get_mount_for_mount_path
    end
  end

  class NetworkAddress < GObject::Object
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GNetworkAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_network_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkAddress*)
    end

    def to_unsafe_networkaddress
      @pointer.not_nil!.as(LibGio::NetworkAddress*)
    end

    def initialize(*, hostname : ::String? = nil, port : UInt32? = nil, scheme : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless hostname.nil?
        __var0 << "hostname".to_unsafe
        __var1 << hostname.to_gvalue.to_unsafe.value
      end

      unless port.nil?
        __var0 << "port".to_unsafe
        __var1 << port.to_gvalue.to_unsafe.value
      end

      unless scheme.nil?
        __var0 << "scheme".to_unsafe
        __var1 << scheme.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_network_address_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(hostname : ::String, port : ::Int) : self
      __var0 = LibGio.network_address_new(hostname.to_unsafe, UInt16.new(port))
      GObject.raise_unexpected_null("g_network_address_new") if __var0.null?
      cast(Gio::NetworkAddress.new(__var0))
    end

    def self.new_loopback(port : ::Int) : self
      __var0 = LibGio.network_address_new_loopback(UInt16.new(port))
      GObject.raise_unexpected_null("g_network_address_new_loopback") if __var0.null?
      cast(Gio::NetworkAddress.new(__var0))
    end

    def self.parse(host_and_port : ::String, default_port : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.network_address_parse(host_and_port.to_unsafe, UInt16.new(default_port), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_network_address_parse") if __var1.null?
      Gio::NetworkAddress.new(__var1)
    end

    def self.parse_uri(uri : ::String, default_port : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.network_address_parse_uri(uri.to_unsafe, UInt16.new(default_port), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_network_address_parse_uri") if __var1.null?
      Gio::NetworkAddress.new(__var1)
    end

    def hostname
      __var0 = LibGio.network_address_get_hostname(@pointer.as(LibGio::NetworkAddress*))
      GObject.raise_unexpected_null("g_network_address_get_hostname") if __var0.null?
      ::String.new(__var0)
    end

    def port
      __var0 = LibGio.network_address_get_port(@pointer.as(LibGio::NetworkAddress*))
      __var0
    end

    def scheme
      __var0 = LibGio.network_address_get_scheme(@pointer.as(LibGio::NetworkAddress*))
      GObject.raise_unexpected_null("g_network_address_get_scheme") if __var0.null?
      ::String.new(__var0)
    end
  end

  class NetworkAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::NetworkAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkAddressClass*)
    end

    def to_unsafe_networkaddressclass
      @pointer.not_nil!.as(LibGio::NetworkAddressClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::NetworkAddressClass*).value.parent_class)
    end
  end

  class NetworkAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkAddressPrivate*)
    end

    def to_unsafe_networkaddressprivate
      @pointer.not_nil!.as(LibGio::NetworkAddressPrivate*)
    end
  end

  enum NetworkConnectivity : UInt32
    ZERO_NONE = 0
    LOCAL     = 1
    LIMITED   = 2
    PORTAL    = 3
    FULL      = 4
  end

  module NetworkMonitor
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include NetworkMonitor
      @pointer : Void*

      def initialize(pointer : LibGio::NetworkMonitor*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GNetworkMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_network_monitor_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::NetworkMonitor*)
      end

      def to_unsafe_networkmonitor
        @pointer.not_nil!.as(LibGio::NetworkMonitor*)
      end
    end

    def to_unsafe_networkmonitor
      @pointer.not_nil!.as(LibGio::NetworkMonitor*)
    end

    def self.default
      __var0 = LibGio.network_monitor_get_default
      GObject.raise_unexpected_null("g_network_monitor_get_default") if __var0.null?
      Gio::NetworkMonitor::Wrapper.new(__var0)
    end

    def can_reach(connectable : Gio::SocketConnectable, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.network_monitor_can_reach(@pointer.as(LibGio::NetworkMonitor*), connectable.to_unsafe_socketconnectable, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def can_reach_async(connectable : Gio::SocketConnectable, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.network_monitor_can_reach_async(@pointer.as(LibGio::NetworkMonitor*), connectable.to_unsafe_socketconnectable, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def can_reach_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.network_monitor_can_reach_finish(@pointer.as(LibGio::NetworkMonitor*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def connectivity
      __var0 = LibGio.network_monitor_get_connectivity(@pointer.as(LibGio::NetworkMonitor*))
      Gio::NetworkConnectivity.new(__var0)
    end

    def network_available
      __var0 = LibGio.network_monitor_get_network_available(@pointer.as(LibGio::NetworkMonitor*))
      (__var0 == 1)
    end

    def network_metered
      __var0 = LibGio.network_monitor_get_network_metered(@pointer.as(LibGio::NetworkMonitor*))
      (__var0 == 1)
    end

    alias NetworkChangedSignal = NetworkMonitor, ::Bool -> Nil

    def on_network_changed(*, after = false, &block : NetworkChangedSignal)
      __var0 = ->(arg0 : LibGio::NetworkMonitor*, arg1 : LibC::Int, box : Void*) {
        ::Box(NetworkChangedSignal).unbox(box).call(NetworkMonitor::Wrapper.new(arg0), (arg1 == 1))
      }

      __var1 = ::Box.box(NetworkChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "network-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_network_changed(&block : NetworkChangedSignal)
      on_network_changed(after: true, &block)
    end
  end

  class NetworkMonitorInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::NetworkMonitorInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkMonitorInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkMonitorInterface*)
    end

    def to_unsafe_networkmonitorinterface
      @pointer.not_nil!.as(LibGio::NetworkMonitorInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::NetworkMonitorInterface*).value.g_iface)
    end

    def network_changed
      to_unsafe.as(LibGio::NetworkMonitorInterface*).value.network_changed
    end

    def can_reach
      to_unsafe.as(LibGio::NetworkMonitorInterface*).value.can_reach
    end

    def can_reach_async
      to_unsafe.as(LibGio::NetworkMonitorInterface*).value.can_reach_async
    end

    def can_reach_finish
      to_unsafe.as(LibGio::NetworkMonitorInterface*).value.can_reach_finish
    end
  end

  class NetworkService < GObject::Object
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkService*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GNetworkService")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_network_service_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkService*)
    end

    def to_unsafe_networkservice
      @pointer.not_nil!.as(LibGio::NetworkService*)
    end

    def initialize(*, domain : ::String? = nil, protocol : ::String? = nil, scheme : ::String? = nil, service : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless domain.nil?
        __var0 << "domain".to_unsafe
        __var1 << domain.to_gvalue.to_unsafe.value
      end

      unless protocol.nil?
        __var0 << "protocol".to_unsafe
        __var1 << protocol.to_gvalue.to_unsafe.value
      end

      unless scheme.nil?
        __var0 << "scheme".to_unsafe
        __var1 << scheme.to_gvalue.to_unsafe.value
      end

      unless service.nil?
        __var0 << "service".to_unsafe
        __var1 << service.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_network_service_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(service : ::String, protocol : ::String, domain : ::String) : self
      __var0 = LibGio.network_service_new(service.to_unsafe, protocol.to_unsafe, domain.to_unsafe)
      GObject.raise_unexpected_null("g_network_service_new") if __var0.null?
      cast(Gio::NetworkService.new(__var0))
    end

    def domain
      __var0 = LibGio.network_service_get_domain(@pointer.as(LibGio::NetworkService*))
      GObject.raise_unexpected_null("g_network_service_get_domain") if __var0.null?
      ::String.new(__var0)
    end

    def protocol
      __var0 = LibGio.network_service_get_protocol(@pointer.as(LibGio::NetworkService*))
      GObject.raise_unexpected_null("g_network_service_get_protocol") if __var0.null?
      ::String.new(__var0)
    end

    def scheme
      __var0 = LibGio.network_service_get_scheme(@pointer.as(LibGio::NetworkService*))
      GObject.raise_unexpected_null("g_network_service_get_scheme") if __var0.null?
      ::String.new(__var0)
    end

    def service
      __var0 = LibGio.network_service_get_service(@pointer.as(LibGio::NetworkService*))
      GObject.raise_unexpected_null("g_network_service_get_service") if __var0.null?
      ::String.new(__var0)
    end

    def scheme=(scheme : ::String)
      LibGio.network_service_set_scheme(@pointer.as(LibGio::NetworkService*), scheme.to_unsafe)
      nil
    end
  end

  class NetworkServiceClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::NetworkServiceClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkServiceClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkServiceClass*)
    end

    def to_unsafe_networkserviceclass
      @pointer.not_nil!.as(LibGio::NetworkServiceClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::NetworkServiceClass*).value.parent_class)
    end
  end

  class NetworkServicePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::NetworkServicePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NetworkServicePrivate*)
    end

    def to_unsafe_networkserviceprivate
      @pointer.not_nil!.as(LibGio::NetworkServicePrivate*)
    end
  end

  class Notification < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Notification*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GNotification")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_notification_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Notification*)
    end

    def to_unsafe_notification
      @pointer.not_nil!.as(LibGio::Notification*)
    end

    def self.new(title : ::String) : self
      __var0 = LibGio.notification_new(title.to_unsafe)
      GObject.raise_unexpected_null("g_notification_new") if __var0.null?
      cast(Gio::Notification.new(__var0))
    end

    def add_button(label : ::String, detailed_action : ::String)
      LibGio.notification_add_button(@pointer.as(LibGio::Notification*), label.to_unsafe, detailed_action.to_unsafe)
      nil
    end

    def add_button_with_target(label : ::String, action : ::String, target : GLib::Variant?)
      LibGio.notification_add_button_with_target(@pointer.as(LibGio::Notification*), label.to_unsafe, action.to_unsafe, target ? target.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def body=(body : ::String?)
      LibGio.notification_set_body(@pointer.as(LibGio::Notification*), body ? body.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def default_action=(detailed_action : ::String)
      LibGio.notification_set_default_action(@pointer.as(LibGio::Notification*), detailed_action.to_unsafe)
      nil
    end

    def set_default_action_and_target(action : ::String, target : GLib::Variant?)
      LibGio.notification_set_default_action_and_target(@pointer.as(LibGio::Notification*), action.to_unsafe, target ? target.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def icon=(icon : Gio::Icon)
      LibGio.notification_set_icon(@pointer.as(LibGio::Notification*), icon.to_unsafe_icon)
      nil
    end

    def priority=(priority : Gio::NotificationPriority)
      LibGio.notification_set_priority(@pointer.as(LibGio::Notification*), priority)
      nil
    end

    def title=(title : ::String)
      LibGio.notification_set_title(@pointer.as(LibGio::Notification*), title.to_unsafe)
      nil
    end

    def urgent=(urgent : ::Bool)
      LibGio.notification_set_urgent(@pointer.as(LibGio::Notification*), LibC::Int.new(urgent ? 1 : 0))
      nil
    end
  end

  enum NotificationPriority : UInt32
    NORMAL = 0
    LOW    = 1
    HIGH   = 2
    URGENT = 3
  end

  class OutputMessage
    include GObject::WrappedType

    def self.new(address : Gio::SocketAddress? = nil, vectors : Gio::OutputVector? = nil, num_vectors : UInt32? = nil, bytes_sent : UInt32? = nil, control_messages : ::Enumerable(Gio::SocketControlMessage)? = nil, num_control_messages : UInt32? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::OutputMessage*))
      __var0.address = address unless address.nil?
      __var0.vectors = vectors unless vectors.nil?
      __var0.num_vectors = num_vectors unless num_vectors.nil?
      __var0.bytes_sent = bytes_sent unless bytes_sent.nil?
      __var0.control_messages = control_messages unless control_messages.nil?
      __var0.num_control_messages = num_control_messages unless num_control_messages.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::OutputMessage*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::OutputMessage*)
    end

    def to_unsafe_outputmessage
      @pointer.not_nil!.as(LibGio::OutputMessage*)
    end

    def address
      Gio::SocketAddress.new(to_unsafe.as(LibGio::OutputMessage*).value.address)
    end

    def address=(value : Gio::SocketAddress)
      to_unsafe.as(LibGio::OutputMessage*).value.address = value.to_unsafe_socketaddress
    end

    def vectors
      Gio::OutputVector.new(to_unsafe.as(LibGio::OutputMessage*).value.vectors)
    end

    def vectors=(value : Gio::OutputVector)
      to_unsafe.as(LibGio::OutputMessage*).value.vectors = value.to_unsafe.as(LibGio::OutputVector*)
    end

    def num_vectors
      to_unsafe.as(LibGio::OutputMessage*).value.num_vectors
    end

    def num_vectors=(value : UInt32)
      to_unsafe.as(LibGio::OutputMessage*).value.num_vectors = UInt32.new(value)
    end

    def bytes_sent
      to_unsafe.as(LibGio::OutputMessage*).value.bytes_sent
    end

    def bytes_sent=(value : UInt32)
      to_unsafe.as(LibGio::OutputMessage*).value.bytes_sent = UInt32.new(value)
    end

    def control_messages
      GObject::PointerIterator.new(to_unsafe.as(LibGio::OutputMessage*).value.control_messages) { |__var0|
        Gio::SocketControlMessage.new(__var0)
      }
    end

    def control_messages=(value : ::Enumerable(Gio::SocketControlMessage))
      to_unsafe.as(LibGio::OutputMessage*).value.control_messages = (__value_ary = value.map { |__item| __item.to_unsafe_socketcontrolmessage }.to_a).to_unsafe
    end

    def num_control_messages
      to_unsafe.as(LibGio::OutputMessage*).value.num_control_messages
    end

    def num_control_messages=(value : UInt32)
      to_unsafe.as(LibGio::OutputMessage*).value.num_control_messages = UInt32.new(value)
    end
  end

  class ConverterOutputStream < FilterOutputStream
    include Gio::PollableOutputStream

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GConverterOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_converter_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterOutputStream*)
    end

    def to_unsafe_converteroutputstream
      @pointer.not_nil!.as(LibGio::ConverterOutputStream*)
    end

    def initialize(*, base_stream : Gio::OutputStream? = nil, close_base_stream : ::Bool? = nil, converter : Gio::Converter? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      unless converter.nil?
        __var0 << "converter".to_unsafe
        __var1 << converter.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_converter_output_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::OutputStream, converter : Gio::Converter) : self
      __var0 = LibGio.converter_output_stream_new(base_stream.to_unsafe_outputstream, converter.to_unsafe_converter)
      GObject.raise_unexpected_null("g_converter_output_stream_new") if __var0.null?
      cast(Gio::OutputStream.new(__var0))
    end

    def converter
      __var0 = LibGio.converter_output_stream_get_converter(@pointer.as(LibGio::ConverterOutputStream*))
      GObject.raise_unexpected_null("g_converter_output_stream_get_converter") if __var0.null?
      Gio::Converter::Wrapper.new(__var0)
    end
  end

  class OutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(296u64, 0u8).as(LibGio::OutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::OutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::OutputStreamClass*)
    end

    def to_unsafe_outputstreamclass
      @pointer.not_nil!.as(LibGio::OutputStreamClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::OutputStreamClass*).value.parent_class)
    end

    def write_fn
      to_unsafe.as(LibGio::OutputStreamClass*).value.write_fn
    end

    def splice
      to_unsafe.as(LibGio::OutputStreamClass*).value.splice
    end

    def flush
      to_unsafe.as(LibGio::OutputStreamClass*).value.flush
    end

    def close_fn
      to_unsafe.as(LibGio::OutputStreamClass*).value.close_fn
    end

    def write_async
      to_unsafe.as(LibGio::OutputStreamClass*).value.write_async
    end

    def write_finish
      to_unsafe.as(LibGio::OutputStreamClass*).value.write_finish
    end

    def splice_async
      to_unsafe.as(LibGio::OutputStreamClass*).value.splice_async
    end

    def splice_finish
      to_unsafe.as(LibGio::OutputStreamClass*).value.splice_finish
    end

    def flush_async
      to_unsafe.as(LibGio::OutputStreamClass*).value.flush_async
    end

    def flush_finish
      to_unsafe.as(LibGio::OutputStreamClass*).value.flush_finish
    end

    def close_async
      to_unsafe.as(LibGio::OutputStreamClass*).value.close_async
    end

    def close_finish
      to_unsafe.as(LibGio::OutputStreamClass*).value.close_finish
    end

    def writev_fn
      to_unsafe.as(LibGio::OutputStreamClass*).value.writev_fn
    end

    def writev_async
      to_unsafe.as(LibGio::OutputStreamClass*).value.writev_async
    end

    def writev_finish
      to_unsafe.as(LibGio::OutputStreamClass*).value.writev_finish
    end

    def _g_reserved4
      to_unsafe.as(LibGio::OutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::OutputStreamClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::OutputStreamClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::OutputStreamClass*).value._g_reserved7
    end

    def _g_reserved8
      to_unsafe.as(LibGio::OutputStreamClass*).value._g_reserved8
    end
  end

  class OutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::OutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::OutputStreamPrivate*)
    end

    def to_unsafe_outputstreamprivate
      @pointer.not_nil!.as(LibGio::OutputStreamPrivate*)
    end
  end

  @[Flags]
  enum OutputStreamSpliceFlags : UInt32
    NONE         = 0
    CLOSE_SOURCE = 1
    CLOSE_TARGET = 2
  end

  class OutputVector
    include GObject::WrappedType

    def self.new(buffer : Void*? = nil, size : UInt64? = nil) : self
      __var0 = new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::OutputVector*))
      __var0.buffer = buffer unless buffer.nil?
      __var0.size = size unless size.nil?
      __var0
    end

    @pointer : Void*

    def initialize(pointer : LibGio::OutputVector*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::OutputVector*)
    end

    def to_unsafe_outputvector
      @pointer.not_nil!.as(LibGio::OutputVector*)
    end

    def buffer
      to_unsafe.as(LibGio::OutputVector*).value.buffer
    end

    def buffer=(value : Void*)
      to_unsafe.as(LibGio::OutputVector*).value.buffer = value
    end

    def size
      to_unsafe.as(LibGio::OutputVector*).value.size
    end

    def size=(value : UInt64)
      to_unsafe.as(LibGio::OutputVector*).value.size = UInt64.new(value)
    end
  end

  enum PasswordSave : UInt32
    NEVER       = 0
    FOR_SESSION = 1
    PERMANENTLY = 2
  end

  class Permission < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Permission*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GPermission")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_permission_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Permission*)
    end

    def to_unsafe_permission
      @pointer.not_nil!.as(LibGio::Permission*)
    end

    def acquire(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.permission_acquire(@pointer.as(LibGio::Permission*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def acquire_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.permission_acquire_async(@pointer.as(LibGio::Permission*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def acquire_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.permission_acquire_finish(@pointer.as(LibGio::Permission*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def allowed
      __var0 = LibGio.permission_get_allowed(@pointer.as(LibGio::Permission*))
      (__var0 == 1)
    end

    def can_acquire
      __var0 = LibGio.permission_get_can_acquire(@pointer.as(LibGio::Permission*))
      (__var0 == 1)
    end

    def can_release
      __var0 = LibGio.permission_get_can_release(@pointer.as(LibGio::Permission*))
      (__var0 == 1)
    end

    def impl_update(allowed : ::Bool, can_acquire : ::Bool, can_release : ::Bool)
      LibGio.permission_impl_update(@pointer.as(LibGio::Permission*), LibC::Int.new(allowed ? 1 : 0), LibC::Int.new(can_acquire ? 1 : 0), LibC::Int.new(can_release ? 1 : 0))
      nil
    end

    def release(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.permission_release(@pointer.as(LibGio::Permission*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def release_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.permission_release_async(@pointer.as(LibGio::Permission*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def release_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.permission_release_finish(@pointer.as(LibGio::Permission*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class PermissionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(312u64, 0u8).as(LibGio::PermissionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::PermissionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::PermissionClass*)
    end

    def to_unsafe_permissionclass
      @pointer.not_nil!.as(LibGio::PermissionClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::PermissionClass*).value.parent_class)
    end

    def acquire
      to_unsafe.as(LibGio::PermissionClass*).value.acquire
    end

    def acquire_async
      to_unsafe.as(LibGio::PermissionClass*).value.acquire_async
    end

    def acquire_finish
      to_unsafe.as(LibGio::PermissionClass*).value.acquire_finish
    end

    def release
      to_unsafe.as(LibGio::PermissionClass*).value.release
    end

    def release_async
      to_unsafe.as(LibGio::PermissionClass*).value.release_async
    end

    def release_finish
      to_unsafe.as(LibGio::PermissionClass*).value.release_finish
    end

    def reserved
      GObject::PointerIterator.new(to_unsafe.as(LibGio::PermissionClass*).value.reserved) { |__var0|
        __var0
      }
    end
  end

  class PermissionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::PermissionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::PermissionPrivate*)
    end

    def to_unsafe_permissionprivate
      @pointer.not_nil!.as(LibGio::PermissionPrivate*)
    end
  end

  class ConverterInputStream < FilterInputStream
    include Gio::PollableInputStream

    @pointer : Void*

    def initialize(pointer : LibGio::ConverterInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GConverterInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_converter_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ConverterInputStream*)
    end

    def to_unsafe_converterinputstream
      @pointer.not_nil!.as(LibGio::ConverterInputStream*)
    end

    def initialize(*, base_stream : Gio::InputStream? = nil, close_base_stream : ::Bool? = nil, converter : Gio::Converter? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      unless converter.nil?
        __var0 << "converter".to_unsafe
        __var1 << converter.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_converter_input_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::InputStream, converter : Gio::Converter) : self
      __var0 = LibGio.converter_input_stream_new(base_stream.to_unsafe_inputstream, converter.to_unsafe_converter)
      GObject.raise_unexpected_null("g_converter_input_stream_new") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def converter
      __var0 = LibGio.converter_input_stream_get_converter(@pointer.as(LibGio::ConverterInputStream*))
      GObject.raise_unexpected_null("g_converter_input_stream_get_converter") if __var0.null?
      Gio::Converter::Wrapper.new(__var0)
    end
  end

  class PollableInputStreamInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::PollableInputStreamInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::PollableInputStreamInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::PollableInputStreamInterface*)
    end

    def to_unsafe_pollableinputstreaminterface
      @pointer.not_nil!.as(LibGio::PollableInputStreamInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::PollableInputStreamInterface*).value.g_iface)
    end

    def can_poll
      to_unsafe.as(LibGio::PollableInputStreamInterface*).value.can_poll
    end

    def is_readable
      to_unsafe.as(LibGio::PollableInputStreamInterface*).value.is_readable
    end

    def create_source
      to_unsafe.as(LibGio::PollableInputStreamInterface*).value.create_source
    end

    def read_nonblocking
      to_unsafe.as(LibGio::PollableInputStreamInterface*).value.read_nonblocking
    end
  end

  class MemoryOutputStream < OutputStream
    include Gio::PollableOutputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::MemoryOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GMemoryOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_memory_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::MemoryOutputStream*)
    end

    def to_unsafe_memoryoutputstream
      @pointer.not_nil!.as(LibGio::MemoryOutputStream*)
    end

    def initialize(*, data : Void*? = nil, size : UInt64? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless data.nil?
        __var0 << "data".to_unsafe
        __var1 << data.to_gvalue.to_unsafe.value
      end

      unless size.nil?
        __var0 << "size".to_unsafe
        __var1 << size.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_memory_output_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new_resizable : self
      __var0 = LibGio.memory_output_stream_new_resizable
      GObject.raise_unexpected_null("g_memory_output_stream_new_resizable") if __var0.null?
      cast(Gio::OutputStream.new(__var0))
    end

    def data
      LibGio.memory_output_stream_get_data(@pointer.as(LibGio::MemoryOutputStream*))
      nil
    end

    def data_size
      __var0 = LibGio.memory_output_stream_get_data_size(@pointer.as(LibGio::MemoryOutputStream*))
      __var0
    end

    def size
      __var0 = LibGio.memory_output_stream_get_size(@pointer.as(LibGio::MemoryOutputStream*))
      __var0
    end

    def steal_as_bytes
      __var0 = LibGio.memory_output_stream_steal_as_bytes(@pointer.as(LibGio::MemoryOutputStream*))
      GObject.raise_unexpected_null("g_memory_output_stream_steal_as_bytes") if __var0.null?
      GLib::Bytes.new(__var0)
    end

    def steal_data
      LibGio.memory_output_stream_steal_data(@pointer.as(LibGio::MemoryOutputStream*))
      nil
    end
  end

  class PollableOutputStreamInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::PollableOutputStreamInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::PollableOutputStreamInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::PollableOutputStreamInterface*)
    end

    def to_unsafe_pollableoutputstreaminterface
      @pointer.not_nil!.as(LibGio::PollableOutputStreamInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.g_iface)
    end

    def can_poll
      to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.can_poll
    end

    def is_writable
      to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.is_writable
    end

    def create_source
      to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.create_source
    end

    def write_nonblocking
      to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.write_nonblocking
    end

    def writev_nonblocking
      to_unsafe.as(LibGio::PollableOutputStreamInterface*).value.writev_nonblocking
    end
  end

  enum PollableReturn : Int32
    FAILED      =   0
    OK          =   1
    WOULD_BLOCK = -27
  end
  alias PollableSourceFunc = LibGio::PollableSourceFunc

  class PropertyAction < GObject::Object
    include Gio::Action

    @pointer : Void*

    def initialize(pointer : LibGio::PropertyAction*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GPropertyAction")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_property_action_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::PropertyAction*)
    end

    def to_unsafe_propertyaction
      @pointer.not_nil!.as(LibGio::PropertyAction*)
    end

    def initialize(*, invert_boolean : ::Bool? = nil, name : ::String? = nil, object : GObject::Object? = nil, property_name : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless invert_boolean.nil?
        __var0 << "invert-boolean".to_unsafe
        __var1 << invert_boolean.to_gvalue.to_unsafe.value
      end

      unless name.nil?
        __var0 << "name".to_unsafe
        __var1 << name.to_gvalue.to_unsafe.value
      end

      unless object.nil?
        __var0 << "object".to_unsafe
        __var1 << object.to_gvalue.to_unsafe.value
      end

      unless property_name.nil?
        __var0 << "property-name".to_unsafe
        __var1 << property_name.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_property_action_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(name : ::String, object : GObject::Object, property_name : ::String) : self
      __var0 = LibGio.property_action_new(name.to_unsafe, object.to_unsafe_object, property_name.to_unsafe)
      GObject.raise_unexpected_null("g_property_action_new") if __var0.null?
      cast(Gio::PropertyAction.new(__var0))
    end

    def enabled : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "enabled", __var0)
      __var0.boolean
    end

    def invert_boolean : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "invert-boolean", __var0)
      __var0.boolean
    end

    def name : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "name", __var0)
      __var0.string
    end

    def parameter_type : GLib::VariantType
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "parameter-type", __var0)
      GLib::VariantType.cast(__var0.object)
    end

    def state : GLib::Variant
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "state", __var0)
      GLib::Variant.cast(__var0.object)
    end

    def state_type : GLib::VariantType
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "state-type", __var0)
      GLib::VariantType.cast(__var0.object)
    end
  end

  module Proxy
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Proxy
      @pointer : Void*

      def initialize(pointer : LibGio::Proxy*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GProxy")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_proxy_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Proxy*)
      end

      def to_unsafe_proxy
        @pointer.not_nil!.as(LibGio::Proxy*)
      end
    end

    def to_unsafe_proxy
      @pointer.not_nil!.as(LibGio::Proxy*)
    end

    def self.default_for_protocol(protocol : ::String)
      __var0 = LibGio.proxy_get_default_for_protocol(protocol.to_unsafe)
      GObject.raise_unexpected_null("g_proxy_get_default_for_protocol") if __var0.null?
      Gio::Proxy::Wrapper.new(__var0)
    end

    def connect(connection : Gio::IOStream, proxy_address : Gio::ProxyAddress, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.proxy_connect(@pointer.as(LibGio::Proxy*), connection.to_unsafe_iostream, proxy_address.to_unsafe_proxyaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_proxy_connect") if __var1.null?
      Gio::IOStream.new(__var1)
    end

    def connect_async(connection : Gio::IOStream, proxy_address : Gio::ProxyAddress, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.proxy_connect_async(@pointer.as(LibGio::Proxy*), connection.to_unsafe_iostream, proxy_address.to_unsafe_proxyaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.proxy_connect_finish(@pointer.as(LibGio::Proxy*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_proxy_connect_finish") if __var1.null?
      Gio::IOStream.new(__var1)
    end

    def supports_hostname
      __var0 = LibGio.proxy_supports_hostname(@pointer.as(LibGio::Proxy*))
      (__var0 == 1)
    end
  end

  class InetSocketAddress < SocketAddress
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::InetSocketAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GInetSocketAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_inet_socket_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::InetSocketAddress*)
    end

    def to_unsafe_inetsocketaddress
      @pointer.not_nil!.as(LibGio::InetSocketAddress*)
    end

    def initialize(*, address : Gio::InetAddress? = nil, flowinfo : UInt32? = nil, port : UInt32? = nil, scope_id : UInt32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless address.nil?
        __var0 << "address".to_unsafe
        __var1 << address.to_gvalue.to_unsafe.value
      end

      unless flowinfo.nil?
        __var0 << "flowinfo".to_unsafe
        __var1 << flowinfo.to_gvalue.to_unsafe.value
      end

      unless port.nil?
        __var0 << "port".to_unsafe
        __var1 << port.to_gvalue.to_unsafe.value
      end

      unless scope_id.nil?
        __var0 << "scope-id".to_unsafe
        __var1 << scope_id.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_inet_socket_address_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(address : Gio::InetAddress, port : ::Int) : self
      __var0 = LibGio.inet_socket_address_new(address.to_unsafe_inetaddress, UInt16.new(port))
      GObject.raise_unexpected_null("g_inet_socket_address_new") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def self.new_from_string(address : ::String, port : ::Int) : self
      __var0 = LibGio.inet_socket_address_new_from_string(address.to_unsafe, UInt32.new(port))
      GObject.raise_unexpected_null("g_inet_socket_address_new_from_string") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def address
      __var0 = LibGio.inet_socket_address_get_address(@pointer.as(LibGio::InetSocketAddress*))
      GObject.raise_unexpected_null("g_inet_socket_address_get_address") if __var0.null?
      Gio::InetAddress.new(__var0)
    end

    def flowinfo
      __var0 = LibGio.inet_socket_address_get_flowinfo(@pointer.as(LibGio::InetSocketAddress*))
      __var0
    end

    def port
      __var0 = LibGio.inet_socket_address_get_port(@pointer.as(LibGio::InetSocketAddress*))
      __var0
    end

    def scope_id
      __var0 = LibGio.inet_socket_address_get_scope_id(@pointer.as(LibGio::InetSocketAddress*))
      __var0
    end
  end

  class ProxyAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::ProxyAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddressClass*)
    end

    def to_unsafe_proxyaddressclass
      @pointer.not_nil!.as(LibGio::ProxyAddressClass*)
    end

    def parent_class
      Gio::InetSocketAddressClass.new(to_unsafe.as(LibGio::ProxyAddressClass*).value.parent_class)
    end
  end

  class SocketAddressEnumerator < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SocketAddressEnumerator*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketAddressEnumerator")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_address_enumerator_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketAddressEnumerator*)
    end

    def to_unsafe_socketaddressenumerator
      @pointer.not_nil!.as(LibGio::SocketAddressEnumerator*)
    end

    def next(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_address_enumerator_next(@pointer.as(LibGio::SocketAddressEnumerator*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_address_enumerator_next") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end

    def next_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_address_enumerator_next_async(@pointer.as(LibGio::SocketAddressEnumerator*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def next_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_address_enumerator_next_finish(@pointer.as(LibGio::SocketAddressEnumerator*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_address_enumerator_next_finish") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end
  end

  class ProxyAddressEnumeratorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(216u64, 0u8).as(LibGio::ProxyAddressEnumeratorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddressEnumeratorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumeratorClass*)
    end

    def to_unsafe_proxyaddressenumeratorclass
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumeratorClass*)
    end

    def parent_class
      Gio::SocketAddressEnumeratorClass.new(to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::ProxyAddressEnumeratorClass*).value._g_reserved7
    end
  end

  class ProxyAddressEnumeratorPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddressEnumeratorPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumeratorPrivate*)
    end

    def to_unsafe_proxyaddressenumeratorprivate
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumeratorPrivate*)
    end
  end

  class ProxyAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddressPrivate*)
    end

    def to_unsafe_proxyaddressprivate
      @pointer.not_nil!.as(LibGio::ProxyAddressPrivate*)
    end
  end

  class ProxyInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::ProxyInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyInterface*)
    end

    def to_unsafe_proxyinterface
      @pointer.not_nil!.as(LibGio::ProxyInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ProxyInterface*).value.g_iface)
    end

    def connect
      to_unsafe.as(LibGio::ProxyInterface*).value.connect
    end

    def connect_async
      to_unsafe.as(LibGio::ProxyInterface*).value.connect_async
    end

    def connect_finish
      to_unsafe.as(LibGio::ProxyInterface*).value.connect_finish
    end

    def supports_hostname
      to_unsafe.as(LibGio::ProxyInterface*).value.supports_hostname
    end
  end

  module ProxyResolver
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include ProxyResolver
      @pointer : Void*

      def initialize(pointer : LibGio::ProxyResolver*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GProxyResolver")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_proxy_resolver_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::ProxyResolver*)
      end

      def to_unsafe_proxyresolver
        @pointer.not_nil!.as(LibGio::ProxyResolver*)
      end
    end

    def to_unsafe_proxyresolver
      @pointer.not_nil!.as(LibGio::ProxyResolver*)
    end

    def self.default
      __var0 = LibGio.proxy_resolver_get_default
      GObject.raise_unexpected_null("g_proxy_resolver_get_default") if __var0.null?
      Gio::ProxyResolver::Wrapper.new(__var0)
    end

    def supported?
      __var0 = LibGio.proxy_resolver_is_supported(@pointer.as(LibGio::ProxyResolver*))
      (__var0 == 1)
    end

    def lookup(uri : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.proxy_resolver_lookup(@pointer.as(LibGio::ProxyResolver*), uri.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_proxy_resolver_lookup") if __var1.null?
      GObject::PointerIterator.new(__var1) { |__var2|
        ::String.new(__var2)
      }
    end

    def lookup_async(uri : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.proxy_resolver_lookup_async(@pointer.as(LibGio::ProxyResolver*), uri.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.proxy_resolver_lookup_finish(@pointer.as(LibGio::ProxyResolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_proxy_resolver_lookup_finish") if __var1.null?
      GObject::PointerIterator.new(__var1) { |__var2|
        ::String.new(__var2)
      }
    end
  end

  class ProxyResolverInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(48u64, 0u8).as(LibGio::ProxyResolverInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyResolverInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyResolverInterface*)
    end

    def to_unsafe_proxyresolverinterface
      @pointer.not_nil!.as(LibGio::ProxyResolverInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::ProxyResolverInterface*).value.g_iface)
    end

    def is_supported
      to_unsafe.as(LibGio::ProxyResolverInterface*).value.is_supported
    end

    def lookup
      to_unsafe.as(LibGio::ProxyResolverInterface*).value.lookup
    end

    def lookup_async
      to_unsafe.as(LibGio::ProxyResolverInterface*).value.lookup_async
    end

    def lookup_finish
      to_unsafe.as(LibGio::ProxyResolverInterface*).value.lookup_finish
    end
  end

  alias ReallocFunc = LibGio::ReallocFunc

  class DBusActionGroup < GObject::Object
    include Gio::ActionGroup
    include Gio::RemoteActionGroup

    @pointer : Void*

    def initialize(pointer : LibGio::DBusActionGroup*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDBusActionGroup")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_dbus_action_group_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DBusActionGroup*)
    end

    def to_unsafe_dbusactiongroup
      @pointer.not_nil!.as(LibGio::DBusActionGroup*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_dbus_action_group_get_type, 0, nil, nil).as(Void*)
    end

    def self.get(connection : Gio::DBusConnection, bus_name : ::String?, object_path : ::String)
      __var0 = LibGio.d_bus_action_group_get(connection.to_unsafe_dbusconnection, bus_name ? bus_name.to_unsafe : Pointer(UInt8).null, object_path.to_unsafe)
      GObject.raise_unexpected_null("g_dbus_action_group_get") if __var0.null?
      Gio::DBusActionGroup.new(__var0)
    end
  end

  class RemoteActionGroupInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(32u64, 0u8).as(LibGio::RemoteActionGroupInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::RemoteActionGroupInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::RemoteActionGroupInterface*)
    end

    def to_unsafe_remoteactiongroupinterface
      @pointer.not_nil!.as(LibGio::RemoteActionGroupInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::RemoteActionGroupInterface*).value.g_iface)
    end

    def activate_action_full
      to_unsafe.as(LibGio::RemoteActionGroupInterface*).value.activate_action_full
    end

    def change_action_state_full
      to_unsafe.as(LibGio::RemoteActionGroupInterface*).value.change_action_state_full
    end
  end

  class Resolver < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Resolver*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GResolver")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_resolver_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Resolver*)
    end

    def to_unsafe_resolver
      @pointer.not_nil!.as(LibGio::Resolver*)
    end

    def self.default
      __var0 = LibGio.resolver_get_default
      GObject.raise_unexpected_null("g_resolver_get_default") if __var0.null?
      Gio::Resolver.new(__var0)
    end

    def lookup_by_address(address : Gio::InetAddress, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_address(@pointer.as(LibGio::Resolver*), address.to_unsafe_inetaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_address") if __var1.null?
      ::String.new(__var1)
    end

    def lookup_by_address_async(address : Gio::InetAddress, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.resolver_lookup_by_address_async(@pointer.as(LibGio::Resolver*), address.to_unsafe_inetaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_by_address_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_address_finish(@pointer.as(LibGio::Resolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_address_finish") if __var1.null?
      ::String.new(__var1)
    end

    def lookup_by_name(hostname : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_name(@pointer.as(LibGio::Resolver*), hostname.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_name") if __var1.null?
      GLib::ListIterator(Gio::InetAddress, LibGio::InetAddress*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_by_name_async(hostname : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.resolver_lookup_by_name_async(@pointer.as(LibGio::Resolver*), hostname.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_by_name_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_name_finish(@pointer.as(LibGio::Resolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_name_finish") if __var1.null?
      GLib::ListIterator(Gio::InetAddress, LibGio::InetAddress*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_by_name_with_flags(hostname : ::String, flags : Gio::ResolverNameLookupFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_name_with_flags(@pointer.as(LibGio::Resolver*), hostname.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_name_with_flags") if __var1.null?
      GLib::ListIterator(Gio::InetAddress, LibGio::InetAddress*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_by_name_with_flags_async(hostname : ::String, flags : Gio::ResolverNameLookupFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.resolver_lookup_by_name_with_flags_async(@pointer.as(LibGio::Resolver*), hostname.to_unsafe, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_by_name_with_flags_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_by_name_with_flags_finish(@pointer.as(LibGio::Resolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_by_name_with_flags_finish") if __var1.null?
      GLib::ListIterator(Gio::InetAddress, LibGio::InetAddress*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_records(rrname : ::String, record_type : Gio::ResolverRecordType, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_records(@pointer.as(LibGio::Resolver*), rrname.to_unsafe, record_type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_records") if __var1.null?
      GLib::ListIterator(GLib::Variant, LibGLib::Variant*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_records_async(rrname : ::String, record_type : Gio::ResolverRecordType, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.resolver_lookup_records_async(@pointer.as(LibGio::Resolver*), rrname.to_unsafe, record_type, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_records_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_records_finish(@pointer.as(LibGio::Resolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_records_finish") if __var1.null?
      GLib::ListIterator(GLib::Variant, LibGLib::Variant*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_service(service : ::String, protocol : ::String, domain : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_service(@pointer.as(LibGio::Resolver*), service.to_unsafe, protocol.to_unsafe, domain.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_service") if __var1.null?
      GLib::ListIterator(Gio::SrvTarget, LibGio::SrvTarget*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_service_async(service : ::String, protocol : ::String, domain : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.resolver_lookup_service_async(@pointer.as(LibGio::Resolver*), service.to_unsafe, protocol.to_unsafe, domain.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_service_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resolver_lookup_service_finish(@pointer.as(LibGio::Resolver*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resolver_lookup_service_finish") if __var1.null?
      GLib::ListIterator(Gio::SrvTarget, LibGio::SrvTarget*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def set_default
      LibGio.resolver_set_default(@pointer.as(LibGio::Resolver*))
      nil
    end

    alias ReloadSignal = Resolver -> Nil

    def on_reload(*, after = false, &block : ReloadSignal)
      __var0 = ->(arg0 : LibGio::Resolver*, box : Void*) {
        ::Box(ReloadSignal).unbox(box).call(Resolver.new(arg0))
      }

      __var1 = ::Box.box(ReloadSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "reload", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_reload(&block : ReloadSignal)
      on_reload(after: true, &block)
    end
  end

  class ResolverClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(264u64, 0u8).as(LibGio::ResolverClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ResolverClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ResolverClass*)
    end

    def to_unsafe_resolverclass
      @pointer.not_nil!.as(LibGio::ResolverClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ResolverClass*).value.parent_class)
    end

    def reload
      to_unsafe.as(LibGio::ResolverClass*).value.reload
    end

    def lookup_by_name
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name
    end

    def lookup_by_name_async
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name_async
    end

    def lookup_by_name_finish
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name_finish
    end

    def lookup_by_address
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_address
    end

    def lookup_by_address_async
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_address_async
    end

    def lookup_by_address_finish
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_address_finish
    end

    def lookup_service
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_service
    end

    def lookup_service_async
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_service_async
    end

    def lookup_service_finish
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_service_finish
    end

    def lookup_records
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_records
    end

    def lookup_records_async
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_records_async
    end

    def lookup_records_finish
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_records_finish
    end

    def lookup_by_name_with_flags_async
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name_with_flags_async
    end

    def lookup_by_name_with_flags_finish
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name_with_flags_finish
    end

    def lookup_by_name_with_flags
      to_unsafe.as(LibGio::ResolverClass*).value.lookup_by_name_with_flags
    end
  end

  enum ResolverError : UInt32
    NOT_FOUND         = 0
    TEMPORARY_FAILURE = 1
    INTERNAL          = 2
  end
  # Function quark

  @[Flags]
  enum ResolverNameLookupFlags : UInt32
    DEFAULT   = 0
    IPV4_ONLY = 1
    IPV6_ONLY = 2
  end

  class ResolverPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ResolverPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ResolverPrivate*)
    end

    def to_unsafe_resolverprivate
      @pointer.not_nil!.as(LibGio::ResolverPrivate*)
    end
  end

  enum ResolverRecordType : UInt32
    ZERO_NONE = 0
    SRV       = 1
    MX        = 2
    TXT       = 3
    SOA       = 4
    NS        = 5
  end

  class Resource
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::Resource*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Resource*)
    end

    def to_unsafe_resource
      @pointer.not_nil!.as(LibGio::Resource*)
    end

    def self.new_from_data(data : GLib::Bytes) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_new_from_data(data.to_unsafe.as(LibGLib::Bytes*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resource_new_from_data") if __var1.null?
      cast(Gio::Resource.new(__var1))
    end

    def register
      LibGio.resource_register(@pointer.as(LibGio::Resource*))
      nil
    end

    def unregister
      LibGio.resource_unregister(@pointer.as(LibGio::Resource*))
      nil
    end

    def enumerate_children(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_enumerate_children(@pointer.as(LibGio::Resource*), path.to_unsafe, lookup_flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resource_enumerate_children") if __var1.null?
      GObject::PointerIterator.new(__var1) { |__var2|
        ::String.new(__var2)
      }
    end

    def info(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_get_info(@pointer.as(LibGio::Resource*), path.to_unsafe, lookup_flags, out size, out flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), size, flags}
    end

    def lookup_data(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_lookup_data(@pointer.as(LibGio::Resource*), path.to_unsafe, lookup_flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resource_lookup_data") if __var1.null?
      GLib::Bytes.new(__var1)
    end

    def open_stream(path : ::String, lookup_flags : Gio::ResourceLookupFlags)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_open_stream(@pointer.as(LibGio::Resource*), path.to_unsafe, lookup_flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resource_open_stream") if __var1.null?
      Gio::InputStream.new(__var1)
    end

    def ref
      __var0 = LibGio.resource_ref(@pointer.as(LibGio::Resource*))
      GObject.raise_unexpected_null("g_resource_ref") if __var0.null?
      Gio::Resource.new(__var0)
    end

    def unref
      LibGio.resource_unref(@pointer.as(LibGio::Resource*))
      nil
    end

    def self.load(filename : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.resource_load(filename.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_resource_load") if __var1.null?
      Gio::Resource.new(__var1)
    end
  end

  enum ResourceError : UInt32
    NOT_FOUND = 0
    INTERNAL  = 1
  end
  # Function quark

  @[Flags]
  enum ResourceFlags : UInt32
    NONE       = 0
    COMPRESSED = 1
  end

  @[Flags]
  enum ResourceLookupFlags : UInt32
    NONE = 0
  end

  class DataInputStream < BufferedInputStream
    include Gio::Seekable

    @pointer : Void*

    def initialize(pointer : LibGio::DataInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GDataInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_data_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::DataInputStream*)
    end

    def to_unsafe_datainputstream
      @pointer.not_nil!.as(LibGio::DataInputStream*)
    end

    def initialize(*, base_stream : Gio::InputStream? = nil, buffer_size : UInt32? = nil, byte_order : Gio::DataStreamByteOrder? = nil, close_base_stream : ::Bool? = nil, newline_type : Gio::DataStreamNewlineType? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_stream.nil?
        __var0 << "base-stream".to_unsafe
        __var1 << base_stream.to_gvalue.to_unsafe.value
      end

      unless buffer_size.nil?
        __var0 << "buffer-size".to_unsafe
        __var1 << buffer_size.to_gvalue.to_unsafe.value
      end

      unless byte_order.nil?
        __var0 << "byte-order".to_unsafe
        __var1 << byte_order.to_gvalue.to_unsafe.value
      end

      unless close_base_stream.nil?
        __var0 << "close-base-stream".to_unsafe
        __var1 << close_base_stream.to_gvalue.to_unsafe.value
      end

      unless newline_type.nil?
        __var0 << "newline-type".to_unsafe
        __var1 << newline_type.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_data_input_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_stream : Gio::InputStream) : self
      __var0 = LibGio.data_input_stream_new(base_stream.to_unsafe_inputstream)
      GObject.raise_unexpected_null("g_data_input_stream_new") if __var0.null?
      cast(Gio::DataInputStream.new(__var0))
    end

    def byte_order
      __var0 = LibGio.data_input_stream_get_byte_order(@pointer.as(LibGio::DataInputStream*))
      Gio::DataStreamByteOrder.new(__var0)
    end

    def newline_type
      __var0 = LibGio.data_input_stream_get_newline_type(@pointer.as(LibGio::DataInputStream*))
      Gio::DataStreamNewlineType.new(__var0)
    end

    def read_byte(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_byte(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_int16(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_int16(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_int32(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_int32(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_int64(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_int64(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_line(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_line(@pointer.as(LibGio::DataInputStream*), out length, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var3 = GObject::PointerIterator.new(__var1) { |__var2|
        __var2
      } if __var1
      {__var3, length}
    end

    def read_line_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.data_input_stream_read_line_async(@pointer.as(LibGio::DataInputStream*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def read_line_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_line_finish(@pointer.as(LibGio::DataInputStream*), result.to_unsafe_asyncresult, out length, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var3 = GObject::PointerIterator.new(__var1) { |__var2|
        __var2
      } if __var1
      {__var3, length}
    end

    def read_line_finish_utf8(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_line_finish_utf8(@pointer.as(LibGio::DataInputStream*), result.to_unsafe_asyncresult, out length, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var2 = ::String.new(__var1) if __var1
      {__var2, length}
    end

    def read_line_utf8(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_line_utf8(@pointer.as(LibGio::DataInputStream*), out length, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var2 = ::String.new(__var1) if __var1
      {__var2, length}
    end

    def read_uint16(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_uint16(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_uint32(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_uint32(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_uint64(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_uint64(@pointer.as(LibGio::DataInputStream*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def read_until(stop_chars : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_until(@pointer.as(LibGio::DataInputStream*), stop_chars.to_unsafe, out length, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_data_input_stream_read_until") if __var1.null?
      {::String.new(__var1), length}
    end

    def read_until_async(stop_chars : ::String, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.data_input_stream_read_until_async(@pointer.as(LibGio::DataInputStream*), stop_chars.to_unsafe, Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def read_until_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_until_finish(@pointer.as(LibGio::DataInputStream*), result.to_unsafe_asyncresult, out length, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_data_input_stream_read_until_finish") if __var1.null?
      {::String.new(__var1), length}
    end

    def read_upto(stop_chars : ::String, stop_chars_len : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_upto(@pointer.as(LibGio::DataInputStream*), stop_chars.to_unsafe, Int64.new(stop_chars_len), out length, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_data_input_stream_read_upto") if __var1.null?
      {::String.new(__var1), length}
    end

    def read_upto_async(stop_chars : ::String, stop_chars_len : ::Int, io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.data_input_stream_read_upto_async(@pointer.as(LibGio::DataInputStream*), stop_chars.to_unsafe, Int64.new(stop_chars_len), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def read_upto_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.data_input_stream_read_upto_finish(@pointer.as(LibGio::DataInputStream*), result.to_unsafe_asyncresult, out length, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_data_input_stream_read_upto_finish") if __var1.null?
      {::String.new(__var1), length}
    end

    def byte_order=(order : Gio::DataStreamByteOrder)
      LibGio.data_input_stream_set_byte_order(@pointer.as(LibGio::DataInputStream*), order)
      nil
    end

    def newline_type=(type : Gio::DataStreamNewlineType)
      LibGio.data_input_stream_set_newline_type(@pointer.as(LibGio::DataInputStream*), type)
      nil
    end
  end

  class SeekableIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(56u64, 0u8).as(LibGio::SeekableIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SeekableIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SeekableIface*)
    end

    def to_unsafe_seekableiface
      @pointer.not_nil!.as(LibGio::SeekableIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::SeekableIface*).value.g_iface)
    end

    def tell
      to_unsafe.as(LibGio::SeekableIface*).value.tell
    end

    def can_seek
      to_unsafe.as(LibGio::SeekableIface*).value.can_seek
    end

    def seek
      to_unsafe.as(LibGio::SeekableIface*).value.seek
    end

    def can_truncate
      to_unsafe.as(LibGio::SeekableIface*).value.can_truncate
    end

    def truncate_fn
      to_unsafe.as(LibGio::SeekableIface*).value.truncate_fn
    end
  end

  class Settings < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Settings*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSettings")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_settings_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Settings*)
    end

    def to_unsafe_settings
      @pointer.not_nil!.as(LibGio::Settings*)
    end

    def initialize(*, backend : Gio::SettingsBackend? = nil, path : ::String? = nil, schema : ::String? = nil, schema_id : ::String? = nil, settings_schema : Gio::SettingsSchema? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless backend.nil?
        __var0 << "backend".to_unsafe
        __var1 << backend.to_gvalue.to_unsafe.value
      end

      unless path.nil?
        __var0 << "path".to_unsafe
        __var1 << path.to_gvalue.to_unsafe.value
      end

      unless schema.nil?
        __var0 << "schema".to_unsafe
        __var1 << schema.to_gvalue.to_unsafe.value
      end

      unless schema_id.nil?
        __var0 << "schema-id".to_unsafe
        __var1 << schema_id.to_gvalue.to_unsafe.value
      end

      unless settings_schema.nil?
        __var0 << "settings-schema".to_unsafe
        __var1 << settings_schema.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_settings_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(schema_id : ::String) : self
      __var0 = LibGio.settings_new(schema_id.to_unsafe)
      GObject.raise_unexpected_null("g_settings_new") if __var0.null?
      cast(Gio::Settings.new(__var0))
    end

    def self.new_full(schema : Gio::SettingsSchema, backend : Gio::SettingsBackend?, path : ::String?) : self
      __var0 = LibGio.settings_new_full(schema.to_unsafe.as(LibGio::SettingsSchema*), backend ? backend.to_unsafe_settingsbackend : Pointer(LibGio::SettingsBackend).null, path ? path.to_unsafe : Pointer(UInt8).null)
      GObject.raise_unexpected_null("g_settings_new_full") if __var0.null?
      cast(Gio::Settings.new(__var0))
    end

    def self.new_with_backend(schema_id : ::String, backend : Gio::SettingsBackend) : self
      __var0 = LibGio.settings_new_with_backend(schema_id.to_unsafe, backend.to_unsafe_settingsbackend)
      GObject.raise_unexpected_null("g_settings_new_with_backend") if __var0.null?
      cast(Gio::Settings.new(__var0))
    end

    def self.new_with_backend_and_path(schema_id : ::String, backend : Gio::SettingsBackend, path : ::String) : self
      __var0 = LibGio.settings_new_with_backend_and_path(schema_id.to_unsafe, backend.to_unsafe_settingsbackend, path.to_unsafe)
      GObject.raise_unexpected_null("g_settings_new_with_backend_and_path") if __var0.null?
      cast(Gio::Settings.new(__var0))
    end

    def self.new_with_path(schema_id : ::String, path : ::String) : self
      __var0 = LibGio.settings_new_with_path(schema_id.to_unsafe, path.to_unsafe)
      GObject.raise_unexpected_null("g_settings_new_with_path") if __var0.null?
      cast(Gio::Settings.new(__var0))
    end

    def self.list_relocatable_schemas
      __var0 = LibGio.settings_list_relocatable_schemas
      GObject.raise_unexpected_null("g_settings_list_relocatable_schemas") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def self.list_schemas
      __var0 = LibGio.settings_list_schemas
      GObject.raise_unexpected_null("g_settings_list_schemas") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def self.sync
      LibGio.settings_sync
      nil
    end

    def self.unbind(object : GObject::Object, property : ::String)
      LibGio.settings_unbind(object.to_unsafe_object, property.to_unsafe)
      nil
    end

    def apply
      LibGio.settings_apply(@pointer.as(LibGio::Settings*))
      nil
    end

    def bind(key : ::String, object : GObject::Object, property : ::String, flags : Gio::SettingsBindFlags)
      LibGio.settings_bind(@pointer.as(LibGio::Settings*), key.to_unsafe, object.to_unsafe_object, property.to_unsafe, flags)
      nil
    end

    def bind_writable(key : ::String, object : GObject::Object, property : ::String, inverted : ::Bool)
      LibGio.settings_bind_writable(@pointer.as(LibGio::Settings*), key.to_unsafe, object.to_unsafe_object, property.to_unsafe, LibC::Int.new(inverted ? 1 : 0))
      nil
    end

    def create_action(key : ::String)
      __var0 = LibGio.settings_create_action(@pointer.as(LibGio::Settings*), key.to_unsafe)
      GObject.raise_unexpected_null("g_settings_create_action") if __var0.null?
      Gio::Action::Wrapper.new(__var0)
    end

    def delay
      LibGio.settings_delay(@pointer.as(LibGio::Settings*))
      nil
    end

    def boolean(key : ::String)
      __var0 = LibGio.settings_get_boolean(@pointer.as(LibGio::Settings*), key.to_unsafe)
      (__var0 == 1)
    end

    def child(name : ::String)
      __var0 = LibGio.settings_get_child(@pointer.as(LibGio::Settings*), name.to_unsafe)
      GObject.raise_unexpected_null("g_settings_get_child") if __var0.null?
      Gio::Settings.new(__var0)
    end

    def default_value(key : ::String)
      __var0 = LibGio.settings_get_default_value(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def double(key : ::String)
      __var0 = LibGio.settings_get_double(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def enum(key : ::String)
      __var0 = LibGio.settings_get_enum(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def flags(key : ::String)
      __var0 = LibGio.settings_get_flags(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def has_unapplied
      __var0 = LibGio.settings_get_has_unapplied(@pointer.as(LibGio::Settings*))
      (__var0 == 1)
    end

    def int(key : ::String)
      __var0 = LibGio.settings_get_int(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def int64(key : ::String)
      __var0 = LibGio.settings_get_int64(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def mapped(key : ::String, mapping : Gio::SettingsGetMapping, user_data : Void*?)
      LibGio.settings_get_mapped(@pointer.as(LibGio::Settings*), key.to_unsafe, mapping, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def range(key : ::String)
      __var0 = LibGio.settings_get_range(@pointer.as(LibGio::Settings*), key.to_unsafe)
      GObject.raise_unexpected_null("g_settings_get_range") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def string(key : ::String)
      __var0 = LibGio.settings_get_string(@pointer.as(LibGio::Settings*), key.to_unsafe)
      GObject.raise_unexpected_null("g_settings_get_string") if __var0.null?
      ::String.new(__var0)
    end

    def strv(key : ::String)
      __var0 = LibGio.settings_get_strv(@pointer.as(LibGio::Settings*), key.to_unsafe)
      GObject.raise_unexpected_null("g_settings_get_strv") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def uint(key : ::String)
      __var0 = LibGio.settings_get_uint(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def uint64(key : ::String)
      __var0 = LibGio.settings_get_uint64(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var0
    end

    def user_value(key : ::String)
      __var0 = LibGio.settings_get_user_value(@pointer.as(LibGio::Settings*), key.to_unsafe)
      __var1 = GLib::Variant.new(__var0) if __var0
      __var1
    end

    def value(key : ::String)
      __var0 = LibGio.settings_get_value(@pointer.as(LibGio::Settings*), key.to_unsafe)
      GObject.raise_unexpected_null("g_settings_get_value") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def writable?(name : ::String)
      __var0 = LibGio.settings_is_writable(@pointer.as(LibGio::Settings*), name.to_unsafe)
      (__var0 == 1)
    end

    def list_children
      __var0 = LibGio.settings_list_children(@pointer.as(LibGio::Settings*))
      GObject.raise_unexpected_null("g_settings_list_children") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def list_keys
      __var0 = LibGio.settings_list_keys(@pointer.as(LibGio::Settings*))
      GObject.raise_unexpected_null("g_settings_list_keys") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def range_check(key : ::String, value : GLib::Variant)
      __var0 = LibGio.settings_range_check(@pointer.as(LibGio::Settings*), key.to_unsafe, value.to_unsafe.as(LibGLib::Variant*))
      (__var0 == 1)
    end

    def reset(key : ::String)
      LibGio.settings_reset(@pointer.as(LibGio::Settings*), key.to_unsafe)
      nil
    end

    def revert
      LibGio.settings_revert(@pointer.as(LibGio::Settings*))
      nil
    end

    def set_boolean(key : ::String, value : ::Bool)
      __var0 = LibGio.settings_set_boolean(@pointer.as(LibGio::Settings*), key.to_unsafe, LibC::Int.new(value ? 1 : 0))
      (__var0 == 1)
    end

    def set_double(key : ::String, value : ::Float)
      __var0 = LibGio.settings_set_double(@pointer.as(LibGio::Settings*), key.to_unsafe, Float64.new(value))
      (__var0 == 1)
    end

    def set_enum(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_enum(@pointer.as(LibGio::Settings*), key.to_unsafe, Int32.new(value))
      (__var0 == 1)
    end

    def set_flags(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_flags(@pointer.as(LibGio::Settings*), key.to_unsafe, UInt32.new(value))
      (__var0 == 1)
    end

    def set_int(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_int(@pointer.as(LibGio::Settings*), key.to_unsafe, Int32.new(value))
      (__var0 == 1)
    end

    def set_int64(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_int64(@pointer.as(LibGio::Settings*), key.to_unsafe, Int64.new(value))
      (__var0 == 1)
    end

    def set_string(key : ::String, value : ::String)
      __var0 = LibGio.settings_set_string(@pointer.as(LibGio::Settings*), key.to_unsafe, value.to_unsafe)
      (__var0 == 1)
    end

    def set_strv(key : ::String, value : ::Enumerable?)
      __var0 = LibGio.settings_set_strv(@pointer.as(LibGio::Settings*), key.to_unsafe, value ? (__value_ary = value.map { |__item| __item.to_unsafe }.to_a).to_unsafe : Pointer(Pointer(UInt8)).null)
      (__var0 == 1)
    end

    def set_uint(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_uint(@pointer.as(LibGio::Settings*), key.to_unsafe, UInt32.new(value))
      (__var0 == 1)
    end

    def set_uint64(key : ::String, value : ::Int)
      __var0 = LibGio.settings_set_uint64(@pointer.as(LibGio::Settings*), key.to_unsafe, UInt64.new(value))
      (__var0 == 1)
    end

    def set_value(key : ::String, value : GLib::Variant)
      __var0 = LibGio.settings_set_value(@pointer.as(LibGio::Settings*), key.to_unsafe, value.to_unsafe.as(LibGLib::Variant*))
      (__var0 == 1)
    end

    def backend : Gio::SettingsBackend
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "backend", __var0)
      Gio::SettingsBackend.cast(__var0.object)
    end

    def delay_apply : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "delay-apply", __var0)
      __var0.boolean
    end

    def path : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "path", __var0)
      __var0.string
    end

    def schema : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "schema", __var0)
      __var0.string
    end

    def schema_id : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "schema-id", __var0)
      __var0.string
    end

    def settings_schema : Gio::SettingsSchema
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "settings-schema", __var0)
      Gio::SettingsSchema.cast(__var0.object)
    end

    alias ChangeEventSignal = Settings, ::Enumerable(UInt32)?, Int32 -> ::Bool

    def on_change_event(*, after = false, &block : ChangeEventSignal)
      __var0 = ->(arg0 : LibGio::Settings*, arg1 : Pointer(UInt32), arg2 : Int32, box : Void*) {
        LibC::Int.new(::Box(ChangeEventSignal).unbox(box).call(Settings.new(arg0), GObject::PointerIterator.new(arg1) { |__var5|
          __var5
        }, arg2) ? 1 : 0)
      }

      __var1 = ::Box.box(ChangeEventSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "change-event", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_change_event(&block : ChangeEventSignal)
      on_change_event(after: true, &block)
    end

    alias ChangedSignal = Settings, ::String -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::Settings*, arg1 : Pointer(UInt8), box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(Settings.new(arg0), ::String.new(arg1))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end

    alias WritableChangeEventSignal = Settings, UInt32 -> ::Bool

    def on_writable_change_event(*, after = false, &block : WritableChangeEventSignal)
      __var0 = ->(arg0 : LibGio::Settings*, arg1 : UInt32, box : Void*) {
        LibC::Int.new(::Box(WritableChangeEventSignal).unbox(box).call(Settings.new(arg0), arg1) ? 1 : 0)
      }

      __var1 = ::Box.box(WritableChangeEventSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "writable-change-event", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_writable_change_event(&block : WritableChangeEventSignal)
      on_writable_change_event(after: true, &block)
    end

    alias WritableChangedSignal = Settings, ::String -> Nil

    def on_writable_changed(*, after = false, &block : WritableChangedSignal)
      __var0 = ->(arg0 : LibGio::Settings*, arg1 : Pointer(UInt8), box : Void*) {
        ::Box(WritableChangedSignal).unbox(box).call(Settings.new(arg0), ::String.new(arg1))
      }

      __var1 = ::Box.box(WritableChangedSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "writable-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_writable_changed(&block : WritableChangedSignal)
      on_writable_changed(after: true, &block)
    end
  end

  class SettingsBackend < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SettingsBackend*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSettingsBackend")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_settings_backend_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsBackend*)
    end

    def to_unsafe_settingsbackend
      @pointer.not_nil!.as(LibGio::SettingsBackend*)
    end

    def self.flatten_tree(tree : GLib::Tree, keys : ::Enumerable, values : ::Enumerable?)
      LibGio.settings_backend_flatten_tree(tree.to_unsafe.as(LibGLib::Tree*), out path, keys, values)
      ::String.new(path)
    end

    def self.default
      __var0 = LibGio.settings_backend_get_default
      GObject.raise_unexpected_null("g_settings_backend_get_default") if __var0.null?
      Gio::SettingsBackend.new(__var0)
    end

    def changed(key : ::String, origin_tag : Void*?)
      LibGio.settings_backend_changed(@pointer.as(LibGio::SettingsBackend*), key.to_unsafe, origin_tag ? origin_tag : Pointer(Void).null)
      nil
    end

    def changed_tree(tree : GLib::Tree, origin_tag : Void*?)
      LibGio.settings_backend_changed_tree(@pointer.as(LibGio::SettingsBackend*), tree.to_unsafe.as(LibGLib::Tree*), origin_tag ? origin_tag : Pointer(Void).null)
      nil
    end

    def keys_changed(path : ::String, items : ::Enumerable, origin_tag : Void*?)
      LibGio.settings_backend_keys_changed(@pointer.as(LibGio::SettingsBackend*), path.to_unsafe, (__items_ary = items.map { |__item| __item.to_unsafe }.to_a).to_unsafe, origin_tag ? origin_tag : Pointer(Void).null)
      nil
    end

    def path_changed(path : ::String, origin_tag : Void*?)
      LibGio.settings_backend_path_changed(@pointer.as(LibGio::SettingsBackend*), path.to_unsafe, origin_tag ? origin_tag : Pointer(Void).null)
      nil
    end

    def path_writable_changed(path : ::String)
      LibGio.settings_backend_path_writable_changed(@pointer.as(LibGio::SettingsBackend*), path.to_unsafe)
      nil
    end

    def writable_changed(key : ::String)
      LibGio.settings_backend_writable_changed(@pointer.as(LibGio::SettingsBackend*), key.to_unsafe)
      nil
    end
  end

  class SettingsBackendClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(400u64, 0u8).as(LibGio::SettingsBackendClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsBackendClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsBackendClass*)
    end

    def to_unsafe_settingsbackendclass
      @pointer.not_nil!.as(LibGio::SettingsBackendClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SettingsBackendClass*).value.parent_class)
    end

    def read
      to_unsafe.as(LibGio::SettingsBackendClass*).value.read
    end

    def get_writable
      to_unsafe.as(LibGio::SettingsBackendClass*).value.get_writable
    end

    def write
      to_unsafe.as(LibGio::SettingsBackendClass*).value.write
    end

    def write_tree
      to_unsafe.as(LibGio::SettingsBackendClass*).value.write_tree
    end

    def reset
      to_unsafe.as(LibGio::SettingsBackendClass*).value.reset
    end

    def subscribe
      to_unsafe.as(LibGio::SettingsBackendClass*).value.subscribe
    end

    def unsubscribe
      to_unsafe.as(LibGio::SettingsBackendClass*).value.unsubscribe
    end

    def sync
      to_unsafe.as(LibGio::SettingsBackendClass*).value.sync
    end

    def get_permission
      to_unsafe.as(LibGio::SettingsBackendClass*).value.get_permission
    end

    def read_user_value
      to_unsafe.as(LibGio::SettingsBackendClass*).value.read_user_value
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::SettingsBackendClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class SettingsBackendPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsBackendPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsBackendPrivate*)
    end

    def to_unsafe_settingsbackendprivate
      @pointer.not_nil!.as(LibGio::SettingsBackendPrivate*)
    end
  end

  @[Flags]
  enum SettingsBindFlags : UInt32
    DEFAULT        =  0
    GET            =  1
    SET            =  2
    NO_SENSITIVITY =  4
    GET_NO_CHANGES =  8
    INVERT_BOOLEAN = 16
  end
  alias SettingsBindGetMapping = LibGio::SettingsBindGetMapping
  alias SettingsBindSetMapping = LibGio::SettingsBindSetMapping

  class SettingsClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(328u64, 0u8).as(LibGio::SettingsClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsClass*)
    end

    def to_unsafe_settingsclass
      @pointer.not_nil!.as(LibGio::SettingsClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SettingsClass*).value.parent_class)
    end

    def writable_changed
      to_unsafe.as(LibGio::SettingsClass*).value.writable_changed
    end

    def changed
      to_unsafe.as(LibGio::SettingsClass*).value.changed
    end

    def writable_change_event
      to_unsafe.as(LibGio::SettingsClass*).value.writable_change_event
    end

    def change_event
      to_unsafe.as(LibGio::SettingsClass*).value.change_event
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::SettingsClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  alias SettingsGetMapping = LibGio::SettingsGetMapping

  class SettingsPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsPrivate*)
    end

    def to_unsafe_settingsprivate
      @pointer.not_nil!.as(LibGio::SettingsPrivate*)
    end
  end

  class SettingsSchema
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsSchema*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsSchema*)
    end

    def to_unsafe_settingsschema
      @pointer.not_nil!.as(LibGio::SettingsSchema*)
    end

    def id
      __var0 = LibGio.settings_schema_get_id(@pointer.as(LibGio::SettingsSchema*))
      GObject.raise_unexpected_null("g_settings_schema_get_id") if __var0.null?
      ::String.new(__var0)
    end

    def key(name : ::String)
      __var0 = LibGio.settings_schema_get_key(@pointer.as(LibGio::SettingsSchema*), name.to_unsafe)
      GObject.raise_unexpected_null("g_settings_schema_get_key") if __var0.null?
      Gio::SettingsSchemaKey.new(__var0)
    end

    def path
      __var0 = LibGio.settings_schema_get_path(@pointer.as(LibGio::SettingsSchema*))
      GObject.raise_unexpected_null("g_settings_schema_get_path") if __var0.null?
      ::String.new(__var0)
    end

    def has_key(name : ::String)
      __var0 = LibGio.settings_schema_has_key(@pointer.as(LibGio::SettingsSchema*), name.to_unsafe)
      (__var0 == 1)
    end

    def list_children
      __var0 = LibGio.settings_schema_list_children(@pointer.as(LibGio::SettingsSchema*))
      GObject.raise_unexpected_null("g_settings_schema_list_children") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def list_keys
      __var0 = LibGio.settings_schema_list_keys(@pointer.as(LibGio::SettingsSchema*))
      GObject.raise_unexpected_null("g_settings_schema_list_keys") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def ref
      __var0 = LibGio.settings_schema_ref(@pointer.as(LibGio::SettingsSchema*))
      GObject.raise_unexpected_null("g_settings_schema_ref") if __var0.null?
      Gio::SettingsSchema.new(__var0)
    end

    def unref
      LibGio.settings_schema_unref(@pointer.as(LibGio::SettingsSchema*))
      nil
    end
  end

  class SettingsSchemaKey
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsSchemaKey*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsSchemaKey*)
    end

    def to_unsafe_settingsschemakey
      @pointer.not_nil!.as(LibGio::SettingsSchemaKey*)
    end

    def default_value
      __var0 = LibGio.settings_schema_key_get_default_value(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_default_value") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def description
      __var0 = LibGio.settings_schema_key_get_description(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_description") if __var0.null?
      ::String.new(__var0)
    end

    def name
      __var0 = LibGio.settings_schema_key_get_name(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def range
      __var0 = LibGio.settings_schema_key_get_range(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_range") if __var0.null?
      GLib::Variant.new(__var0)
    end

    def summary
      __var0 = LibGio.settings_schema_key_get_summary(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_summary") if __var0.null?
      ::String.new(__var0)
    end

    def value_type
      __var0 = LibGio.settings_schema_key_get_value_type(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_get_value_type") if __var0.null?
      GLib::VariantType.new(__var0)
    end

    def range_check(value : GLib::Variant)
      __var0 = LibGio.settings_schema_key_range_check(@pointer.as(LibGio::SettingsSchemaKey*), value.to_unsafe.as(LibGLib::Variant*))
      (__var0 == 1)
    end

    def ref
      __var0 = LibGio.settings_schema_key_ref(@pointer.as(LibGio::SettingsSchemaKey*))
      GObject.raise_unexpected_null("g_settings_schema_key_ref") if __var0.null?
      Gio::SettingsSchemaKey.new(__var0)
    end

    def unref
      LibGio.settings_schema_key_unref(@pointer.as(LibGio::SettingsSchemaKey*))
      nil
    end
  end

  class SettingsSchemaSource
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SettingsSchemaSource*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SettingsSchemaSource*)
    end

    def to_unsafe_settingsschemasource
      @pointer.not_nil!.as(LibGio::SettingsSchemaSource*)
    end

    def self.new_from_directory(directory : ::String, parent : Gio::SettingsSchemaSource?, trusted : ::Bool) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.settings_schema_source_new_from_directory(directory.to_unsafe, parent ? parent.to_unsafe.as(LibGio::SettingsSchemaSource*) : Pointer(LibGio::SettingsSchemaSource).null, LibC::Int.new(trusted ? 1 : 0), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_settings_schema_source_new_from_directory") if __var1.null?
      cast(Gio::SettingsSchemaSource.new(__var1))
    end

    def list_schemas(recursive : ::Bool, non_relocatable : ::Enumerable, relocatable : ::Enumerable)
      LibGio.settings_schema_source_list_schemas(@pointer.as(LibGio::SettingsSchemaSource*), LibC::Int.new(recursive ? 1 : 0), non_relocatable, relocatable)
      nil
    end

    def lookup(schema_id : ::String, recursive : ::Bool)
      __var0 = LibGio.settings_schema_source_lookup(@pointer.as(LibGio::SettingsSchemaSource*), schema_id.to_unsafe, LibC::Int.new(recursive ? 1 : 0))
      __var1 = Gio::SettingsSchema.new(__var0) if __var0
      __var1
    end

    def ref
      __var0 = LibGio.settings_schema_source_ref(@pointer.as(LibGio::SettingsSchemaSource*))
      GObject.raise_unexpected_null("g_settings_schema_source_ref") if __var0.null?
      Gio::SettingsSchemaSource.new(__var0)
    end

    def unref
      LibGio.settings_schema_source_unref(@pointer.as(LibGio::SettingsSchemaSource*))
      nil
    end

    def self.default
      __var0 = LibGio.settings_schema_source_get_default
      __var1 = Gio::SettingsSchemaSource.new(__var0) if __var0
      __var1
    end
  end

  class SimpleAction < GObject::Object
    include Gio::Action

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleAction*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimpleAction")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_action_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleAction*)
    end

    def to_unsafe_simpleaction
      @pointer.not_nil!.as(LibGio::SimpleAction*)
    end

    def initialize(*, enabled : ::Bool? = nil, name : ::String? = nil, parameter_type : GLib::VariantType? = nil, state : GLib::Variant? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless enabled.nil?
        __var0 << "enabled".to_unsafe
        __var1 << enabled.to_gvalue.to_unsafe.value
      end

      unless name.nil?
        __var0 << "name".to_unsafe
        __var1 << name.to_gvalue.to_unsafe.value
      end

      unless parameter_type.nil?
        __var0 << "parameter-type".to_unsafe
        __var1 << parameter_type.to_gvalue.to_unsafe.value
      end

      unless state.nil?
        __var0 << "state".to_unsafe
        __var1 << state.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_simple_action_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(name : ::String, parameter_type : GLib::VariantType?) : self
      __var0 = LibGio.simple_action_new(name.to_unsafe, parameter_type ? parameter_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null)
      GObject.raise_unexpected_null("g_simple_action_new") if __var0.null?
      cast(Gio::SimpleAction.new(__var0))
    end

    def self.new_stateful(name : ::String, parameter_type : GLib::VariantType?, state : GLib::Variant) : self
      __var0 = LibGio.simple_action_new_stateful(name.to_unsafe, parameter_type ? parameter_type.to_unsafe.as(LibGLib::VariantType*) : Pointer(LibGLib::VariantType).null, state.to_unsafe.as(LibGLib::Variant*))
      GObject.raise_unexpected_null("g_simple_action_new_stateful") if __var0.null?
      cast(Gio::SimpleAction.new(__var0))
    end

    def enabled=(enabled : ::Bool)
      LibGio.simple_action_set_enabled(@pointer.as(LibGio::SimpleAction*), LibC::Int.new(enabled ? 1 : 0))
      nil
    end

    def state=(value : GLib::Variant)
      LibGio.simple_action_set_state(@pointer.as(LibGio::SimpleAction*), value.to_unsafe.as(LibGLib::Variant*))
      nil
    end

    def state_hint=(state_hint : GLib::Variant?)
      LibGio.simple_action_set_state_hint(@pointer.as(LibGio::SimpleAction*), state_hint ? state_hint.to_unsafe.as(LibGLib::Variant*) : Pointer(LibGLib::Variant).null)
      nil
    end

    def name : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "name", __var0)
      __var0.string
    end

    def parameter_type : GLib::VariantType
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "parameter-type", __var0)
      GLib::VariantType.cast(__var0.object)
    end

    def state_type : GLib::VariantType
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "state-type", __var0)
      GLib::VariantType.cast(__var0.object)
    end

    alias ActivateSignal = SimpleAction, GLib::Variant? -> Nil

    def on_activate(*, after = false, &block : ActivateSignal)
      __var0 = ->(arg0 : LibGio::SimpleAction*, arg1 : LibGLib::Variant*, box : Void*) {
        ::Box(ActivateSignal).unbox(box).call(SimpleAction.new(arg0), arg1.null? ? nil : GLib::Variant.new(arg1))
      }

      __var1 = ::Box.box(ActivateSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "activate", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_activate(&block : ActivateSignal)
      on_activate(after: true, &block)
    end

    alias ChangeStateSignal = SimpleAction, GLib::Variant? -> Nil

    def on_change_state(*, after = false, &block : ChangeStateSignal)
      __var0 = ->(arg0 : LibGio::SimpleAction*, arg1 : LibGLib::Variant*, box : Void*) {
        ::Box(ChangeStateSignal).unbox(box).call(SimpleAction.new(arg0), arg1.null? ? nil : GLib::Variant.new(arg1))
      }

      __var1 = ::Box.box(ChangeStateSignal.new { |arg0, arg1|
        block.call(arg0, arg1)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "change-state", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_change_state(&block : ChangeStateSignal)
      on_change_state(after: true, &block)
    end
  end

  class SimpleActionGroup < GObject::Object
    include Gio::ActionGroup
    include Gio::ActionMap

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleActionGroup*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimpleActionGroup")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_action_group_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleActionGroup*)
    end

    def to_unsafe_simpleactiongroup
      @pointer.not_nil!.as(LibGio::SimpleActionGroup*)
    end

    def self.new : self
      __var0 = LibGio.simple_action_group_new
      GObject.raise_unexpected_null("g_simple_action_group_new") if __var0.null?
      cast(Gio::SimpleActionGroup.new(__var0))
    end

    def add_entries(entries : ::Enumerable, user_data : Void*?)
      n_entries = entries.size
      __entries = (__entries_ary = entries.map { |__item| __item }.to_a).to_unsafe
      n_entries = __entries_ary.size
      LibGio.simple_action_group_add_entries(@pointer.as(LibGio::SimpleActionGroup*), __entries, Int32.new(n_entries), user_data ? user_data : Pointer(Void).null)
      nil
    end

    def insert(action : Gio::Action)
      LibGio.simple_action_group_insert(@pointer.as(LibGio::SimpleActionGroup*), action.to_unsafe_action)
      nil
    end

    def lookup(action_name : ::String)
      __var0 = LibGio.simple_action_group_lookup(@pointer.as(LibGio::SimpleActionGroup*), action_name.to_unsafe)
      GObject.raise_unexpected_null("g_simple_action_group_lookup") if __var0.null?
      Gio::Action::Wrapper.new(__var0)
    end

    def remove(action_name : ::String)
      LibGio.simple_action_group_remove(@pointer.as(LibGio::SimpleActionGroup*), action_name.to_unsafe)
      nil
    end
  end

  class SimpleActionGroupClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(232u64, 0u8).as(LibGio::SimpleActionGroupClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleActionGroupClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleActionGroupClass*)
    end

    def to_unsafe_simpleactiongroupclass
      @pointer.not_nil!.as(LibGio::SimpleActionGroupClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SimpleActionGroupClass*).value.parent_class)
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::SimpleActionGroupClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class SimpleActionGroupPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleActionGroupPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleActionGroupPrivate*)
    end

    def to_unsafe_simpleactiongroupprivate
      @pointer.not_nil!.as(LibGio::SimpleActionGroupPrivate*)
    end
  end

  class SimpleAsyncResult < GObject::Object
    include Gio::AsyncResult

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleAsyncResult*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimpleAsyncResult")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_async_result_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleAsyncResult*)
    end

    def to_unsafe_simpleasyncresult
      @pointer.not_nil!.as(LibGio::SimpleAsyncResult*)
    end

    def self.new(source_object : GObject::Object?, callback : Gio::AsyncReadyCallback?, user_data : Void*?, source_tag : Void*?) : self
      __var0 = LibGio.simple_async_result_new(source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null, source_tag ? source_tag : Pointer(Void).null)
      GObject.raise_unexpected_null("g_simple_async_result_new") if __var0.null?
      cast(Gio::SimpleAsyncResult.new(__var0))
    end

    def self.new_from_error(source_object : GObject::Object?, callback : Gio::AsyncReadyCallback?, user_data : Void*?, error : LibGLib::Error*) : self
      __var0 = LibGio.simple_async_result_new_from_error(source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null, error)
      GObject.raise_unexpected_null("g_simple_async_result_new_from_error") if __var0.null?
      cast(Gio::SimpleAsyncResult.new(__var0))
    end

    def self.valid?(result : Gio::AsyncResult, source : GObject::Object?, source_tag : Void*?)
      __var0 = LibGio.simple_async_result_is_valid(result.to_unsafe_asyncresult, source ? source.to_unsafe_object : Pointer(LibGObject::Object).null, source_tag ? source_tag : Pointer(Void).null)
      (__var0 == 1)
    end

    def complete
      LibGio.simple_async_result_complete(@pointer.as(LibGio::SimpleAsyncResult*))
      nil
    end

    def complete_in_idle
      LibGio.simple_async_result_complete_in_idle(@pointer.as(LibGio::SimpleAsyncResult*))
      nil
    end

    def op_res_gboolean
      __var0 = LibGio.simple_async_result_get_op_res_gboolean(@pointer.as(LibGio::SimpleAsyncResult*))
      (__var0 == 1)
    end

    def op_res_gssize
      __var0 = LibGio.simple_async_result_get_op_res_gssize(@pointer.as(LibGio::SimpleAsyncResult*))
      __var0
    end

    def propagate_error
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.simple_async_result_propagate_error(@pointer.as(LibGio::SimpleAsyncResult*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def check_cancellable=(check_cancellable : Gio::Cancellable?)
      LibGio.simple_async_result_set_check_cancellable(@pointer.as(LibGio::SimpleAsyncResult*), check_cancellable ? check_cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null)
      nil
    end

    def from_error=(error : LibGLib::Error*)
      LibGio.simple_async_result_set_from_error(@pointer.as(LibGio::SimpleAsyncResult*), error)
      nil
    end

    def handle_cancellation=(handle_cancellation : ::Bool)
      LibGio.simple_async_result_set_handle_cancellation(@pointer.as(LibGio::SimpleAsyncResult*), LibC::Int.new(handle_cancellation ? 1 : 0))
      nil
    end

    def op_res_gboolean=(op_res : ::Bool)
      LibGio.simple_async_result_set_op_res_gboolean(@pointer.as(LibGio::SimpleAsyncResult*), LibC::Int.new(op_res ? 1 : 0))
      nil
    end

    def op_res_gssize=(op_res : ::Int)
      LibGio.simple_async_result_set_op_res_gssize(@pointer.as(LibGio::SimpleAsyncResult*), Int64.new(op_res))
      nil
    end
  end

  class SimpleAsyncResultClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleAsyncResultClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleAsyncResultClass*)
    end

    def to_unsafe_simpleasyncresultclass
      @pointer.not_nil!.as(LibGio::SimpleAsyncResultClass*)
    end
  end

  alias SimpleAsyncThreadFunc = LibGio::SimpleAsyncThreadFunc

  class SimpleIOStream < IOStream
    @pointer : Void*

    def initialize(pointer : LibGio::SimpleIOStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimpleIOStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_io_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleIOStream*)
    end

    def to_unsafe_simpleiostream
      @pointer.not_nil!.as(LibGio::SimpleIOStream*)
    end

    def initialize(*, input_stream : Gio::InputStream? = nil, output_stream : Gio::OutputStream? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless input_stream.nil?
        __var0 << "input-stream".to_unsafe
        __var1 << input_stream.to_gvalue.to_unsafe.value
      end

      unless output_stream.nil?
        __var0 << "output-stream".to_unsafe
        __var1 << output_stream.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_simple_io_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(input_stream : Gio::InputStream, output_stream : Gio::OutputStream) : self
      __var0 = LibGio.simple_i_o_stream_new(input_stream.to_unsafe_inputstream, output_stream.to_unsafe_outputstream)
      GObject.raise_unexpected_null("g_simple_io_stream_new") if __var0.null?
      cast(Gio::IOStream.new(__var0))
    end

    def input_stream : Gio::InputStream
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "input-stream", __var0)
      Gio::InputStream.cast(__var0.object)
    end

    def output_stream : Gio::OutputStream
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "output-stream", __var0)
      Gio::OutputStream.cast(__var0.object)
    end
  end

  class SimplePermission < Permission
    @pointer : Void*

    def initialize(pointer : LibGio::SimplePermission*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimplePermission")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_permission_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimplePermission*)
    end

    def to_unsafe_simplepermission
      @pointer.not_nil!.as(LibGio::SimplePermission*)
    end

    def self.new(allowed : ::Bool) : self
      __var0 = LibGio.simple_permission_new(LibC::Int.new(allowed ? 1 : 0))
      GObject.raise_unexpected_null("g_simple_permission_new") if __var0.null?
      cast(Gio::Permission.new(__var0))
    end
  end

  class SimpleProxyResolver < GObject::Object
    include Gio::ProxyResolver

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleProxyResolver*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSimpleProxyResolver")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_simple_proxy_resolver_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleProxyResolver*)
    end

    def to_unsafe_simpleproxyresolver
      @pointer.not_nil!.as(LibGio::SimpleProxyResolver*)
    end

    def initialize(*, default_proxy : ::String? = nil, ignore_hosts : ::Enumerable(::String)? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless default_proxy.nil?
        __var0 << "default-proxy".to_unsafe
        __var1 << default_proxy.to_gvalue.to_unsafe.value
      end

      unless ignore_hosts.nil?
        __var0 << "ignore-hosts".to_unsafe
        __var1 << ignore_hosts.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_simple_proxy_resolver_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(default_proxy : ::String?, ignore_hosts : ::String?)
      __var0 = LibGio.simple_proxy_resolver_new(default_proxy ? default_proxy.to_unsafe : Pointer(UInt8).null, ignore_hosts ? ignore_hosts.to_unsafe : Pointer(UInt8).null)
      GObject.raise_unexpected_null("g_simple_proxy_resolver_new") if __var0.null?
      Gio::ProxyResolver::Wrapper.new(__var0)
    end

    def default_proxy=(default_proxy : ::String)
      LibGio.simple_proxy_resolver_set_default_proxy(@pointer.as(LibGio::SimpleProxyResolver*), default_proxy.to_unsafe)
      nil
    end

    def ignore_hosts=(ignore_hosts : ::String)
      LibGio.simple_proxy_resolver_set_ignore_hosts(@pointer.as(LibGio::SimpleProxyResolver*), ignore_hosts.to_unsafe)
      nil
    end

    def set_uri_proxy(uri_scheme : ::String, proxy : ::String)
      LibGio.simple_proxy_resolver_set_uri_proxy(@pointer.as(LibGio::SimpleProxyResolver*), uri_scheme.to_unsafe, proxy.to_unsafe)
      nil
    end
  end

  class SimpleProxyResolverClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(176u64, 0u8).as(LibGio::SimpleProxyResolverClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleProxyResolverClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleProxyResolverClass*)
    end

    def to_unsafe_simpleproxyresolverclass
      @pointer.not_nil!.as(LibGio::SimpleProxyResolverClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SimpleProxyResolverClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SimpleProxyResolverClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SimpleProxyResolverClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SimpleProxyResolverClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SimpleProxyResolverClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SimpleProxyResolverClass*).value._g_reserved5
    end
  end

  class SimpleProxyResolverPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SimpleProxyResolverPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SimpleProxyResolverPrivate*)
    end

    def to_unsafe_simpleproxyresolverprivate
      @pointer.not_nil!.as(LibGio::SimpleProxyResolverPrivate*)
    end
  end

  class Socket < GObject::Object
    include Gio::DatagramBased
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::Socket*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocket")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Socket*)
    end

    def to_unsafe_socket
      @pointer.not_nil!.as(LibGio::Socket*)
    end

    def initialize(*, blocking : ::Bool? = nil, broadcast : ::Bool? = nil, family : Gio::SocketFamily? = nil, fd : Int32? = nil, keepalive : ::Bool? = nil, listen_backlog : Int32? = nil, multicast_loopback : ::Bool? = nil, multicast_ttl : UInt32? = nil, protocol : Gio::SocketProtocol? = nil, timeout : UInt32? = nil, ttl : UInt32? = nil, type : Gio::SocketType? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless blocking.nil?
        __var0 << "blocking".to_unsafe
        __var1 << blocking.to_gvalue.to_unsafe.value
      end

      unless broadcast.nil?
        __var0 << "broadcast".to_unsafe
        __var1 << broadcast.to_gvalue.to_unsafe.value
      end

      unless family.nil?
        __var0 << "family".to_unsafe
        __var1 << family.to_gvalue.to_unsafe.value
      end

      unless fd.nil?
        __var0 << "fd".to_unsafe
        __var1 << fd.to_gvalue.to_unsafe.value
      end

      unless keepalive.nil?
        __var0 << "keepalive".to_unsafe
        __var1 << keepalive.to_gvalue.to_unsafe.value
      end

      unless listen_backlog.nil?
        __var0 << "listen-backlog".to_unsafe
        __var1 << listen_backlog.to_gvalue.to_unsafe.value
      end

      unless multicast_loopback.nil?
        __var0 << "multicast-loopback".to_unsafe
        __var1 << multicast_loopback.to_gvalue.to_unsafe.value
      end

      unless multicast_ttl.nil?
        __var0 << "multicast-ttl".to_unsafe
        __var1 << multicast_ttl.to_gvalue.to_unsafe.value
      end

      unless protocol.nil?
        __var0 << "protocol".to_unsafe
        __var1 << protocol.to_gvalue.to_unsafe.value
      end

      unless timeout.nil?
        __var0 << "timeout".to_unsafe
        __var1 << timeout.to_gvalue.to_unsafe.value
      end

      unless ttl.nil?
        __var0 << "ttl".to_unsafe
        __var1 << ttl.to_gvalue.to_unsafe.value
      end

      unless type.nil?
        __var0 << "type".to_unsafe
        __var1 << type.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_socket_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(family : Gio::SocketFamily, type : Gio::SocketType, protocol : Gio::SocketProtocol) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_new(family, type, protocol, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_new") if __var1.null?
      cast(Gio::Socket.new(__var1))
    end

    def self.new_from_fd(fd : ::Int) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_new_from_fd(Int32.new(fd), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_new_from_fd") if __var1.null?
      cast(Gio::Socket.new(__var1))
    end

    def accept(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_accept(@pointer.as(LibGio::Socket*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_accept") if __var1.null?
      Gio::Socket.new(__var1)
    end

    def bind(address : Gio::SocketAddress, allow_reuse : ::Bool)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_bind(@pointer.as(LibGio::Socket*), address.to_unsafe_socketaddress, LibC::Int.new(allow_reuse ? 1 : 0), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def check_connect_result
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_check_connect_result(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_close(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def condition_check(condition : GLib::IOCondition)
      __var0 = LibGio.socket_condition_check(@pointer.as(LibGio::Socket*), condition)
      GLib::IOCondition.new(__var0)
    end

    def condition_timed_wait(condition : GLib::IOCondition, timeout_us : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_condition_timed_wait(@pointer.as(LibGio::Socket*), condition, Int64.new(timeout_us), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def condition_wait(condition : GLib::IOCondition, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_condition_wait(@pointer.as(LibGio::Socket*), condition, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def connect(address : Gio::SocketAddress, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_connect(@pointer.as(LibGio::Socket*), address.to_unsafe_socketaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def connection_factory_create_connection
      __var0 = LibGio.socket_connection_factory_create_connection(@pointer.as(LibGio::Socket*))
      GObject.raise_unexpected_null("g_socket_connection_factory_create_connection") if __var0.null?
      Gio::SocketConnection.new(__var0)
    end

    def available_bytes
      __var0 = LibGio.socket_get_available_bytes(@pointer.as(LibGio::Socket*))
      __var0
    end

    def blocking
      __var0 = LibGio.socket_get_blocking(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def broadcast
      __var0 = LibGio.socket_get_broadcast(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def credentials
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_get_credentials(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_get_credentials") if __var1.null?
      Gio::Credentials.new(__var1)
    end

    def family
      __var0 = LibGio.socket_get_family(@pointer.as(LibGio::Socket*))
      Gio::SocketFamily.new(__var0)
    end

    def fd
      __var0 = LibGio.socket_get_fd(@pointer.as(LibGio::Socket*))
      __var0
    end

    def keepalive
      __var0 = LibGio.socket_get_keepalive(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def listen_backlog
      __var0 = LibGio.socket_get_listen_backlog(@pointer.as(LibGio::Socket*))
      __var0
    end

    def local_address
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_get_local_address(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_get_local_address") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end

    def multicast_loopback
      __var0 = LibGio.socket_get_multicast_loopback(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def multicast_ttl
      __var0 = LibGio.socket_get_multicast_ttl(@pointer.as(LibGio::Socket*))
      __var0
    end

    def option(level : ::Int, optname : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_get_option(@pointer.as(LibGio::Socket*), Int32.new(level), Int32.new(optname), out value, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), value}
    end

    def protocol
      __var0 = LibGio.socket_get_protocol(@pointer.as(LibGio::Socket*))
      Gio::SocketProtocol.new(__var0)
    end

    def remote_address
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_get_remote_address(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_get_remote_address") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end

    def socket_type
      __var0 = LibGio.socket_get_socket_type(@pointer.as(LibGio::Socket*))
      Gio::SocketType.new(__var0)
    end

    def timeout
      __var0 = LibGio.socket_get_timeout(@pointer.as(LibGio::Socket*))
      __var0
    end

    def ttl
      __var0 = LibGio.socket_get_ttl(@pointer.as(LibGio::Socket*))
      __var0
    end

    def closed?
      __var0 = LibGio.socket_is_closed(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def connected?
      __var0 = LibGio.socket_is_connected(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def join_multicast_group(group : Gio::InetAddress, source_specific : ::Bool, iface : ::String?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_join_multicast_group(@pointer.as(LibGio::Socket*), group.to_unsafe_inetaddress, LibC::Int.new(source_specific ? 1 : 0), iface ? iface.to_unsafe : Pointer(UInt8).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def join_multicast_group_ssm(group : Gio::InetAddress, source_specific : Gio::InetAddress?, iface : ::String?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_join_multicast_group_ssm(@pointer.as(LibGio::Socket*), group.to_unsafe_inetaddress, source_specific ? source_specific.to_unsafe_inetaddress : Pointer(LibGio::InetAddress).null, iface ? iface.to_unsafe : Pointer(UInt8).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def leave_multicast_group(group : Gio::InetAddress, source_specific : ::Bool, iface : ::String?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_leave_multicast_group(@pointer.as(LibGio::Socket*), group.to_unsafe_inetaddress, LibC::Int.new(source_specific ? 1 : 0), iface ? iface.to_unsafe : Pointer(UInt8).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def leave_multicast_group_ssm(group : Gio::InetAddress, source_specific : Gio::InetAddress?, iface : ::String?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_leave_multicast_group_ssm(@pointer.as(LibGio::Socket*), group.to_unsafe_inetaddress, source_specific ? source_specific.to_unsafe_inetaddress : Pointer(LibGio::InetAddress).null, iface ? iface.to_unsafe : Pointer(UInt8).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def listen
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listen(@pointer.as(LibGio::Socket*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def receive(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_receive(@pointer.as(LibGio::Socket*), buffer.to_unsafe, UInt64.new(size), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def receive_from(address : Gio::SocketAddress?, buffer : ::Bytes, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_receive_from(@pointer.as(LibGio::Socket*), address, buffer.to_unsafe, UInt64.new(size), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def receive_message(address : Gio::SocketAddress?, vectors : ::Enumerable, messages : ::Enumerable?, flags : ::Int, cancellable : Gio::Cancellable?)
      num_vectors = vectors.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_receive_message(@pointer.as(LibGio::Socket*), address, (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe, Int32.new(num_vectors), messages, out num_messages, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {__var1, num_messages}
    end

    def receive_messages(messages : ::Enumerable, flags : ::Int, cancellable : Gio::Cancellable?)
      num_messages = messages.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_receive_messages(@pointer.as(LibGio::Socket*), (__messages_ary = messages.map { |__item| __item }.to_a).to_unsafe, UInt32.new(num_messages), Int32.new(flags), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def receive_with_blocking(buffer : ::Bytes, blocking : ::Bool, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_receive_with_blocking(@pointer.as(LibGio::Socket*), buffer.to_unsafe, UInt64.new(size), LibC::Int.new(blocking ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send(buffer : ::Bytes, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send(@pointer.as(LibGio::Socket*), buffer.to_unsafe, UInt64.new(size), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_message(address : Gio::SocketAddress?, vectors : ::Enumerable, messages : ::Enumerable?, flags : ::Int, cancellable : Gio::Cancellable?)
      num_vectors = vectors.size
      num_messages = messages ? messages.size : 0
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send_message(@pointer.as(LibGio::Socket*), address ? address.to_unsafe_socketaddress : Pointer(LibGio::SocketAddress).null, (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe, Int32.new(num_vectors), messages ? (__messages_ary = messages.map { |__item| __item.to_unsafe_socketcontrolmessage }.to_a).to_unsafe : Pointer(Pointer(LibGio::SocketControlMessage)).null, Int32.new(num_messages), Int32.new(flags), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_message_with_timeout(address : Gio::SocketAddress?, vectors : ::Enumerable, messages : ::Enumerable?, flags : ::Int, timeout_us : ::Int, cancellable : Gio::Cancellable?)
      num_vectors = vectors.size
      num_messages = messages ? messages.size : 0
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send_message_with_timeout(@pointer.as(LibGio::Socket*), address ? address.to_unsafe_socketaddress : Pointer(LibGio::SocketAddress).null, (__vectors_ary = vectors.map { |__item| __item }.to_a).to_unsafe, Int32.new(num_vectors), messages ? (__messages_ary = messages.map { |__item| __item.to_unsafe_socketcontrolmessage }.to_a).to_unsafe : Pointer(Pointer(LibGio::SocketControlMessage)).null, Int32.new(num_messages), Int32.new(flags), Int64.new(timeout_us), out bytes_written, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      {Gio::PollableReturn.new(__var1), bytes_written}
    end

    def send_messages(messages : ::Enumerable, flags : ::Int, cancellable : Gio::Cancellable?)
      num_messages = messages.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send_messages(@pointer.as(LibGio::Socket*), (__messages_ary = messages.map { |__item| __item }.to_a).to_unsafe, UInt32.new(num_messages), Int32.new(flags), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_to(address : Gio::SocketAddress?, buffer : ::Bytes, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send_to(@pointer.as(LibGio::Socket*), address ? address.to_unsafe_socketaddress : Pointer(LibGio::SocketAddress).null, buffer.to_unsafe, UInt64.new(size), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_with_blocking(buffer : ::Bytes, blocking : ::Bool, cancellable : Gio::Cancellable?)
      size = buffer.size
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_send_with_blocking(@pointer.as(LibGio::Socket*), buffer.to_unsafe, UInt64.new(size), LibC::Int.new(blocking ? 1 : 0), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def blocking=(blocking : ::Bool)
      LibGio.socket_set_blocking(@pointer.as(LibGio::Socket*), LibC::Int.new(blocking ? 1 : 0))
      nil
    end

    def broadcast=(broadcast : ::Bool)
      LibGio.socket_set_broadcast(@pointer.as(LibGio::Socket*), LibC::Int.new(broadcast ? 1 : 0))
      nil
    end

    def keepalive=(keepalive : ::Bool)
      LibGio.socket_set_keepalive(@pointer.as(LibGio::Socket*), LibC::Int.new(keepalive ? 1 : 0))
      nil
    end

    def listen_backlog=(backlog : ::Int)
      LibGio.socket_set_listen_backlog(@pointer.as(LibGio::Socket*), Int32.new(backlog))
      nil
    end

    def multicast_loopback=(loopback : ::Bool)
      LibGio.socket_set_multicast_loopback(@pointer.as(LibGio::Socket*), LibC::Int.new(loopback ? 1 : 0))
      nil
    end

    def multicast_ttl=(ttl : ::Int)
      LibGio.socket_set_multicast_ttl(@pointer.as(LibGio::Socket*), UInt32.new(ttl))
      nil
    end

    def set_option(level : ::Int, optname : ::Int, value : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_set_option(@pointer.as(LibGio::Socket*), Int32.new(level), Int32.new(optname), Int32.new(value), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def timeout=(timeout : ::Int)
      LibGio.socket_set_timeout(@pointer.as(LibGio::Socket*), UInt32.new(timeout))
      nil
    end

    def ttl=(ttl : ::Int)
      LibGio.socket_set_ttl(@pointer.as(LibGio::Socket*), UInt32.new(ttl))
      nil
    end

    def shutdown(shutdown_read : ::Bool, shutdown_write : ::Bool)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_shutdown(@pointer.as(LibGio::Socket*), LibC::Int.new(shutdown_read ? 1 : 0), LibC::Int.new(shutdown_write ? 1 : 0), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def speaks_ipv4
      __var0 = LibGio.socket_speaks_ipv4(@pointer.as(LibGio::Socket*))
      (__var0 == 1)
    end

    def type : Gio::SocketType
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "type", __var0)
      Gio::SocketType.new(UInt32.new(__var0.enum))
    end
  end

  class ProxyAddress < InetSocketAddress
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GProxyAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_proxy_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddress*)
    end

    def to_unsafe_proxyaddress
      @pointer.not_nil!.as(LibGio::ProxyAddress*)
    end

    def initialize(*, address : Gio::InetAddress? = nil, destination_hostname : ::String? = nil, destination_port : UInt32? = nil, destination_protocol : ::String? = nil, flowinfo : UInt32? = nil, password : ::String? = nil, port : UInt32? = nil, protocol : ::String? = nil, scope_id : UInt32? = nil, uri : ::String? = nil, username : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless address.nil?
        __var0 << "address".to_unsafe
        __var1 << address.to_gvalue.to_unsafe.value
      end

      unless destination_hostname.nil?
        __var0 << "destination-hostname".to_unsafe
        __var1 << destination_hostname.to_gvalue.to_unsafe.value
      end

      unless destination_port.nil?
        __var0 << "destination-port".to_unsafe
        __var1 << destination_port.to_gvalue.to_unsafe.value
      end

      unless destination_protocol.nil?
        __var0 << "destination-protocol".to_unsafe
        __var1 << destination_protocol.to_gvalue.to_unsafe.value
      end

      unless flowinfo.nil?
        __var0 << "flowinfo".to_unsafe
        __var1 << flowinfo.to_gvalue.to_unsafe.value
      end

      unless password.nil?
        __var0 << "password".to_unsafe
        __var1 << password.to_gvalue.to_unsafe.value
      end

      unless port.nil?
        __var0 << "port".to_unsafe
        __var1 << port.to_gvalue.to_unsafe.value
      end

      unless protocol.nil?
        __var0 << "protocol".to_unsafe
        __var1 << protocol.to_gvalue.to_unsafe.value
      end

      unless scope_id.nil?
        __var0 << "scope-id".to_unsafe
        __var1 << scope_id.to_gvalue.to_unsafe.value
      end

      unless uri.nil?
        __var0 << "uri".to_unsafe
        __var1 << uri.to_gvalue.to_unsafe.value
      end

      unless username.nil?
        __var0 << "username".to_unsafe
        __var1 << username.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_proxy_address_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(inetaddr : Gio::InetAddress, port : ::Int, protocol : ::String, dest_hostname : ::String, dest_port : ::Int, username : ::String?, password : ::String?) : self
      __var0 = LibGio.proxy_address_new(inetaddr.to_unsafe_inetaddress, UInt16.new(port), protocol.to_unsafe, dest_hostname.to_unsafe, UInt16.new(dest_port), username ? username.to_unsafe : Pointer(UInt8).null, password ? password.to_unsafe : Pointer(UInt8).null)
      GObject.raise_unexpected_null("g_proxy_address_new") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def destination_hostname
      __var0 = LibGio.proxy_address_get_destination_hostname(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_destination_hostname") if __var0.null?
      ::String.new(__var0)
    end

    def destination_port
      __var0 = LibGio.proxy_address_get_destination_port(@pointer.as(LibGio::ProxyAddress*))
      __var0
    end

    def destination_protocol
      __var0 = LibGio.proxy_address_get_destination_protocol(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_destination_protocol") if __var0.null?
      ::String.new(__var0)
    end

    def password
      __var0 = LibGio.proxy_address_get_password(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_password") if __var0.null?
      ::String.new(__var0)
    end

    def protocol
      __var0 = LibGio.proxy_address_get_protocol(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_protocol") if __var0.null?
      ::String.new(__var0)
    end

    def uri
      __var0 = LibGio.proxy_address_get_uri(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_uri") if __var0.null?
      ::String.new(__var0)
    end

    def username
      __var0 = LibGio.proxy_address_get_username(@pointer.as(LibGio::ProxyAddress*))
      GObject.raise_unexpected_null("g_proxy_address_get_username") if __var0.null?
      ::String.new(__var0)
    end
  end

  class SocketAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::SocketAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketAddressClass*)
    end

    def to_unsafe_socketaddressclass
      @pointer.not_nil!.as(LibGio::SocketAddressClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketAddressClass*).value.parent_class)
    end

    def get_family
      to_unsafe.as(LibGio::SocketAddressClass*).value.get_family
    end

    def get_native_size
      to_unsafe.as(LibGio::SocketAddressClass*).value.get_native_size
    end

    def to_native
      to_unsafe.as(LibGio::SocketAddressClass*).value.to_native
    end
  end

  class ProxyAddressEnumerator < SocketAddressEnumerator
    @pointer : Void*

    def initialize(pointer : LibGio::ProxyAddressEnumerator*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GProxyAddressEnumerator")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_proxy_address_enumerator_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumerator*)
    end

    def to_unsafe_proxyaddressenumerator
      @pointer.not_nil!.as(LibGio::ProxyAddressEnumerator*)
    end

    def initialize(*, connectable : Gio::SocketConnectable? = nil, default_port : UInt32? = nil, proxy_resolver : Gio::ProxyResolver? = nil, uri : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless connectable.nil?
        __var0 << "connectable".to_unsafe
        __var1 << connectable.to_gvalue.to_unsafe.value
      end

      unless default_port.nil?
        __var0 << "default-port".to_unsafe
        __var1 << default_port.to_gvalue.to_unsafe.value
      end

      unless proxy_resolver.nil?
        __var0 << "proxy-resolver".to_unsafe
        __var1 << proxy_resolver.to_gvalue.to_unsafe.value
      end

      unless uri.nil?
        __var0 << "uri".to_unsafe
        __var1 << uri.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_proxy_address_enumerator_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def connectable : Gio::SocketConnectable
      __var0 = GObject::Value.new(type: GObject::Type::INTERFACE)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "connectable", __var0)
      Gio::SocketConnectable::Wrapper.cast(__var0.instance)
    end

    def default_port : UInt32
      __var0 = GObject::Value.new(type: GObject::Type::UINT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "default-port", __var0)
      __var0.uint
    end

    def proxy_resolver : Gio::ProxyResolver
      __var0 = GObject::Value.new(type: GObject::Type::INTERFACE)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "proxy-resolver", __var0)
      Gio::ProxyResolver::Wrapper.cast(__var0.instance)
    end

    def proxy_resolver=(value : Gio::ProxyResolver)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "proxy-resolver", value.to_gvalue)
    end

    def uri : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "uri", __var0)
      __var0.string
    end
  end

  class SocketAddressEnumeratorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::SocketAddressEnumeratorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketAddressEnumeratorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketAddressEnumeratorClass*)
    end

    def to_unsafe_socketaddressenumeratorclass
      @pointer.not_nil!.as(LibGio::SocketAddressEnumeratorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketAddressEnumeratorClass*).value.parent_class)
    end

    def next
      to_unsafe.as(LibGio::SocketAddressEnumeratorClass*).value._next
    end

    def next_async
      to_unsafe.as(LibGio::SocketAddressEnumeratorClass*).value.next_async
    end

    def next_finish
      to_unsafe.as(LibGio::SocketAddressEnumeratorClass*).value.next_finish
    end
  end

  class SocketClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(216u64, 0u8).as(LibGio::SocketClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketClass*)
    end

    def to_unsafe_socketclass
      @pointer.not_nil!.as(LibGio::SocketClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved6
    end

    def _g_reserved7
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved7
    end

    def _g_reserved8
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved8
    end

    def _g_reserved9
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved9
    end

    def _g_reserved10
      to_unsafe.as(LibGio::SocketClass*).value._g_reserved10
    end
  end

  class SocketClient < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SocketClient*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketClient")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_client_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketClient*)
    end

    def to_unsafe_socketclient
      @pointer.not_nil!.as(LibGio::SocketClient*)
    end

    def initialize(*, enable_proxy : ::Bool? = nil, family : Gio::SocketFamily? = nil, local_address : Gio::SocketAddress? = nil, protocol : Gio::SocketProtocol? = nil, proxy_resolver : Gio::ProxyResolver? = nil, timeout : UInt32? = nil, tls : ::Bool? = nil, tls_validation_flags : Gio::TlsCertificateFlags? = nil, type : Gio::SocketType? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless enable_proxy.nil?
        __var0 << "enable-proxy".to_unsafe
        __var1 << enable_proxy.to_gvalue.to_unsafe.value
      end

      unless family.nil?
        __var0 << "family".to_unsafe
        __var1 << family.to_gvalue.to_unsafe.value
      end

      unless local_address.nil?
        __var0 << "local-address".to_unsafe
        __var1 << local_address.to_gvalue.to_unsafe.value
      end

      unless protocol.nil?
        __var0 << "protocol".to_unsafe
        __var1 << protocol.to_gvalue.to_unsafe.value
      end

      unless proxy_resolver.nil?
        __var0 << "proxy-resolver".to_unsafe
        __var1 << proxy_resolver.to_gvalue.to_unsafe.value
      end

      unless timeout.nil?
        __var0 << "timeout".to_unsafe
        __var1 << timeout.to_gvalue.to_unsafe.value
      end

      unless tls.nil?
        __var0 << "tls".to_unsafe
        __var1 << tls.to_gvalue.to_unsafe.value
      end

      unless tls_validation_flags.nil?
        __var0 << "tls-validation-flags".to_unsafe
        __var1 << tls_validation_flags.to_gvalue.to_unsafe.value
      end

      unless type.nil?
        __var0 << "type".to_unsafe
        __var1 << type.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_socket_client_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.socket_client_new
      GObject.raise_unexpected_null("g_socket_client_new") if __var0.null?
      cast(Gio::SocketClient.new(__var0))
    end

    def add_application_proxy(protocol : ::String)
      LibGio.socket_client_add_application_proxy(@pointer.as(LibGio::SocketClient*), protocol.to_unsafe)
      nil
    end

    def connect(connectable : Gio::SocketConnectable, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect(@pointer.as(LibGio::SocketClient*), connectable.to_unsafe_socketconnectable, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_async(connectable : Gio::SocketConnectable, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_client_connect_async(@pointer.as(LibGio::SocketClient*), connectable.to_unsafe_socketconnectable, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_finish(@pointer.as(LibGio::SocketClient*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_finish") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_host(host_and_port : ::String, default_port : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_host(@pointer.as(LibGio::SocketClient*), host_and_port.to_unsafe, UInt16.new(default_port), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_host") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_host_async(host_and_port : ::String, default_port : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_client_connect_to_host_async(@pointer.as(LibGio::SocketClient*), host_and_port.to_unsafe, UInt16.new(default_port), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_to_host_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_host_finish(@pointer.as(LibGio::SocketClient*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_host_finish") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_service(domain : ::String, service : ::String, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_service(@pointer.as(LibGio::SocketClient*), domain.to_unsafe, service.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_service") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_service_async(domain : ::String, service : ::String, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_client_connect_to_service_async(@pointer.as(LibGio::SocketClient*), domain.to_unsafe, service.to_unsafe, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_to_service_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_service_finish(@pointer.as(LibGio::SocketClient*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_service_finish") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_uri(uri : ::String, default_port : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_uri(@pointer.as(LibGio::SocketClient*), uri.to_unsafe, UInt16.new(default_port), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_uri") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def connect_to_uri_async(uri : ::String, default_port : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_client_connect_to_uri_async(@pointer.as(LibGio::SocketClient*), uri.to_unsafe, UInt16.new(default_port), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_to_uri_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_client_connect_to_uri_finish(@pointer.as(LibGio::SocketClient*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_client_connect_to_uri_finish") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def enable_proxy
      __var0 = LibGio.socket_client_get_enable_proxy(@pointer.as(LibGio::SocketClient*))
      (__var0 == 1)
    end

    def family
      __var0 = LibGio.socket_client_get_family(@pointer.as(LibGio::SocketClient*))
      Gio::SocketFamily.new(__var0)
    end

    def local_address
      __var0 = LibGio.socket_client_get_local_address(@pointer.as(LibGio::SocketClient*))
      GObject.raise_unexpected_null("g_socket_client_get_local_address") if __var0.null?
      Gio::SocketAddress.new(__var0)
    end

    def protocol
      __var0 = LibGio.socket_client_get_protocol(@pointer.as(LibGio::SocketClient*))
      Gio::SocketProtocol.new(__var0)
    end

    def proxy_resolver
      __var0 = LibGio.socket_client_get_proxy_resolver(@pointer.as(LibGio::SocketClient*))
      GObject.raise_unexpected_null("g_socket_client_get_proxy_resolver") if __var0.null?
      Gio::ProxyResolver::Wrapper.new(__var0)
    end

    def socket_type
      __var0 = LibGio.socket_client_get_socket_type(@pointer.as(LibGio::SocketClient*))
      Gio::SocketType.new(__var0)
    end

    def timeout
      __var0 = LibGio.socket_client_get_timeout(@pointer.as(LibGio::SocketClient*))
      __var0
    end

    def tls
      __var0 = LibGio.socket_client_get_tls(@pointer.as(LibGio::SocketClient*))
      (__var0 == 1)
    end

    def tls_validation_flags
      __var0 = LibGio.socket_client_get_tls_validation_flags(@pointer.as(LibGio::SocketClient*))
      Gio::TlsCertificateFlags.new(__var0)
    end

    def enable_proxy=(enable : ::Bool)
      LibGio.socket_client_set_enable_proxy(@pointer.as(LibGio::SocketClient*), LibC::Int.new(enable ? 1 : 0))
      nil
    end

    def family=(family : Gio::SocketFamily)
      LibGio.socket_client_set_family(@pointer.as(LibGio::SocketClient*), family)
      nil
    end

    def local_address=(address : Gio::SocketAddress?)
      LibGio.socket_client_set_local_address(@pointer.as(LibGio::SocketClient*), address ? address.to_unsafe_socketaddress : Pointer(LibGio::SocketAddress).null)
      nil
    end

    def protocol=(protocol : Gio::SocketProtocol)
      LibGio.socket_client_set_protocol(@pointer.as(LibGio::SocketClient*), protocol)
      nil
    end

    def proxy_resolver=(proxy_resolver : Gio::ProxyResolver?)
      LibGio.socket_client_set_proxy_resolver(@pointer.as(LibGio::SocketClient*), proxy_resolver ? proxy_resolver.to_unsafe_proxyresolver : Pointer(LibGio::ProxyResolver).null)
      nil
    end

    def socket_type=(type : Gio::SocketType)
      LibGio.socket_client_set_socket_type(@pointer.as(LibGio::SocketClient*), type)
      nil
    end

    def timeout=(timeout : ::Int)
      LibGio.socket_client_set_timeout(@pointer.as(LibGio::SocketClient*), UInt32.new(timeout))
      nil
    end

    def tls=(tls : ::Bool)
      LibGio.socket_client_set_tls(@pointer.as(LibGio::SocketClient*), LibC::Int.new(tls ? 1 : 0))
      nil
    end

    def tls_validation_flags=(flags : Gio::TlsCertificateFlags)
      LibGio.socket_client_set_tls_validation_flags(@pointer.as(LibGio::SocketClient*), flags)
      nil
    end

    def type : Gio::SocketType
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "type", __var0)
      Gio::SocketType.new(UInt32.new(__var0.enum))
    end

    def type=(value : Gio::SocketType)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "type", value.to_gvalue)
    end

    alias EventSignal = SocketClient, Gio::SocketClientEvent, Gio::SocketConnectable, Gio::IOStream? -> Nil

    def on_event(*, after = false, &block : EventSignal)
      __var0 = ->(arg0 : LibGio::SocketClient*, arg1 : LibGio::SocketClientEvent, arg2 : LibGio::SocketConnectable*, arg3 : LibGio::IOStream*, box : Void*) {
        ::Box(EventSignal).unbox(box).call(SocketClient.new(arg0), Gio::SocketClientEvent.new(arg1), arg2.null? ? GObject.raise_unexpected_null("connectable in event") : Gio::SocketConnectable::Wrapper.new(arg2), arg3.null? ? nil : Gio::IOStream.new(arg3))
      }

      __var1 = ::Box.box(EventSignal.new { |arg0, arg1, arg2, arg3|
        block.call(arg0, arg1, arg2, arg3)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "event", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_event(&block : EventSignal)
      on_event(after: true, &block)
    end
  end

  class SocketClientClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(176u64, 0u8).as(LibGio::SocketClientClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketClientClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketClientClass*)
    end

    def to_unsafe_socketclientclass
      @pointer.not_nil!.as(LibGio::SocketClientClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketClientClass*).value.parent_class)
    end

    def event
      to_unsafe.as(LibGio::SocketClientClass*).value.event
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SocketClientClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketClientClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketClientClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketClientClass*).value._g_reserved4
    end
  end

  enum SocketClientEvent : UInt32
    RESOLVING         = 0
    RESOLVED          = 1
    CONNECTING        = 2
    CONNECTED         = 3
    PROXY_NEGOTIATING = 4
    PROXY_NEGOTIATED  = 5
    TLS_HANDSHAKING   = 6
    TLS_HANDSHAKED    = 7
    COMPLETE          = 8
  end

  class SocketClientPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketClientPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketClientPrivate*)
    end

    def to_unsafe_socketclientprivate
      @pointer.not_nil!.as(LibGio::SocketClientPrivate*)
    end
  end

  class NativeSocketAddress < SocketAddress
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::NativeSocketAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GNativeSocketAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_native_socket_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NativeSocketAddress*)
    end

    def to_unsafe_nativesocketaddress
      @pointer.not_nil!.as(LibGio::NativeSocketAddress*)
    end

    def self.new(native : Void*?, len : ::Int) : self
      __var0 = LibGio.native_socket_address_new(native ? native : Pointer(Void).null, UInt64.new(len))
      GObject.raise_unexpected_null("g_native_socket_address_new") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end
  end

  class SocketConnectableIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::SocketConnectableIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketConnectableIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketConnectableIface*)
    end

    def to_unsafe_socketconnectableiface
      @pointer.not_nil!.as(LibGio::SocketConnectableIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::SocketConnectableIface*).value.g_iface)
    end

    def enumerate
      to_unsafe.as(LibGio::SocketConnectableIface*).value.enumerate
    end

    def proxy_enumerate
      to_unsafe.as(LibGio::SocketConnectableIface*).value.proxy_enumerate
    end

    def to_string
      to_unsafe.as(LibGio::SocketConnectableIface*).value.to_string
    end
  end

  class SocketConnection < IOStream
    @pointer : Void*

    def initialize(pointer : LibGio::SocketConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketConnection*)
    end

    def to_unsafe_socketconnection
      @pointer.not_nil!.as(LibGio::SocketConnection*)
    end

    def initialize(*, socket : Gio::Socket? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless socket.nil?
        __var0 << "socket".to_unsafe
        __var1 << socket.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_socket_connection_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.factory_lookup_type(family : Gio::SocketFamily, type : Gio::SocketType, protocol_id : ::Int)
      __var0 = LibGio.socket_connection_factory_lookup_type(family, type, Int32.new(protocol_id))
      __var0
    end

    def self.factory_register_type(g_type : UInt64, family : Gio::SocketFamily, type : Gio::SocketType, protocol : ::Int)
      LibGio.socket_connection_factory_register_type(UInt64.new(g_type), family, type, Int32.new(protocol))
      nil
    end

    def connect(address : Gio::SocketAddress, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_connection_connect(@pointer.as(LibGio::SocketConnection*), address.to_unsafe_socketaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def connect_async(address : Gio::SocketAddress, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_connection_connect_async(@pointer.as(LibGio::SocketConnection*), address.to_unsafe_socketaddress, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def connect_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_connection_connect_finish(@pointer.as(LibGio::SocketConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def local_address
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_connection_get_local_address(@pointer.as(LibGio::SocketConnection*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_connection_get_local_address") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end

    def remote_address
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_connection_get_remote_address(@pointer.as(LibGio::SocketConnection*), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_connection_get_remote_address") if __var1.null?
      Gio::SocketAddress.new(__var1)
    end

    def socket
      __var0 = LibGio.socket_connection_get_socket(@pointer.as(LibGio::SocketConnection*))
      GObject.raise_unexpected_null("g_socket_connection_get_socket") if __var0.null?
      Gio::Socket.new(__var0)
    end

    def connected?
      __var0 = LibGio.socket_connection_is_connected(@pointer.as(LibGio::SocketConnection*))
      (__var0 == 1)
    end
  end

  class SocketConnectionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(304u64, 0u8).as(LibGio::SocketConnectionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketConnectionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketConnectionClass*)
    end

    def to_unsafe_socketconnectionclass
      @pointer.not_nil!.as(LibGio::SocketConnectionClass*)
    end

    def parent_class
      Gio::IOStreamClass.new(to_unsafe.as(LibGio::SocketConnectionClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::SocketConnectionClass*).value._g_reserved6
    end
  end

  class SocketConnectionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketConnectionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketConnectionPrivate*)
    end

    def to_unsafe_socketconnectionprivate
      @pointer.not_nil!.as(LibGio::SocketConnectionPrivate*)
    end
  end

  class SocketControlMessage < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SocketControlMessage*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketControlMessage")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_control_message_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketControlMessage*)
    end

    def to_unsafe_socketcontrolmessage
      @pointer.not_nil!.as(LibGio::SocketControlMessage*)
    end

    def self.deserialize(level : ::Int, type : ::Int, data : ::Bytes)
      size = data.size
      __var0 = LibGio.socket_control_message_deserialize(Int32.new(level), Int32.new(type), UInt64.new(size), data.to_unsafe)
      GObject.raise_unexpected_null("g_socket_control_message_deserialize") if __var0.null?
      Gio::SocketControlMessage.new(__var0)
    end

    def level
      __var0 = LibGio.socket_control_message_get_level(@pointer.as(LibGio::SocketControlMessage*))
      __var0
    end

    def msg_type
      __var0 = LibGio.socket_control_message_get_msg_type(@pointer.as(LibGio::SocketControlMessage*))
      __var0
    end

    def size
      __var0 = LibGio.socket_control_message_get_size(@pointer.as(LibGio::SocketControlMessage*))
      __var0
    end

    def serialize(data : Void*)
      LibGio.socket_control_message_serialize(@pointer.as(LibGio::SocketControlMessage*), data)
      nil
    end
  end

  class SocketControlMessageClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(216u64, 0u8).as(LibGio::SocketControlMessageClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketControlMessageClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketControlMessageClass*)
    end

    def to_unsafe_socketcontrolmessageclass
      @pointer.not_nil!.as(LibGio::SocketControlMessageClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketControlMessageClass*).value.parent_class)
    end

    def get_size
      to_unsafe.as(LibGio::SocketControlMessageClass*).value.get_size
    end

    def get_level
      to_unsafe.as(LibGio::SocketControlMessageClass*).value.get_level
    end

    def get_type
      to_unsafe.as(LibGio::SocketControlMessageClass*).value.get_type
    end

    def serialize
      to_unsafe.as(LibGio::SocketControlMessageClass*).value.serialize
    end

    def deserialize
      to_unsafe.as(LibGio::SocketControlMessageClass*).value.deserialize
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SocketControlMessageClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketControlMessageClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketControlMessageClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketControlMessageClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SocketControlMessageClass*).value._g_reserved5
    end
  end

  class SocketControlMessagePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketControlMessagePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketControlMessagePrivate*)
    end

    def to_unsafe_socketcontrolmessageprivate
      @pointer.not_nil!.as(LibGio::SocketControlMessagePrivate*)
    end
  end

  enum SocketFamily : UInt32
    INVALID =  0
    UNIX    =  1
    IPV4    =  2
    IPV6    = 10
  end

  class SocketListener < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SocketListener*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketListener")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_listener_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketListener*)
    end

    def to_unsafe_socketlistener
      @pointer.not_nil!.as(LibGio::SocketListener*)
    end

    def initialize(*, listen_backlog : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless listen_backlog.nil?
        __var0 << "listen-backlog".to_unsafe
        __var1 << listen_backlog.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_socket_listener_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.socket_listener_new
      GObject.raise_unexpected_null("g_socket_listener_new") if __var0.null?
      cast(Gio::SocketListener.new(__var0))
    end

    def accept(source_object : GObject::Object?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_accept(@pointer.as(LibGio::SocketListener*), source_object, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_listener_accept") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def accept_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_listener_accept_async(@pointer.as(LibGio::SocketListener*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def accept_finish(result : Gio::AsyncResult, source_object : GObject::Object?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_accept_finish(@pointer.as(LibGio::SocketListener*), result.to_unsafe_asyncresult, source_object, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_listener_accept_finish") if __var1.null?
      Gio::SocketConnection.new(__var1)
    end

    def accept_socket(source_object : GObject::Object?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_accept_socket(@pointer.as(LibGio::SocketListener*), source_object, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_listener_accept_socket") if __var1.null?
      Gio::Socket.new(__var1)
    end

    def accept_socket_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.socket_listener_accept_socket_async(@pointer.as(LibGio::SocketListener*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def accept_socket_finish(result : Gio::AsyncResult, source_object : GObject::Object?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_accept_socket_finish(@pointer.as(LibGio::SocketListener*), result.to_unsafe_asyncresult, source_object, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_socket_listener_accept_socket_finish") if __var1.null?
      Gio::Socket.new(__var1)
    end

    def add_address(address : Gio::SocketAddress, type : Gio::SocketType, protocol : Gio::SocketProtocol, source_object : GObject::Object?, effective_address : Gio::SocketAddress?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_add_address(@pointer.as(LibGio::SocketListener*), address.to_unsafe_socketaddress, type, protocol, source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, effective_address, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def add_any_inet_port(source_object : GObject::Object?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_add_any_inet_port(@pointer.as(LibGio::SocketListener*), source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def add_inet_port(port : ::Int, source_object : GObject::Object?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_add_inet_port(@pointer.as(LibGio::SocketListener*), UInt16.new(port), source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def add_socket(socket : Gio::Socket, source_object : GObject::Object?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.socket_listener_add_socket(@pointer.as(LibGio::SocketListener*), socket.to_unsafe_socket, source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def close
      LibGio.socket_listener_close(@pointer.as(LibGio::SocketListener*))
      nil
    end

    def backlog=(listen_backlog : ::Int)
      LibGio.socket_listener_set_backlog(@pointer.as(LibGio::SocketListener*), Int32.new(listen_backlog))
      nil
    end

    def listen_backlog : Int32
      __var0 = GObject::Value.new(type: GObject::Type::INT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "listen-backlog", __var0)
      __var0.int
    end

    def listen_backlog=(value : Int32)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "listen-backlog", value.to_gvalue)
    end

    alias EventSignal = SocketListener, Gio::SocketListenerEvent, Gio::Socket -> Nil

    def on_event(*, after = false, &block : EventSignal)
      __var0 = ->(arg0 : LibGio::SocketListener*, arg1 : LibGio::SocketListenerEvent, arg2 : LibGio::Socket*, box : Void*) {
        ::Box(EventSignal).unbox(box).call(SocketListener.new(arg0), Gio::SocketListenerEvent.new(arg1), arg2.null? ? GObject.raise_unexpected_null("socket in event") : Gio::Socket.new(arg2))
      }

      __var1 = ::Box.box(EventSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "event", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_event(&block : EventSignal)
      on_event(after: true, &block)
    end
  end

  class SocketListenerClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(192u64, 0u8).as(LibGio::SocketListenerClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketListenerClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketListenerClass*)
    end

    def to_unsafe_socketlistenerclass
      @pointer.not_nil!.as(LibGio::SocketListenerClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::SocketListenerClass*).value.parent_class)
    end

    def changed
      to_unsafe.as(LibGio::SocketListenerClass*).value.changed
    end

    def event
      to_unsafe.as(LibGio::SocketListenerClass*).value.event
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketListenerClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketListenerClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketListenerClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SocketListenerClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::SocketListenerClass*).value._g_reserved6
    end
  end

  enum SocketListenerEvent : UInt32
    BINDING   = 0
    BOUND     = 1
    LISTENING = 2
    LISTENED  = 3
  end

  class SocketListenerPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketListenerPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketListenerPrivate*)
    end

    def to_unsafe_socketlistenerprivate
      @pointer.not_nil!.as(LibGio::SocketListenerPrivate*)
    end
  end

  @[Flags]
  enum SocketMsgFlags : UInt32
    NONE      = 0
    OOB       = 1
    PEEK      = 2
    DONTROUTE = 4
  end

  class SocketPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketPrivate*)
    end

    def to_unsafe_socketprivate
      @pointer.not_nil!.as(LibGio::SocketPrivate*)
    end
  end

  enum SocketProtocol : Int32
    UNKNOWN =  -1
    DEFAULT =   0
    TCP     =   6
    UDP     =  17
    SCTP    = 132
  end

  class SocketService < SocketListener
    @pointer : Void*

    def initialize(pointer : LibGio::SocketService*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSocketService")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_socket_service_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketService*)
    end

    def to_unsafe_socketservice
      @pointer.not_nil!.as(LibGio::SocketService*)
    end

    def initialize(*, active : ::Bool? = nil, listen_backlog : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless active.nil?
        __var0 << "active".to_unsafe
        __var1 << active.to_gvalue.to_unsafe.value
      end

      unless listen_backlog.nil?
        __var0 << "listen-backlog".to_unsafe
        __var1 << listen_backlog.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_socket_service_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.socket_service_new
      GObject.raise_unexpected_null("g_socket_service_new") if __var0.null?
      cast(Gio::SocketService.new(__var0))
    end

    def active?
      __var0 = LibGio.socket_service_is_active(@pointer.as(LibGio::SocketService*))
      (__var0 == 1)
    end

    def start
      LibGio.socket_service_start(@pointer.as(LibGio::SocketService*))
      nil
    end

    def stop
      LibGio.socket_service_stop(@pointer.as(LibGio::SocketService*))
      nil
    end

    def active : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "active", __var0)
      __var0.boolean
    end

    def active=(value : ::Bool)
      LibGObject.object_set_property(@pointer.as(LibGObject::Object*), "active", value.to_gvalue)
    end

    alias IncomingSignal = SocketService, Gio::SocketConnection, GObject::Object? -> ::Bool

    def on_incoming(*, after = false, &block : IncomingSignal)
      __var0 = ->(arg0 : LibGio::SocketService*, arg1 : LibGio::SocketConnection*, arg2 : LibGObject::Object*, box : Void*) {
        LibC::Int.new(::Box(IncomingSignal).unbox(box).call(SocketService.new(arg0), arg1.null? ? GObject.raise_unexpected_null("connection in incoming") : Gio::SocketConnection.new(arg1), arg2.null? ? nil : GObject::Object.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(IncomingSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "incoming", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_incoming(&block : IncomingSignal)
      on_incoming(after: true, &block)
    end
  end

  class SocketServiceClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(248u64, 0u8).as(LibGio::SocketServiceClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::SocketServiceClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketServiceClass*)
    end

    def to_unsafe_socketserviceclass
      @pointer.not_nil!.as(LibGio::SocketServiceClass*)
    end

    def parent_class
      Gio::SocketListenerClass.new(to_unsafe.as(LibGio::SocketServiceClass*).value.parent_class)
    end

    def incoming
      to_unsafe.as(LibGio::SocketServiceClass*).value.incoming
    end

    def _g_reserved1
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::SocketServiceClass*).value._g_reserved6
    end
  end

  class SocketServicePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SocketServicePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SocketServicePrivate*)
    end

    def to_unsafe_socketserviceprivate
      @pointer.not_nil!.as(LibGio::SocketServicePrivate*)
    end
  end

  alias SocketSourceFunc = LibGio::SocketSourceFunc

  enum SocketType : UInt32
    INVALID   = 0
    STREAM    = 1
    DATAGRAM  = 2
    SEQPACKET = 3
  end

  class SrvTarget
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::SrvTarget*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SrvTarget*)
    end

    def to_unsafe_srvtarget
      @pointer.not_nil!.as(LibGio::SrvTarget*)
    end

    def self.new(hostname : ::String, port : ::Int, priority : ::Int, weight : ::Int) : self
      __var0 = LibGio.srv_target_new(hostname.to_unsafe, UInt16.new(port), UInt16.new(priority), UInt16.new(weight))
      GObject.raise_unexpected_null("g_srv_target_new") if __var0.null?
      cast(Gio::SrvTarget.new(__var0))
    end

    def copy
      __var0 = LibGio.srv_target_copy(@pointer.as(LibGio::SrvTarget*))
      GObject.raise_unexpected_null("g_srv_target_copy") if __var0.null?
      Gio::SrvTarget.new(__var0)
    end

    def free
      LibGio.srv_target_free(@pointer.as(LibGio::SrvTarget*))
      nil
    end

    def hostname
      __var0 = LibGio.srv_target_get_hostname(@pointer.as(LibGio::SrvTarget*))
      GObject.raise_unexpected_null("g_srv_target_get_hostname") if __var0.null?
      ::String.new(__var0)
    end

    def port
      __var0 = LibGio.srv_target_get_port(@pointer.as(LibGio::SrvTarget*))
      __var0
    end

    def priority
      __var0 = LibGio.srv_target_get_priority(@pointer.as(LibGio::SrvTarget*))
      __var0
    end

    def weight
      __var0 = LibGio.srv_target_get_weight(@pointer.as(LibGio::SrvTarget*))
      __var0
    end
  end

  class StaticResource
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(40u64, 0u8).as(LibGio::StaticResource*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::StaticResource*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::StaticResource*)
    end

    def to_unsafe_staticresource
      @pointer.not_nil!.as(LibGio::StaticResource*)
    end

    def fini
      LibGio.static_resource_fini(@pointer.as(LibGio::StaticResource*))
      nil
    end

    def resource
      __var0 = LibGio.static_resource_get_resource(@pointer.as(LibGio::StaticResource*))
      GObject.raise_unexpected_null("g_static_resource_get_resource") if __var0.null?
      Gio::Resource.new(__var0)
    end

    def init
      LibGio.static_resource_init(@pointer.as(LibGio::StaticResource*))
      nil
    end

    def data
      to_unsafe.as(LibGio::StaticResource*).value.data
    end

    def data_len
      to_unsafe.as(LibGio::StaticResource*).value.data_len
    end

    def next
      Gio::StaticResource.new(to_unsafe.as(LibGio::StaticResource*).value._next)
    end

    def padding
      to_unsafe.as(LibGio::StaticResource*).value.padding
    end
  end

  class Subprocess < GObject::Object
    include Gio::Initable

    @pointer : Void*

    def initialize(pointer : LibGio::Subprocess*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSubprocess")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_subprocess_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Subprocess*)
    end

    def to_unsafe_subprocess
      @pointer.not_nil!.as(LibGio::Subprocess*)
    end

    def initialize(*, argv : ::Enumerable(::String)? = nil, flags : Gio::SubprocessFlags? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless argv.nil?
        __var0 << "argv".to_unsafe
        __var1 << argv.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_subprocess_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(argv : ::Enumerable, flags : Gio::SubprocessFlags) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_new((__argv_ary = argv.map { |__item| __item.to_unsafe }.to_a).to_unsafe, flags, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_subprocess_newv") if __var1.null?
      cast(Gio::Subprocess.new(__var1))
    end

    def communicate(stdin_buf : GLib::Bytes?, cancellable : Gio::Cancellable?, stdout_buf : GLib::Bytes?, stderr_buf : GLib::Bytes?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_communicate(@pointer.as(LibGio::Subprocess*), stdin_buf ? stdin_buf.to_unsafe.as(LibGLib::Bytes*) : Pointer(LibGLib::Bytes).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, stdout_buf, stderr_buf, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def communicate_async(stdin_buf : GLib::Bytes?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.subprocess_communicate_async(@pointer.as(LibGio::Subprocess*), stdin_buf ? stdin_buf.to_unsafe.as(LibGLib::Bytes*) : Pointer(LibGLib::Bytes).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def communicate_finish(result : Gio::AsyncResult, stdout_buf : GLib::Bytes?, stderr_buf : GLib::Bytes?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_communicate_finish(@pointer.as(LibGio::Subprocess*), result.to_unsafe_asyncresult, stdout_buf, stderr_buf, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def communicate_utf8(stdin_buf : ::String?, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_communicate_utf8(@pointer.as(LibGio::Subprocess*), stdin_buf ? stdin_buf.to_unsafe : Pointer(UInt8).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, out stdout_buf, out stderr_buf, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), ::String.new(stdout_buf), ::String.new(stderr_buf)}
    end

    def communicate_utf8_async(stdin_buf : ::String?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.subprocess_communicate_utf8_async(@pointer.as(LibGio::Subprocess*), stdin_buf ? stdin_buf.to_unsafe : Pointer(UInt8).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def communicate_utf8_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_communicate_utf8_finish(@pointer.as(LibGio::Subprocess*), result.to_unsafe_asyncresult, out stdout_buf, out stderr_buf, pointerof(__var0))
      GLib::Error.assert(__var0)
      {(__var1 == 1), ::String.new(stdout_buf), ::String.new(stderr_buf)}
    end

    def force_exit
      LibGio.subprocess_force_exit(@pointer.as(LibGio::Subprocess*))
      nil
    end

    def exit_status
      __var0 = LibGio.subprocess_get_exit_status(@pointer.as(LibGio::Subprocess*))
      __var0
    end

    def identifier
      __var0 = LibGio.subprocess_get_identifier(@pointer.as(LibGio::Subprocess*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def if_exited
      __var0 = LibGio.subprocess_get_if_exited(@pointer.as(LibGio::Subprocess*))
      (__var0 == 1)
    end

    def if_signaled
      __var0 = LibGio.subprocess_get_if_signaled(@pointer.as(LibGio::Subprocess*))
      (__var0 == 1)
    end

    def status
      __var0 = LibGio.subprocess_get_status(@pointer.as(LibGio::Subprocess*))
      __var0
    end

    def stderr_pipe
      __var0 = LibGio.subprocess_get_stderr_pipe(@pointer.as(LibGio::Subprocess*))
      GObject.raise_unexpected_null("g_subprocess_get_stderr_pipe") if __var0.null?
      Gio::InputStream.new(__var0)
    end

    def stdin_pipe
      __var0 = LibGio.subprocess_get_stdin_pipe(@pointer.as(LibGio::Subprocess*))
      GObject.raise_unexpected_null("g_subprocess_get_stdin_pipe") if __var0.null?
      Gio::OutputStream.new(__var0)
    end

    def stdout_pipe
      __var0 = LibGio.subprocess_get_stdout_pipe(@pointer.as(LibGio::Subprocess*))
      GObject.raise_unexpected_null("g_subprocess_get_stdout_pipe") if __var0.null?
      Gio::InputStream.new(__var0)
    end

    def successful
      __var0 = LibGio.subprocess_get_successful(@pointer.as(LibGio::Subprocess*))
      (__var0 == 1)
    end

    def term_sig
      __var0 = LibGio.subprocess_get_term_sig(@pointer.as(LibGio::Subprocess*))
      __var0
    end

    def send_signal(signal_num : ::Int)
      LibGio.subprocess_send_signal(@pointer.as(LibGio::Subprocess*), Int32.new(signal_num))
      nil
    end

    def wait(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_wait(@pointer.as(LibGio::Subprocess*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def wait_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.subprocess_wait_async(@pointer.as(LibGio::Subprocess*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def wait_check(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_wait_check(@pointer.as(LibGio::Subprocess*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def wait_check_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.subprocess_wait_check_async(@pointer.as(LibGio::Subprocess*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def wait_check_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_wait_check_finish(@pointer.as(LibGio::Subprocess*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def wait_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_wait_finish(@pointer.as(LibGio::Subprocess*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  @[Flags]
  enum SubprocessFlags : UInt32
    NONE           =   0
    STDIN_PIPE     =   1
    STDIN_INHERIT  =   2
    STDOUT_PIPE    =   4
    STDOUT_SILENCE =   8
    STDERR_PIPE    =  16
    STDERR_SILENCE =  32
    STDERR_MERGE   =  64
    INHERIT_FDS    = 128
  end

  class SubprocessLauncher < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::SubprocessLauncher*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GSubprocessLauncher")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_subprocess_launcher_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::SubprocessLauncher*)
    end

    def to_unsafe_subprocesslauncher
      @pointer.not_nil!.as(LibGio::SubprocessLauncher*)
    end

    def initialize(*, flags : Gio::SubprocessFlags? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_subprocess_launcher_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(flags : Gio::SubprocessFlags) : self
      __var0 = LibGio.subprocess_launcher_new(flags)
      GObject.raise_unexpected_null("g_subprocess_launcher_new") if __var0.null?
      cast(Gio::SubprocessLauncher.new(__var0))
    end

    def getenv(variable : ::String)
      __var0 = LibGio.subprocess_launcher_getenv(@pointer.as(LibGio::SubprocessLauncher*), variable.to_unsafe)
      GObject.raise_unexpected_null("g_subprocess_launcher_getenv") if __var0.null?
      ::String.new(__var0)
    end

    def cwd=(cwd : ::String)
      LibGio.subprocess_launcher_set_cwd(@pointer.as(LibGio::SubprocessLauncher*), cwd.to_unsafe)
      nil
    end

    def environ=(env : ::Enumerable)
      LibGio.subprocess_launcher_set_environ(@pointer.as(LibGio::SubprocessLauncher*), (__env_ary = env.map { |__item| __item.to_unsafe }.to_a).to_unsafe)
      nil
    end

    def flags=(flags : Gio::SubprocessFlags)
      LibGio.subprocess_launcher_set_flags(@pointer.as(LibGio::SubprocessLauncher*), flags)
      nil
    end

    def stderr_file_path=(path : ::String?)
      LibGio.subprocess_launcher_set_stderr_file_path(@pointer.as(LibGio::SubprocessLauncher*), path ? path.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def stdin_file_path=(path : ::String)
      LibGio.subprocess_launcher_set_stdin_file_path(@pointer.as(LibGio::SubprocessLauncher*), path.to_unsafe)
      nil
    end

    def stdout_file_path=(path : ::String?)
      LibGio.subprocess_launcher_set_stdout_file_path(@pointer.as(LibGio::SubprocessLauncher*), path ? path.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def setenv(variable : ::String, value : ::String, overwrite : ::Bool)
      LibGio.subprocess_launcher_setenv(@pointer.as(LibGio::SubprocessLauncher*), variable.to_unsafe, value.to_unsafe, LibC::Int.new(overwrite ? 1 : 0))
      nil
    end

    def spawnv(argv : ::Enumerable)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.subprocess_launcher_spawnv(@pointer.as(LibGio::SubprocessLauncher*), (__argv_ary = argv.map { |__item| __item.to_unsafe }.to_a).to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_subprocess_launcher_spawnv") if __var1.null?
      Gio::Subprocess.new(__var1)
    end

    def take_fd(source_fd : ::Int, target_fd : ::Int)
      LibGio.subprocess_launcher_take_fd(@pointer.as(LibGio::SubprocessLauncher*), Int32.new(source_fd), Int32.new(target_fd))
      nil
    end

    def take_stderr_fd(fd : ::Int)
      LibGio.subprocess_launcher_take_stderr_fd(@pointer.as(LibGio::SubprocessLauncher*), Int32.new(fd))
      nil
    end

    def take_stdin_fd(fd : ::Int)
      LibGio.subprocess_launcher_take_stdin_fd(@pointer.as(LibGio::SubprocessLauncher*), Int32.new(fd))
      nil
    end

    def take_stdout_fd(fd : ::Int)
      LibGio.subprocess_launcher_take_stdout_fd(@pointer.as(LibGio::SubprocessLauncher*), Int32.new(fd))
      nil
    end

    def unsetenv(variable : ::String)
      LibGio.subprocess_launcher_unsetenv(@pointer.as(LibGio::SubprocessLauncher*), variable.to_unsafe)
      nil
    end
  end

  class Task < GObject::Object
    include Gio::AsyncResult

    @pointer : Void*

    def initialize(pointer : LibGio::Task*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTask")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_task_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Task*)
    end

    def to_unsafe_task
      @pointer.not_nil!.as(LibGio::Task*)
    end

    def self.new(source_object : GObject::Object?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, callback_data : Void*?) : self
      __var0 = LibGio.task_new(source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, callback_data ? callback_data : Pointer(Void).null)
      GObject.raise_unexpected_null("g_task_new") if __var0.null?
      cast(Gio::Task.new(__var0))
    end

    def self.valid?(result : Gio::AsyncResult, source_object : GObject::Object?)
      __var0 = LibGio.task_is_valid(result.to_unsafe_asyncresult, source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null)
      (__var0 == 1)
    end

    def self.report_error(source_object : GObject::Object?, callback : Gio::AsyncReadyCallback?, callback_data : Void*?, source_tag : Void*?, error : LibGLib::Error*)
      LibGio.task_report_error(source_object ? source_object.to_unsafe_object : Pointer(LibGObject::Object).null, callback ? callback : nil, callback_data ? callback_data : Pointer(Void).null, source_tag ? source_tag : Pointer(Void).null, error)
      nil
    end

    def cancellable
      __var0 = LibGio.task_get_cancellable(@pointer.as(LibGio::Task*))
      GObject.raise_unexpected_null("g_task_get_cancellable") if __var0.null?
      Gio::Cancellable.new(__var0)
    end

    def check_cancellable
      __var0 = LibGio.task_get_check_cancellable(@pointer.as(LibGio::Task*))
      (__var0 == 1)
    end

    def completed
      __var0 = LibGio.task_get_completed(@pointer.as(LibGio::Task*))
      (__var0 == 1)
    end

    def context
      __var0 = LibGio.task_get_context(@pointer.as(LibGio::Task*))
      GObject.raise_unexpected_null("g_task_get_context") if __var0.null?
      GLib::MainContext.new(__var0)
    end

    def name
      __var0 = LibGio.task_get_name(@pointer.as(LibGio::Task*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def priority
      __var0 = LibGio.task_get_priority(@pointer.as(LibGio::Task*))
      __var0
    end

    def return_on_cancel
      __var0 = LibGio.task_get_return_on_cancel(@pointer.as(LibGio::Task*))
      (__var0 == 1)
    end

    def source_object
      __var0 = LibGio.task_get_source_object(@pointer.as(LibGio::Task*))
      __var1 = GObject::Object.new(__var0) if __var0
      __var1
    end

    def source_tag
      LibGio.task_get_source_tag(@pointer.as(LibGio::Task*))
      nil
    end

    def task_data
      LibGio.task_get_task_data(@pointer.as(LibGio::Task*))
      nil
    end

    def had_error
      __var0 = LibGio.task_had_error(@pointer.as(LibGio::Task*))
      (__var0 == 1)
    end

    def propagate_boolean
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.task_propagate_boolean(@pointer.as(LibGio::Task*), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def propagate_int
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.task_propagate_int(@pointer.as(LibGio::Task*), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def propagate_pointer
      __var0 = Pointer(LibGLib::Error).null
      LibGio.task_propagate_pointer(@pointer.as(LibGio::Task*), pointerof(__var0))
      GLib::Error.assert(__var0)
      nil
    end

    def propagate_value : GObject::Value
      value = GObject::Value.new
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.task_propagate_value(@pointer.as(LibGio::Task*), value, pointerof(__var0))
      GLib::Error.assert(__var0)
      value
    end

    def return_boolean(result : ::Bool)
      LibGio.task_return_boolean(@pointer.as(LibGio::Task*), LibC::Int.new(result ? 1 : 0))
      nil
    end

    def return_error(error : LibGLib::Error*)
      LibGio.task_return_error(@pointer.as(LibGio::Task*), error)
      nil
    end

    def return_error_if_cancelled
      __var0 = LibGio.task_return_error_if_cancelled(@pointer.as(LibGio::Task*))
      (__var0 == 1)
    end

    def return_int(result : ::Int)
      LibGio.task_return_int(@pointer.as(LibGio::Task*), Int64.new(result))
      nil
    end

    def return_pointer(result : Void*?, result_destroy : GLib::DestroyNotify?)
      LibGio.task_return_pointer(@pointer.as(LibGio::Task*), result ? result : Pointer(Void).null, result_destroy ? result_destroy : nil)
      nil
    end

    def return_value(result)
      LibGio.task_return_value(@pointer.as(LibGio::Task*), result ? result.to_gvalue.to_unsafe : Pointer(LibGObject::Value).null)
      nil
    end

    def run_in_thread(task_func : Gio::TaskThreadFunc)
      LibGio.task_run_in_thread(@pointer.as(LibGio::Task*), task_func)
      nil
    end

    def run_in_thread_sync(task_func : Gio::TaskThreadFunc)
      LibGio.task_run_in_thread_sync(@pointer.as(LibGio::Task*), task_func)
      nil
    end

    def check_cancellable=(check_cancellable : ::Bool)
      LibGio.task_set_check_cancellable(@pointer.as(LibGio::Task*), LibC::Int.new(check_cancellable ? 1 : 0))
      nil
    end

    def name=(name : ::String?)
      LibGio.task_set_name(@pointer.as(LibGio::Task*), name ? name.to_unsafe : Pointer(UInt8).null)
      nil
    end

    def priority=(priority : ::Int)
      LibGio.task_set_priority(@pointer.as(LibGio::Task*), Int32.new(priority))
      nil
    end

    def return_on_cancel=(return_on_cancel : ::Bool)
      __var0 = LibGio.task_set_return_on_cancel(@pointer.as(LibGio::Task*), LibC::Int.new(return_on_cancel ? 1 : 0))
      (__var0 == 1)
    end

    def source_tag=(source_tag : Void*?)
      LibGio.task_set_source_tag(@pointer.as(LibGio::Task*), source_tag ? source_tag : Pointer(Void).null)
      nil
    end

    def set_task_data(task_data : Void*?, task_data_destroy : GLib::DestroyNotify?)
      LibGio.task_set_task_data(@pointer.as(LibGio::Task*), task_data ? task_data : Pointer(Void).null, task_data_destroy ? task_data_destroy : nil)
      nil
    end
  end

  class TaskClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TaskClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TaskClass*)
    end

    def to_unsafe_taskclass
      @pointer.not_nil!.as(LibGio::TaskClass*)
    end
  end

  alias TaskThreadFunc = LibGio::TaskThreadFunc

  class TcpConnection < SocketConnection
    @pointer : Void*

    def initialize(pointer : LibGio::TcpConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTcpConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tcp_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpConnection*)
    end

    def to_unsafe_tcpconnection
      @pointer.not_nil!.as(LibGio::TcpConnection*)
    end

    def initialize(*, graceful_disconnect : ::Bool? = nil, socket : Gio::Socket? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless graceful_disconnect.nil?
        __var0 << "graceful-disconnect".to_unsafe
        __var1 << graceful_disconnect.to_gvalue.to_unsafe.value
      end

      unless socket.nil?
        __var0 << "socket".to_unsafe
        __var1 << socket.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_tcp_connection_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def graceful_disconnect
      __var0 = LibGio.tcp_connection_get_graceful_disconnect(@pointer.as(LibGio::TcpConnection*))
      (__var0 == 1)
    end

    def graceful_disconnect=(graceful_disconnect : ::Bool)
      LibGio.tcp_connection_set_graceful_disconnect(@pointer.as(LibGio::TcpConnection*), LibC::Int.new(graceful_disconnect ? 1 : 0))
      nil
    end
  end

  class TcpConnectionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(304u64, 0u8).as(LibGio::TcpConnectionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TcpConnectionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpConnectionClass*)
    end

    def to_unsafe_tcpconnectionclass
      @pointer.not_nil!.as(LibGio::TcpConnectionClass*)
    end

    def parent_class
      Gio::SocketConnectionClass.new(to_unsafe.as(LibGio::TcpConnectionClass*).value.parent_class)
    end
  end

  class TcpConnectionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TcpConnectionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpConnectionPrivate*)
    end

    def to_unsafe_tcpconnectionprivate
      @pointer.not_nil!.as(LibGio::TcpConnectionPrivate*)
    end
  end

  class TcpWrapperConnection < TcpConnection
    @pointer : Void*

    def initialize(pointer : LibGio::TcpWrapperConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTcpWrapperConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tcp_wrapper_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpWrapperConnection*)
    end

    def to_unsafe_tcpwrapperconnection
      @pointer.not_nil!.as(LibGio::TcpWrapperConnection*)
    end

    def initialize(*, base_io_stream : Gio::IOStream? = nil, graceful_disconnect : ::Bool? = nil, socket : Gio::Socket? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless base_io_stream.nil?
        __var0 << "base-io-stream".to_unsafe
        __var1 << base_io_stream.to_gvalue.to_unsafe.value
      end

      unless graceful_disconnect.nil?
        __var0 << "graceful-disconnect".to_unsafe
        __var1 << graceful_disconnect.to_gvalue.to_unsafe.value
      end

      unless socket.nil?
        __var0 << "socket".to_unsafe
        __var1 << socket.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_tcp_wrapper_connection_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(base_io_stream : Gio::IOStream, socket : Gio::Socket) : self
      __var0 = LibGio.tcp_wrapper_connection_new(base_io_stream.to_unsafe_iostream, socket.to_unsafe_socket)
      GObject.raise_unexpected_null("g_tcp_wrapper_connection_new") if __var0.null?
      cast(Gio::SocketConnection.new(__var0))
    end

    def base_io_stream
      __var0 = LibGio.tcp_wrapper_connection_get_base_io_stream(@pointer.as(LibGio::TcpWrapperConnection*))
      GObject.raise_unexpected_null("g_tcp_wrapper_connection_get_base_io_stream") if __var0.null?
      Gio::IOStream.new(__var0)
    end
  end

  class TcpWrapperConnectionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(304u64, 0u8).as(LibGio::TcpWrapperConnectionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TcpWrapperConnectionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpWrapperConnectionClass*)
    end

    def to_unsafe_tcpwrapperconnectionclass
      @pointer.not_nil!.as(LibGio::TcpWrapperConnectionClass*)
    end

    def parent_class
      Gio::TcpConnectionClass.new(to_unsafe.as(LibGio::TcpWrapperConnectionClass*).value.parent_class)
    end
  end

  class TcpWrapperConnectionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TcpWrapperConnectionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TcpWrapperConnectionPrivate*)
    end

    def to_unsafe_tcpwrapperconnectionprivate
      @pointer.not_nil!.as(LibGio::TcpWrapperConnectionPrivate*)
    end
  end

  class TestDBus < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::TestDBus*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTestDBus")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_test_dbus_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TestDBus*)
    end

    def to_unsafe_testdbus
      @pointer.not_nil!.as(LibGio::TestDBus*)
    end

    def initialize(*, flags : Gio::TestDBusFlags? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_test_dbus_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(flags : Gio::TestDBusFlags) : self
      __var0 = LibGio.test_d_bus_new(flags)
      GObject.raise_unexpected_null("g_test_dbus_new") if __var0.null?
      cast(Gio::TestDBus.new(__var0))
    end

    def self.unset
      LibGio.test_d_bus_unset
      nil
    end

    def add_service_dir(path : ::String)
      LibGio.test_d_bus_add_service_dir(@pointer.as(LibGio::TestDBus*), path.to_unsafe)
      nil
    end

    def down
      LibGio.test_d_bus_down(@pointer.as(LibGio::TestDBus*))
      nil
    end

    def bus_address
      __var0 = LibGio.test_d_bus_get_bus_address(@pointer.as(LibGio::TestDBus*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def flags
      __var0 = LibGio.test_d_bus_get_flags(@pointer.as(LibGio::TestDBus*))
      Gio::TestDBusFlags.new(__var0)
    end

    def stop
      LibGio.test_d_bus_stop(@pointer.as(LibGio::TestDBus*))
      nil
    end

    def up
      LibGio.test_d_bus_up(@pointer.as(LibGio::TestDBus*))
      nil
    end
  end

  @[Flags]
  enum TestDBusFlags : UInt32
    NONE = 0
  end

  class ThemedIcon < GObject::Object
    include Gio::Icon

    @pointer : Void*

    def initialize(pointer : LibGio::ThemedIcon*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GThemedIcon")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_themed_icon_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ThemedIcon*)
    end

    def to_unsafe_themedicon
      @pointer.not_nil!.as(LibGio::ThemedIcon*)
    end

    def initialize(*, name : ::String? = nil, names : ::Enumerable(::String)? = nil, use_default_fallbacks : ::Bool? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless name.nil?
        __var0 << "name".to_unsafe
        __var1 << name.to_gvalue.to_unsafe.value
      end

      unless names.nil?
        __var0 << "names".to_unsafe
        __var1 << names.to_gvalue.to_unsafe.value
      end

      unless use_default_fallbacks.nil?
        __var0 << "use-default-fallbacks".to_unsafe
        __var1 << use_default_fallbacks.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_themed_icon_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(iconname : ::String) : self
      __var0 = LibGio.themed_icon_new(iconname.to_unsafe)
      GObject.raise_unexpected_null("g_themed_icon_new") if __var0.null?
      cast(Gio::ThemedIcon.new(__var0))
    end

    def self.new_from_names(iconnames : ::Enumerable) : self
      len = iconnames.size
      __var0 = LibGio.themed_icon_new_from_names((__iconnames_ary = iconnames.map { |__item| __item.to_unsafe }.to_a).to_unsafe, Int32.new(len))
      GObject.raise_unexpected_null("g_themed_icon_new_from_names") if __var0.null?
      cast(Gio::ThemedIcon.new(__var0))
    end

    def self.new_with_default_fallbacks(iconname : ::String) : self
      __var0 = LibGio.themed_icon_new_with_default_fallbacks(iconname.to_unsafe)
      GObject.raise_unexpected_null("g_themed_icon_new_with_default_fallbacks") if __var0.null?
      cast(Gio::ThemedIcon.new(__var0))
    end

    def append_name(iconname : ::String)
      LibGio.themed_icon_append_name(@pointer.as(LibGio::ThemedIcon*), iconname.to_unsafe)
      nil
    end

    def names
      __var0 = LibGio.themed_icon_get_names(@pointer.as(LibGio::ThemedIcon*))
      GObject.raise_unexpected_null("g_themed_icon_get_names") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def prepend_name(iconname : ::String)
      LibGio.themed_icon_prepend_name(@pointer.as(LibGio::ThemedIcon*), iconname.to_unsafe)
      nil
    end

    def use_default_fallbacks : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "use-default-fallbacks", __var0)
      __var0.boolean
    end
  end

  class ThemedIconClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ThemedIconClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ThemedIconClass*)
    end

    def to_unsafe_themediconclass
      @pointer.not_nil!.as(LibGio::ThemedIconClass*)
    end
  end

  class ThreadedSocketService < SocketService
    @pointer : Void*

    def initialize(pointer : LibGio::ThreadedSocketService*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GThreadedSocketService")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_threaded_socket_service_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ThreadedSocketService*)
    end

    def to_unsafe_threadedsocketservice
      @pointer.not_nil!.as(LibGio::ThreadedSocketService*)
    end

    def initialize(*, active : ::Bool? = nil, listen_backlog : Int32? = nil, max_threads : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless active.nil?
        __var0 << "active".to_unsafe
        __var1 << active.to_gvalue.to_unsafe.value
      end

      unless listen_backlog.nil?
        __var0 << "listen-backlog".to_unsafe
        __var1 << listen_backlog.to_gvalue.to_unsafe.value
      end

      unless max_threads.nil?
        __var0 << "max-threads".to_unsafe
        __var1 << max_threads.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_threaded_socket_service_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(max_threads : ::Int) : self
      __var0 = LibGio.threaded_socket_service_new(Int32.new(max_threads))
      GObject.raise_unexpected_null("g_threaded_socket_service_new") if __var0.null?
      cast(Gio::SocketService.new(__var0))
    end

    def max_threads : Int32
      __var0 = GObject::Value.new(type: GObject::Type::INT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "max-threads", __var0)
      __var0.int
    end

    alias RunSignal = ThreadedSocketService, Gio::SocketConnection, GObject::Object -> ::Bool

    def on_run(*, after = false, &block : RunSignal)
      __var0 = ->(arg0 : LibGio::ThreadedSocketService*, arg1 : LibGio::SocketConnection*, arg2 : LibGObject::Object*, box : Void*) {
        LibC::Int.new(::Box(RunSignal).unbox(box).call(ThreadedSocketService.new(arg0), arg1.null? ? GObject.raise_unexpected_null("connection in run") : Gio::SocketConnection.new(arg1), arg2.null? ? GObject.raise_unexpected_null("source_object in run") : GObject::Object.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(RunSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "run", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_run(&block : RunSignal)
      on_run(after: true, &block)
    end
  end

  class ThreadedSocketServiceClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(296u64, 0u8).as(LibGio::ThreadedSocketServiceClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ThreadedSocketServiceClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ThreadedSocketServiceClass*)
    end

    def to_unsafe_threadedsocketserviceclass
      @pointer.not_nil!.as(LibGio::ThreadedSocketServiceClass*)
    end

    def parent_class
      Gio::SocketServiceClass.new(to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value.parent_class)
    end

    def run
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value.run
    end

    def _g_reserved1
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::ThreadedSocketServiceClass*).value._g_reserved5
    end
  end

  class ThreadedSocketServicePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::ThreadedSocketServicePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ThreadedSocketServicePrivate*)
    end

    def to_unsafe_threadedsocketserviceprivate
      @pointer.not_nil!.as(LibGio::ThreadedSocketServicePrivate*)
    end
  end

  enum TlsAuthenticationMode : UInt32
    NONE      = 0
    REQUESTED = 1
    REQUIRED  = 2
  end

  module TlsBackend
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include TlsBackend
      @pointer : Void*

      def initialize(pointer : LibGio::TlsBackend*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GTlsBackend")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_backend_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::TlsBackend*)
      end

      def to_unsafe_tlsbackend
        @pointer.not_nil!.as(LibGio::TlsBackend*)
      end
    end

    def to_unsafe_tlsbackend
      @pointer.not_nil!.as(LibGio::TlsBackend*)
    end

    def self.default
      __var0 = LibGio.tls_backend_get_default
      GObject.raise_unexpected_null("g_tls_backend_get_default") if __var0.null?
      Gio::TlsBackend::Wrapper.new(__var0)
    end

    def certificate_type
      __var0 = LibGio.tls_backend_get_certificate_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def client_connection_type
      __var0 = LibGio.tls_backend_get_client_connection_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def default_database
      __var0 = LibGio.tls_backend_get_default_database(@pointer.as(LibGio::TlsBackend*))
      GObject.raise_unexpected_null("g_tls_backend_get_default_database") if __var0.null?
      Gio::TlsDatabase.new(__var0)
    end

    def dtls_client_connection_type
      __var0 = LibGio.tls_backend_get_dtls_client_connection_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def dtls_server_connection_type
      __var0 = LibGio.tls_backend_get_dtls_server_connection_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def file_database_type
      __var0 = LibGio.tls_backend_get_file_database_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def server_connection_type
      __var0 = LibGio.tls_backend_get_server_connection_type(@pointer.as(LibGio::TlsBackend*))
      __var0
    end

    def default_database=(database : Gio::TlsDatabase?)
      LibGio.tls_backend_set_default_database(@pointer.as(LibGio::TlsBackend*), database ? database.to_unsafe_tlsdatabase : Pointer(LibGio::TlsDatabase).null)
      nil
    end

    def supports_dtls
      __var0 = LibGio.tls_backend_supports_dtls(@pointer.as(LibGio::TlsBackend*))
      (__var0 == 1)
    end

    def supports_tls
      __var0 = LibGio.tls_backend_supports_tls(@pointer.as(LibGio::TlsBackend*))
      (__var0 == 1)
    end
  end

  class TlsBackendInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(88u64, 0u8).as(LibGio::TlsBackendInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsBackendInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsBackendInterface*)
    end

    def to_unsafe_tlsbackendinterface
      @pointer.not_nil!.as(LibGio::TlsBackendInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::TlsBackendInterface*).value.g_iface)
    end

    def supports_tls
      to_unsafe.as(LibGio::TlsBackendInterface*).value.supports_tls
    end

    def get_certificate_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_certificate_type
    end

    def get_client_connection_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_client_connection_type
    end

    def get_server_connection_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_server_connection_type
    end

    def get_file_database_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_file_database_type
    end

    def get_default_database
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_default_database
    end

    def supports_dtls
      to_unsafe.as(LibGio::TlsBackendInterface*).value.supports_dtls
    end

    def get_dtls_client_connection_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_dtls_client_connection_type
    end

    def get_dtls_server_connection_type
      to_unsafe.as(LibGio::TlsBackendInterface*).value.get_dtls_server_connection_type
    end
  end

  class TlsCertificate < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::TlsCertificate*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTlsCertificate")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_certificate_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsCertificate*)
    end

    def to_unsafe_tlscertificate
      @pointer.not_nil!.as(LibGio::TlsCertificate*)
    end

    def self.new_from_file(file : ::String) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_certificate_new_from_file(file.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_certificate_new_from_file") if __var1.null?
      cast(Gio::TlsCertificate.new(__var1))
    end

    def self.new_from_files(cert_file : ::String, key_file : ::String) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_certificate_new_from_files(cert_file.to_unsafe, key_file.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_certificate_new_from_files") if __var1.null?
      cast(Gio::TlsCertificate.new(__var1))
    end

    def self.new_from_pem(data : ::String, length : ::Int) : self
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_certificate_new_from_pem(data.to_unsafe, Int64.new(length), pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_certificate_new_from_pem") if __var1.null?
      cast(Gio::TlsCertificate.new(__var1))
    end

    def self.list_new_from_file(file : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_certificate_list_new_from_file(file.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_certificate_list_new_from_file") if __var1.null?
      GLib::ListIterator(Gio::TlsCertificate, LibGio::TlsCertificate*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def issuer
      __var0 = LibGio.tls_certificate_get_issuer(@pointer.as(LibGio::TlsCertificate*))
      GObject.raise_unexpected_null("g_tls_certificate_get_issuer") if __var0.null?
      Gio::TlsCertificate.new(__var0)
    end

    def same?(cert_two : Gio::TlsCertificate)
      __var0 = LibGio.tls_certificate_is_same(@pointer.as(LibGio::TlsCertificate*), cert_two.to_unsafe_tlscertificate)
      (__var0 == 1)
    end

    def verify(identity : Gio::SocketConnectable?, trusted_ca : Gio::TlsCertificate?)
      __var0 = LibGio.tls_certificate_verify(@pointer.as(LibGio::TlsCertificate*), identity ? identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, trusted_ca ? trusted_ca.to_unsafe_tlscertificate : Pointer(LibGio::TlsCertificate).null)
      Gio::TlsCertificateFlags.new(__var0)
    end

    def certificate : ::Enumerable(UInt8)
      __var0 = GObject::Value.new(type: GObject::Type::ARRAY)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "certificate", __var0)
      __var0
    end

    def certificate_pem : ::String
      __var0 = GObject::Value.new(type: GObject::Type::UTF8)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "certificate-pem", __var0)
      __var0.string
    end
  end

  class TlsCertificateClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(208u64, 0u8).as(LibGio::TlsCertificateClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsCertificateClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsCertificateClass*)
    end

    def to_unsafe_tlscertificateclass
      @pointer.not_nil!.as(LibGio::TlsCertificateClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::TlsCertificateClass*).value.parent_class)
    end

    def verify
      to_unsafe.as(LibGio::TlsCertificateClass*).value.verify
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsCertificateClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  @[Flags]
  enum TlsCertificateFlags : UInt32
    ZERO_NONE     =   0
    UNKNOWN_CA    =   1
    BAD_IDENTITY  =   2
    NOT_ACTIVATED =   4
    EXPIRED       =   8
    REVOKED       =  16
    INSECURE      =  32
    GENERIC_ERROR =  64
    VALIDATE_ALL  = 127
  end

  class TlsCertificatePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TlsCertificatePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsCertificatePrivate*)
    end

    def to_unsafe_tlscertificateprivate
      @pointer.not_nil!.as(LibGio::TlsCertificatePrivate*)
    end
  end

  enum TlsCertificateRequestFlags : UInt32
    NONE = 0
  end

  module TlsClientConnection
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include TlsClientConnection
      @pointer : Void*

      def initialize(pointer : LibGio::TlsClientConnection*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GTlsClientConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_client_connection_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::TlsClientConnection*)
      end

      def to_unsafe_tlsclientconnection
        @pointer.not_nil!.as(LibGio::TlsClientConnection*)
      end
    end

    def to_unsafe_tlsclientconnection
      @pointer.not_nil!.as(LibGio::TlsClientConnection*)
    end

    def self.new(base_io_stream : Gio::IOStream, server_identity : Gio::SocketConnectable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_client_connection_new(base_io_stream.to_unsafe_iostream, server_identity ? server_identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_client_connection_new") if __var1.null?
      Gio::TlsClientConnection::Wrapper.new(__var1)
    end

    def copy_session_state(source : Gio::TlsClientConnection)
      LibGio.tls_client_connection_copy_session_state(@pointer.as(LibGio::TlsClientConnection*), source.to_unsafe_tlsclientconnection)
      nil
    end

    def accepted_cas
      __var0 = LibGio.tls_client_connection_get_accepted_cas(@pointer.as(LibGio::TlsClientConnection*))
      GObject.raise_unexpected_null("g_tls_client_connection_get_accepted_cas") if __var0.null?
      GLib::ListIterator(::Enumerable(UInt8), Pointer(Void)*).new(GLib::List.new(__var0.as(LibGLib::List*)))
    end

    def server_identity
      __var0 = LibGio.tls_client_connection_get_server_identity(@pointer.as(LibGio::TlsClientConnection*))
      GObject.raise_unexpected_null("g_tls_client_connection_get_server_identity") if __var0.null?
      Gio::SocketConnectable::Wrapper.new(__var0)
    end

    def use_ssl3
      __var0 = LibGio.tls_client_connection_get_use_ssl3(@pointer.as(LibGio::TlsClientConnection*))
      (__var0 == 1)
    end

    def validation_flags
      __var0 = LibGio.tls_client_connection_get_validation_flags(@pointer.as(LibGio::TlsClientConnection*))
      Gio::TlsCertificateFlags.new(__var0)
    end

    def server_identity=(identity : Gio::SocketConnectable)
      LibGio.tls_client_connection_set_server_identity(@pointer.as(LibGio::TlsClientConnection*), identity.to_unsafe_socketconnectable)
      nil
    end

    def use_ssl3=(use_ssl3 : ::Bool)
      LibGio.tls_client_connection_set_use_ssl3(@pointer.as(LibGio::TlsClientConnection*), LibC::Int.new(use_ssl3 ? 1 : 0))
      nil
    end

    def validation_flags=(flags : Gio::TlsCertificateFlags)
      LibGio.tls_client_connection_set_validation_flags(@pointer.as(LibGio::TlsClientConnection*), flags)
      nil
    end
  end

  class TlsClientConnectionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(24u64, 0u8).as(LibGio::TlsClientConnectionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsClientConnectionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsClientConnectionInterface*)
    end

    def to_unsafe_tlsclientconnectioninterface
      @pointer.not_nil!.as(LibGio::TlsClientConnectionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::TlsClientConnectionInterface*).value.g_iface)
    end

    def copy_session_state
      to_unsafe.as(LibGio::TlsClientConnectionInterface*).value.copy_session_state
    end
  end

  class TlsConnection < IOStream
    @pointer : Void*

    def initialize(pointer : LibGio::TlsConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTlsConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsConnection*)
    end

    def to_unsafe_tlsconnection
      @pointer.not_nil!.as(LibGio::TlsConnection*)
    end

    def emit_accept_certificate(peer_cert : Gio::TlsCertificate, errors : Gio::TlsCertificateFlags)
      __var0 = LibGio.tls_connection_emit_accept_certificate(@pointer.as(LibGio::TlsConnection*), peer_cert.to_unsafe_tlscertificate, errors)
      (__var0 == 1)
    end

    def certificate
      __var0 = LibGio.tls_connection_get_certificate(@pointer.as(LibGio::TlsConnection*))
      GObject.raise_unexpected_null("g_tls_connection_get_certificate") if __var0.null?
      Gio::TlsCertificate.new(__var0)
    end

    def database
      __var0 = LibGio.tls_connection_get_database(@pointer.as(LibGio::TlsConnection*))
      GObject.raise_unexpected_null("g_tls_connection_get_database") if __var0.null?
      Gio::TlsDatabase.new(__var0)
    end

    def interaction
      __var0 = LibGio.tls_connection_get_interaction(@pointer.as(LibGio::TlsConnection*))
      GObject.raise_unexpected_null("g_tls_connection_get_interaction") if __var0.null?
      Gio::TlsInteraction.new(__var0)
    end

    def negotiated_protocol
      __var0 = LibGio.tls_connection_get_negotiated_protocol(@pointer.as(LibGio::TlsConnection*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def peer_certificate
      __var0 = LibGio.tls_connection_get_peer_certificate(@pointer.as(LibGio::TlsConnection*))
      GObject.raise_unexpected_null("g_tls_connection_get_peer_certificate") if __var0.null?
      Gio::TlsCertificate.new(__var0)
    end

    def peer_certificate_errors
      __var0 = LibGio.tls_connection_get_peer_certificate_errors(@pointer.as(LibGio::TlsConnection*))
      Gio::TlsCertificateFlags.new(__var0)
    end

    def rehandshake_mode
      __var0 = LibGio.tls_connection_get_rehandshake_mode(@pointer.as(LibGio::TlsConnection*))
      Gio::TlsRehandshakeMode.new(__var0)
    end

    def require_close_notify
      __var0 = LibGio.tls_connection_get_require_close_notify(@pointer.as(LibGio::TlsConnection*))
      (__var0 == 1)
    end

    def use_system_certdb
      __var0 = LibGio.tls_connection_get_use_system_certdb(@pointer.as(LibGio::TlsConnection*))
      (__var0 == 1)
    end

    def handshake(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_connection_handshake(@pointer.as(LibGio::TlsConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def handshake_async(io_priority : ::Int, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_connection_handshake_async(@pointer.as(LibGio::TlsConnection*), Int32.new(io_priority), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def handshake_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_connection_handshake_finish(@pointer.as(LibGio::TlsConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def advertised_protocols=(protocols : ::Enumerable?)
      LibGio.tls_connection_set_advertised_protocols(@pointer.as(LibGio::TlsConnection*), protocols ? (__protocols_ary = protocols.map { |__item| __item.to_unsafe }.to_a).to_unsafe : Pointer(Pointer(UInt8)).null)
      nil
    end

    def certificate=(certificate : Gio::TlsCertificate)
      LibGio.tls_connection_set_certificate(@pointer.as(LibGio::TlsConnection*), certificate.to_unsafe_tlscertificate)
      nil
    end

    def database=(database : Gio::TlsDatabase)
      LibGio.tls_connection_set_database(@pointer.as(LibGio::TlsConnection*), database.to_unsafe_tlsdatabase)
      nil
    end

    def interaction=(interaction : Gio::TlsInteraction?)
      LibGio.tls_connection_set_interaction(@pointer.as(LibGio::TlsConnection*), interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null)
      nil
    end

    def rehandshake_mode=(mode : Gio::TlsRehandshakeMode)
      LibGio.tls_connection_set_rehandshake_mode(@pointer.as(LibGio::TlsConnection*), mode)
      nil
    end

    def require_close_notify=(require_close_notify : ::Bool)
      LibGio.tls_connection_set_require_close_notify(@pointer.as(LibGio::TlsConnection*), LibC::Int.new(require_close_notify ? 1 : 0))
      nil
    end

    def use_system_certdb=(use_system_certdb : ::Bool)
      LibGio.tls_connection_set_use_system_certdb(@pointer.as(LibGio::TlsConnection*), LibC::Int.new(use_system_certdb ? 1 : 0))
      nil
    end

    def base_io_stream : Gio::IOStream
      __var0 = GObject::Value.new(type: GObject::Type::OBJECT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "base-io-stream", __var0)
      Gio::IOStream.cast(__var0.object)
    end

    alias AcceptCertificateSignal = TlsConnection, Gio::TlsCertificate, Gio::TlsCertificateFlags -> ::Bool

    def on_accept_certificate(*, after = false, &block : AcceptCertificateSignal)
      __var0 = ->(arg0 : LibGio::TlsConnection*, arg1 : LibGio::TlsCertificate*, arg2 : LibGio::TlsCertificateFlags, box : Void*) {
        LibC::Int.new(::Box(AcceptCertificateSignal).unbox(box).call(TlsConnection.new(arg0), arg1.null? ? GObject.raise_unexpected_null("peer_cert in accept_certificate") : Gio::TlsCertificate.new(arg1), Gio::TlsCertificateFlags.new(arg2)) ? 1 : 0)
      }

      __var1 = ::Box.box(AcceptCertificateSignal.new { |arg0, arg1, arg2|
        block.call(arg0, arg1, arg2)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "accept-certificate", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_accept_certificate(&block : AcceptCertificateSignal)
      on_accept_certificate(after: true, &block)
    end
  end

  class TlsConnectionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(352u64, 0u8).as(LibGio::TlsConnectionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsConnectionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsConnectionClass*)
    end

    def to_unsafe_tlsconnectionclass
      @pointer.not_nil!.as(LibGio::TlsConnectionClass*)
    end

    def parent_class
      Gio::IOStreamClass.new(to_unsafe.as(LibGio::TlsConnectionClass*).value.parent_class)
    end

    def accept_certificate
      to_unsafe.as(LibGio::TlsConnectionClass*).value.accept_certificate
    end

    def handshake
      to_unsafe.as(LibGio::TlsConnectionClass*).value.handshake
    end

    def handshake_async
      to_unsafe.as(LibGio::TlsConnectionClass*).value.handshake_async
    end

    def handshake_finish
      to_unsafe.as(LibGio::TlsConnectionClass*).value.handshake_finish
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsConnectionClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class TlsConnectionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TlsConnectionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsConnectionPrivate*)
    end

    def to_unsafe_tlsconnectionprivate
      @pointer.not_nil!.as(LibGio::TlsConnectionPrivate*)
    end
  end

  class TlsDatabase < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::TlsDatabase*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTlsDatabase")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_database_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsDatabase*)
    end

    def to_unsafe_tlsdatabase
      @pointer.not_nil!.as(LibGio::TlsDatabase*)
    end

    def create_certificate_handle(certificate : Gio::TlsCertificate)
      __var0 = LibGio.tls_database_create_certificate_handle(@pointer.as(LibGio::TlsDatabase*), certificate.to_unsafe_tlscertificate)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def lookup_certificate_for_handle(handle : ::String, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificate_for_handle(@pointer.as(LibGio::TlsDatabase*), handle.to_unsafe, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var2 = Gio::TlsCertificate.new(__var1) if __var1
      __var2
    end

    def lookup_certificate_for_handle_async(handle : ::String, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_database_lookup_certificate_for_handle_async(@pointer.as(LibGio::TlsDatabase*), handle.to_unsafe, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_certificate_for_handle_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificate_for_handle_finish(@pointer.as(LibGio::TlsDatabase*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_database_lookup_certificate_for_handle_finish") if __var1.null?
      Gio::TlsCertificate.new(__var1)
    end

    def lookup_certificate_issuer(certificate : Gio::TlsCertificate, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificate_issuer(@pointer.as(LibGio::TlsDatabase*), certificate.to_unsafe_tlscertificate, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_database_lookup_certificate_issuer") if __var1.null?
      Gio::TlsCertificate.new(__var1)
    end

    def lookup_certificate_issuer_async(certificate : Gio::TlsCertificate, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_database_lookup_certificate_issuer_async(@pointer.as(LibGio::TlsDatabase*), certificate.to_unsafe_tlscertificate, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_certificate_issuer_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificate_issuer_finish(@pointer.as(LibGio::TlsDatabase*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_database_lookup_certificate_issuer_finish") if __var1.null?
      Gio::TlsCertificate.new(__var1)
    end

    def lookup_certificates_issued_by(issuer_raw_dn : ::Bytes, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificates_issued_by(@pointer.as(LibGio::TlsDatabase*), issuer_raw_dn.to_unsafe, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_database_lookup_certificates_issued_by") if __var1.null?
      GLib::ListIterator(Gio::TlsCertificate, LibGio::TlsCertificate*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def lookup_certificates_issued_by_async(issuer_raw_dn : ::Bytes, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseLookupFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_database_lookup_certificates_issued_by_async(@pointer.as(LibGio::TlsDatabase*), issuer_raw_dn.to_unsafe, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def lookup_certificates_issued_by_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_lookup_certificates_issued_by_finish(@pointer.as(LibGio::TlsDatabase*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_database_lookup_certificates_issued_by_finish") if __var1.null?
      GLib::ListIterator(Gio::TlsCertificate, LibGio::TlsCertificate*).new(GLib::List.new(__var1.as(LibGLib::List*)))
    end

    def verify_chain(chain : Gio::TlsCertificate, purpose : ::String, identity : Gio::SocketConnectable?, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseVerifyFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_verify_chain(@pointer.as(LibGio::TlsDatabase*), chain.to_unsafe_tlscertificate, purpose.to_unsafe, identity ? identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsCertificateFlags.new(__var1)
    end

    def verify_chain_async(chain : Gio::TlsCertificate, purpose : ::String, identity : Gio::SocketConnectable?, interaction : Gio::TlsInteraction?, flags : Gio::TlsDatabaseVerifyFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_database_verify_chain_async(@pointer.as(LibGio::TlsDatabase*), chain.to_unsafe_tlscertificate, purpose.to_unsafe, identity ? identity.to_unsafe_socketconnectable : Pointer(LibGio::SocketConnectable).null, interaction ? interaction.to_unsafe_tlsinteraction : Pointer(LibGio::TlsInteraction).null, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def verify_chain_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_database_verify_chain_finish(@pointer.as(LibGio::TlsDatabase*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsCertificateFlags.new(__var1)
    end
  end

  class TlsDatabaseClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(368u64, 0u8).as(LibGio::TlsDatabaseClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsDatabaseClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsDatabaseClass*)
    end

    def to_unsafe_tlsdatabaseclass
      @pointer.not_nil!.as(LibGio::TlsDatabaseClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::TlsDatabaseClass*).value.parent_class)
    end

    def verify_chain
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.verify_chain
    end

    def verify_chain_async
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.verify_chain_async
    end

    def verify_chain_finish
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.verify_chain_finish
    end

    def create_certificate_handle
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.create_certificate_handle
    end

    def lookup_certificate_for_handle
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_for_handle
    end

    def lookup_certificate_for_handle_async
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_for_handle_async
    end

    def lookup_certificate_for_handle_finish
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_for_handle_finish
    end

    def lookup_certificate_issuer
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_issuer
    end

    def lookup_certificate_issuer_async
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_issuer_async
    end

    def lookup_certificate_issuer_finish
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificate_issuer_finish
    end

    def lookup_certificates_issued_by
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificates_issued_by
    end

    def lookup_certificates_issued_by_async
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificates_issued_by_async
    end

    def lookup_certificates_issued_by_finish
      to_unsafe.as(LibGio::TlsDatabaseClass*).value.lookup_certificates_issued_by_finish
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsDatabaseClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  enum TlsDatabaseLookupFlags : UInt32
    NONE    = 0
    KEYPAIR = 1
  end

  class TlsDatabasePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TlsDatabasePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsDatabasePrivate*)
    end

    def to_unsafe_tlsdatabaseprivate
      @pointer.not_nil!.as(LibGio::TlsDatabasePrivate*)
    end
  end

  @[Flags]
  enum TlsDatabaseVerifyFlags : UInt32
    NONE = 0
  end

  enum TlsError : UInt32
    UNAVAILABLE            = 0
    MISC                   = 1
    BAD_CERTIFICATE        = 2
    NOT_TLS                = 3
    HANDSHAKE              = 4
    CERTIFICATE_REQUIRED   = 5
    EOF                    = 6
    INAPPROPRIATE_FALLBACK = 7
  end

  # Function quark

  module TlsFileDatabase
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include TlsFileDatabase
      @pointer : Void*

      def initialize(pointer : LibGio::TlsFileDatabase*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GTlsFileDatabase")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_file_database_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::TlsFileDatabase*)
      end

      def to_unsafe_tlsfiledatabase
        @pointer.not_nil!.as(LibGio::TlsFileDatabase*)
      end
    end

    def to_unsafe_tlsfiledatabase
      @pointer.not_nil!.as(LibGio::TlsFileDatabase*)
    end

    def self.new(anchors : ::String)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_file_database_new(anchors.to_unsafe, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_file_database_new") if __var1.null?
      Gio::TlsFileDatabase::Wrapper.new(__var1)
    end
  end

  class TlsFileDatabaseInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(80u64, 0u8).as(LibGio::TlsFileDatabaseInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsFileDatabaseInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsFileDatabaseInterface*)
    end

    def to_unsafe_tlsfiledatabaseinterface
      @pointer.not_nil!.as(LibGio::TlsFileDatabaseInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::TlsFileDatabaseInterface*).value.g_iface)
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsFileDatabaseInterface*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class TlsInteraction < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::TlsInteraction*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTlsInteraction")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_interaction_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsInteraction*)
    end

    def to_unsafe_tlsinteraction
      @pointer.not_nil!.as(LibGio::TlsInteraction*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_tls_interaction_get_type, 0, nil, nil).as(Void*)
    end

    def ask_password(password : Gio::TlsPassword, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_ask_password(@pointer.as(LibGio::TlsInteraction*), password.to_unsafe_tlspassword, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end

    def ask_password_async(password : Gio::TlsPassword, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_interaction_ask_password_async(@pointer.as(LibGio::TlsInteraction*), password.to_unsafe_tlspassword, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def ask_password_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_ask_password_finish(@pointer.as(LibGio::TlsInteraction*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end

    def invoke_ask_password(password : Gio::TlsPassword, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_invoke_ask_password(@pointer.as(LibGio::TlsInteraction*), password.to_unsafe_tlspassword, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end

    def invoke_request_certificate(connection : Gio::TlsConnection, flags : Gio::TlsCertificateRequestFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_invoke_request_certificate(@pointer.as(LibGio::TlsInteraction*), connection.to_unsafe_tlsconnection, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end

    def request_certificate(connection : Gio::TlsConnection, flags : Gio::TlsCertificateRequestFlags, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_request_certificate(@pointer.as(LibGio::TlsInteraction*), connection.to_unsafe_tlsconnection, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end

    def request_certificate_async(connection : Gio::TlsConnection, flags : Gio::TlsCertificateRequestFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.tls_interaction_request_certificate_async(@pointer.as(LibGio::TlsInteraction*), connection.to_unsafe_tlsconnection, flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def request_certificate_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_interaction_request_certificate_finish(@pointer.as(LibGio::TlsInteraction*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      Gio::TlsInteractionResult.new(__var1)
    end
  end

  class TlsInteractionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(352u64, 0u8).as(LibGio::TlsInteractionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsInteractionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsInteractionClass*)
    end

    def to_unsafe_tlsinteractionclass
      @pointer.not_nil!.as(LibGio::TlsInteractionClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::TlsInteractionClass*).value.parent_class)
    end

    def ask_password
      to_unsafe.as(LibGio::TlsInteractionClass*).value.ask_password
    end

    def ask_password_async
      to_unsafe.as(LibGio::TlsInteractionClass*).value.ask_password_async
    end

    def ask_password_finish
      to_unsafe.as(LibGio::TlsInteractionClass*).value.ask_password_finish
    end

    def request_certificate
      to_unsafe.as(LibGio::TlsInteractionClass*).value.request_certificate
    end

    def request_certificate_async
      to_unsafe.as(LibGio::TlsInteractionClass*).value.request_certificate_async
    end

    def request_certificate_finish
      to_unsafe.as(LibGio::TlsInteractionClass*).value.request_certificate_finish
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsInteractionClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  class TlsInteractionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TlsInteractionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsInteractionPrivate*)
    end

    def to_unsafe_tlsinteractionprivate
      @pointer.not_nil!.as(LibGio::TlsInteractionPrivate*)
    end
  end

  enum TlsInteractionResult : UInt32
    UNHANDLED = 0
    HANDLED   = 1
    FAILED    = 2
  end

  class TlsPassword < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::TlsPassword*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GTlsPassword")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_password_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsPassword*)
    end

    def to_unsafe_tlspassword
      @pointer.not_nil!.as(LibGio::TlsPassword*)
    end

    def initialize(*, description : ::String? = nil, flags : Gio::TlsPasswordFlags? = nil, warning : ::String? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless description.nil?
        __var0 << "description".to_unsafe
        __var1 << description.to_gvalue.to_unsafe.value
      end

      unless flags.nil?
        __var0 << "flags".to_unsafe
        __var1 << flags.to_gvalue.to_unsafe.value
      end

      unless warning.nil?
        __var0 << "warning".to_unsafe
        __var1 << warning.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_tls_password_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(flags : Gio::TlsPasswordFlags, description : ::String) : self
      __var0 = LibGio.tls_password_new(flags, description.to_unsafe)
      GObject.raise_unexpected_null("g_tls_password_new") if __var0.null?
      cast(Gio::TlsPassword.new(__var0))
    end

    def description
      __var0 = LibGio.tls_password_get_description(@pointer.as(LibGio::TlsPassword*))
      GObject.raise_unexpected_null("g_tls_password_get_description") if __var0.null?
      ::String.new(__var0)
    end

    def flags
      __var0 = LibGio.tls_password_get_flags(@pointer.as(LibGio::TlsPassword*))
      Gio::TlsPasswordFlags.new(__var0)
    end

    def value(length : ::Int)
      __var0 = LibGio.tls_password_get_value(@pointer.as(LibGio::TlsPassword*), length ? length : Pointer(UInt64).null)
      GObject.raise_unexpected_null("g_tls_password_get_value") if __var0.null?
      __var0
    end

    def warning
      __var0 = LibGio.tls_password_get_warning(@pointer.as(LibGio::TlsPassword*))
      GObject.raise_unexpected_null("g_tls_password_get_warning") if __var0.null?
      ::String.new(__var0)
    end

    def description=(description : ::String)
      LibGio.tls_password_set_description(@pointer.as(LibGio::TlsPassword*), description.to_unsafe)
      nil
    end

    def flags=(flags : Gio::TlsPasswordFlags)
      LibGio.tls_password_set_flags(@pointer.as(LibGio::TlsPassword*), flags)
      nil
    end

    def set_value(value : ::Bytes)
      length = value.size
      LibGio.tls_password_set_value(@pointer.as(LibGio::TlsPassword*), value.to_unsafe, Int64.new(length))
      nil
    end

    def set_value_full(value : ::Bytes, destroy : GLib::DestroyNotify?)
      length = value.size
      LibGio.tls_password_set_value_full(@pointer.as(LibGio::TlsPassword*), value.to_unsafe, Int64.new(length), destroy ? destroy : nil)
      nil
    end

    def warning=(warning : ::String)
      LibGio.tls_password_set_warning(@pointer.as(LibGio::TlsPassword*), warning.to_unsafe)
      nil
    end
  end

  class TlsPasswordClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(192u64, 0u8).as(LibGio::TlsPasswordClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsPasswordClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsPasswordClass*)
    end

    def to_unsafe_tlspasswordclass
      @pointer.not_nil!.as(LibGio::TlsPasswordClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::TlsPasswordClass*).value.parent_class)
    end

    def get_value
      to_unsafe.as(LibGio::TlsPasswordClass*).value.get_value
    end

    def set_value
      to_unsafe.as(LibGio::TlsPasswordClass*).value.set_value
    end

    def get_default_warning
      to_unsafe.as(LibGio::TlsPasswordClass*).value.get_default_warning
    end

    def padding
      GObject::PointerIterator.new(to_unsafe.as(LibGio::TlsPasswordClass*).value.padding) { |__var0|
        __var0
      }
    end
  end

  @[Flags]
  enum TlsPasswordFlags : UInt32
    NONE       = 0
    RETRY      = 2
    MANY_TRIES = 4
    FINAL_TRY  = 8
  end

  class TlsPasswordPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::TlsPasswordPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsPasswordPrivate*)
    end

    def to_unsafe_tlspasswordprivate
      @pointer.not_nil!.as(LibGio::TlsPasswordPrivate*)
    end
  end

  enum TlsRehandshakeMode : UInt32
    NEVER    = 0
    SAFELY   = 1
    UNSAFELY = 2
  end

  module TlsServerConnection
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include TlsServerConnection
      @pointer : Void*

      def initialize(pointer : LibGio::TlsServerConnection*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GTlsServerConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_tls_server_connection_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::TlsServerConnection*)
      end

      def to_unsafe_tlsserverconnection
        @pointer.not_nil!.as(LibGio::TlsServerConnection*)
      end
    end

    def to_unsafe_tlsserverconnection
      @pointer.not_nil!.as(LibGio::TlsServerConnection*)
    end

    def self.new(base_io_stream : Gio::IOStream, certificate : Gio::TlsCertificate?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.tls_server_connection_new(base_io_stream.to_unsafe_iostream, certificate ? certificate.to_unsafe_tlscertificate : Pointer(LibGio::TlsCertificate).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_tls_server_connection_new") if __var1.null?
      Gio::TlsServerConnection::Wrapper.new(__var1)
    end
  end

  class TlsServerConnectionInterface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(16u64, 0u8).as(LibGio::TlsServerConnectionInterface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::TlsServerConnectionInterface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::TlsServerConnectionInterface*)
    end

    def to_unsafe_tlsserverconnectioninterface
      @pointer.not_nil!.as(LibGio::TlsServerConnectionInterface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::TlsServerConnectionInterface*).value.g_iface)
    end
  end

  class UnixConnection < SocketConnection
    @pointer : Void*

    def initialize(pointer : LibGio::UnixConnection*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixConnection")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_connection_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixConnection*)
    end

    def to_unsafe_unixconnection
      @pointer.not_nil!.as(LibGio::UnixConnection*)
    end

    def initialize(*, socket : Gio::Socket? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless socket.nil?
        __var0 << "socket".to_unsafe
        __var1 << socket.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_connection_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def receive_credentials(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_receive_credentials(@pointer.as(LibGio::UnixConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_unix_connection_receive_credentials") if __var1.null?
      Gio::Credentials.new(__var1)
    end

    def receive_credentials_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.unix_connection_receive_credentials_async(@pointer.as(LibGio::UnixConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def receive_credentials_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_receive_credentials_finish(@pointer.as(LibGio::UnixConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      GObject.raise_unexpected_null("g_unix_connection_receive_credentials_finish") if __var1.null?
      Gio::Credentials.new(__var1)
    end

    def receive_fd(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_receive_fd(@pointer.as(LibGio::UnixConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def send_credentials(cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_send_credentials(@pointer.as(LibGio::UnixConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def send_credentials_async(cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.unix_connection_send_credentials_async(@pointer.as(LibGio::UnixConnection*), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def send_credentials_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_send_credentials_finish(@pointer.as(LibGio::UnixConnection*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def send_fd(fd : ::Int, cancellable : Gio::Cancellable?)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_connection_send_fd(@pointer.as(LibGio::UnixConnection*), Int32.new(fd), cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end
  end

  class UnixConnectionClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(304u64, 0u8).as(LibGio::UnixConnectionClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixConnectionClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixConnectionClass*)
    end

    def to_unsafe_unixconnectionclass
      @pointer.not_nil!.as(LibGio::UnixConnectionClass*)
    end

    def parent_class
      Gio::SocketConnectionClass.new(to_unsafe.as(LibGio::UnixConnectionClass*).value.parent_class)
    end
  end

  class UnixConnectionPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixConnectionPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixConnectionPrivate*)
    end

    def to_unsafe_unixconnectionprivate
      @pointer.not_nil!.as(LibGio::UnixConnectionPrivate*)
    end
  end

  class UnixCredentialsMessage < SocketControlMessage
    @pointer : Void*

    def initialize(pointer : LibGio::UnixCredentialsMessage*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixCredentialsMessage")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_credentials_message_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessage*)
    end

    def to_unsafe_unixcredentialsmessage
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessage*)
    end

    def initialize(*, credentials : Gio::Credentials? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless credentials.nil?
        __var0 << "credentials".to_unsafe
        __var1 << credentials.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_credentials_message_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.unix_credentials_message_new
      GObject.raise_unexpected_null("g_unix_credentials_message_new") if __var0.null?
      cast(Gio::SocketControlMessage.new(__var0))
    end

    def self.new_with_credentials(credentials : Gio::Credentials) : self
      __var0 = LibGio.unix_credentials_message_new_with_credentials(credentials.to_unsafe_credentials)
      GObject.raise_unexpected_null("g_unix_credentials_message_new_with_credentials") if __var0.null?
      cast(Gio::SocketControlMessage.new(__var0))
    end

    def self.supported?
      __var0 = LibGio.unix_credentials_message_is_supported
      (__var0 == 1)
    end

    def credentials
      __var0 = LibGio.unix_credentials_message_get_credentials(@pointer.as(LibGio::UnixCredentialsMessage*))
      GObject.raise_unexpected_null("g_unix_credentials_message_get_credentials") if __var0.null?
      Gio::Credentials.new(__var0)
    end
  end

  class UnixCredentialsMessageClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(232u64, 0u8).as(LibGio::UnixCredentialsMessageClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixCredentialsMessageClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessageClass*)
    end

    def to_unsafe_unixcredentialsmessageclass
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessageClass*)
    end

    def parent_class
      Gio::SocketControlMessageClass.new(to_unsafe.as(LibGio::UnixCredentialsMessageClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::UnixCredentialsMessageClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::UnixCredentialsMessageClass*).value._g_reserved2
    end
  end

  class UnixCredentialsMessagePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixCredentialsMessagePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessagePrivate*)
    end

    def to_unsafe_unixcredentialsmessageprivate
      @pointer.not_nil!.as(LibGio::UnixCredentialsMessagePrivate*)
    end
  end

  class UnixFDList < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDList*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixFDList")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_fd_list_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDList*)
    end

    def to_unsafe_unixfdlist
      @pointer.not_nil!.as(LibGio::UnixFDList*)
    end

    def self.new : self
      __var0 = LibGio.unix_f_d_list_new
      GObject.raise_unexpected_null("g_unix_fd_list_new") if __var0.null?
      cast(Gio::UnixFDList.new(__var0))
    end

    def self.new_from_array(fds : ::Enumerable) : self
      n_fds = fds.size
      __fds = (__fds_ary = fds.map { |__item| Int32.new(__item) }.to_a).to_unsafe
      n_fds = __fds_ary.size
      __var0 = LibGio.unix_f_d_list_new_from_array(__fds, Int32.new(n_fds))
      GObject.raise_unexpected_null("g_unix_fd_list_new_from_array") if __var0.null?
      cast(Gio::UnixFDList.new(__var0))
    end

    def append(fd : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_f_d_list_append(@pointer.as(LibGio::UnixFDList*), Int32.new(fd), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def get(index_ : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_f_d_list_get(@pointer.as(LibGio::UnixFDList*), Int32.new(index_), pointerof(__var0))
      GLib::Error.assert(__var0)
      __var1
    end

    def length
      __var0 = LibGio.unix_f_d_list_get_length(@pointer.as(LibGio::UnixFDList*))
      __var0
    end

    def peek_fds
      __var0 = LibGio.unix_f_d_list_peek_fds(@pointer.as(LibGio::UnixFDList*), out length)
      GObject.raise_unexpected_null("g_unix_fd_list_peek_fds") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        __var1
      }, length}
    end

    def steal_fds
      __var0 = LibGio.unix_f_d_list_steal_fds(@pointer.as(LibGio::UnixFDList*), out length)
      GObject.raise_unexpected_null("g_unix_fd_list_steal_fds") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        __var1
      }, length}
    end
  end

  class UnixFDListClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(176u64, 0u8).as(LibGio::UnixFDListClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDListClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDListClass*)
    end

    def to_unsafe_unixfdlistclass
      @pointer.not_nil!.as(LibGio::UnixFDListClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::UnixFDListClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::UnixFDListClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::UnixFDListClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::UnixFDListClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::UnixFDListClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::UnixFDListClass*).value._g_reserved5
    end
  end

  class UnixFDListPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDListPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDListPrivate*)
    end

    def to_unsafe_unixfdlistprivate
      @pointer.not_nil!.as(LibGio::UnixFDListPrivate*)
    end
  end

  class UnixFDMessage < SocketControlMessage
    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDMessage*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixFDMessage")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_fd_message_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDMessage*)
    end

    def to_unsafe_unixfdmessage
      @pointer.not_nil!.as(LibGio::UnixFDMessage*)
    end

    def initialize(*, fd_list : Gio::UnixFDList? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless fd_list.nil?
        __var0 << "fd-list".to_unsafe
        __var1 << fd_list.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_fd_message_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new : self
      __var0 = LibGio.unix_f_d_message_new
      GObject.raise_unexpected_null("g_unix_fd_message_new") if __var0.null?
      cast(Gio::SocketControlMessage.new(__var0))
    end

    def self.new_with_fd_list(fd_list : Gio::UnixFDList) : self
      __var0 = LibGio.unix_f_d_message_new_with_fd_list(fd_list.to_unsafe_unixfdlist)
      GObject.raise_unexpected_null("g_unix_fd_message_new_with_fd_list") if __var0.null?
      cast(Gio::SocketControlMessage.new(__var0))
    end

    def append_fd(fd : ::Int)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.unix_f_d_message_append_fd(@pointer.as(LibGio::UnixFDMessage*), Int32.new(fd), pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def fd_list
      __var0 = LibGio.unix_f_d_message_get_fd_list(@pointer.as(LibGio::UnixFDMessage*))
      GObject.raise_unexpected_null("g_unix_fd_message_get_fd_list") if __var0.null?
      Gio::UnixFDList.new(__var0)
    end

    def steal_fds
      __var0 = LibGio.unix_f_d_message_steal_fds(@pointer.as(LibGio::UnixFDMessage*), out length)
      GObject.raise_unexpected_null("g_unix_fd_message_steal_fds") if __var0.null?
      {GObject::PointerIterator.new(__var0) { |__var1|
        __var1
      }, length}
    end
  end

  class UnixFDMessageClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(232u64, 0u8).as(LibGio::UnixFDMessageClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDMessageClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDMessageClass*)
    end

    def to_unsafe_unixfdmessageclass
      @pointer.not_nil!.as(LibGio::UnixFDMessageClass*)
    end

    def parent_class
      Gio::SocketControlMessageClass.new(to_unsafe.as(LibGio::UnixFDMessageClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::UnixFDMessageClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::UnixFDMessageClass*).value._g_reserved2
    end
  end

  class UnixFDMessagePrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixFDMessagePrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixFDMessagePrivate*)
    end

    def to_unsafe_unixfdmessageprivate
      @pointer.not_nil!.as(LibGio::UnixFDMessagePrivate*)
    end
  end

  class UnixInputStream < InputStream
    include Gio::FileDescriptorBased
    include Gio::PollableInputStream

    @pointer : Void*

    def initialize(pointer : LibGio::UnixInputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixInputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_input_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixInputStream*)
    end

    def to_unsafe_unixinputstream
      @pointer.not_nil!.as(LibGio::UnixInputStream*)
    end

    def initialize(*, close_fd : ::Bool? = nil, fd : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless close_fd.nil?
        __var0 << "close-fd".to_unsafe
        __var1 << close_fd.to_gvalue.to_unsafe.value
      end

      unless fd.nil?
        __var0 << "fd".to_unsafe
        __var1 << fd.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_input_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(fd : ::Int, close_fd : ::Bool) : self
      __var0 = LibGio.unix_input_stream_new(Int32.new(fd), LibC::Int.new(close_fd ? 1 : 0))
      GObject.raise_unexpected_null("g_unix_input_stream_new") if __var0.null?
      cast(Gio::InputStream.new(__var0))
    end

    def close_fd
      __var0 = LibGio.unix_input_stream_get_close_fd(@pointer.as(LibGio::UnixInputStream*))
      (__var0 == 1)
    end

    def fd
      __var0 = LibGio.unix_input_stream_get_fd(@pointer.as(LibGio::UnixInputStream*))
      __var0
    end

    def close_fd=(close_fd : ::Bool)
      LibGio.unix_input_stream_set_close_fd(@pointer.as(LibGio::UnixInputStream*), LibC::Int.new(close_fd ? 1 : 0))
      nil
    end
  end

  class UnixInputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(288u64, 0u8).as(LibGio::UnixInputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixInputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixInputStreamClass*)
    end

    def to_unsafe_unixinputstreamclass
      @pointer.not_nil!.as(LibGio::UnixInputStreamClass*)
    end

    def parent_class
      Gio::InputStreamClass.new(to_unsafe.as(LibGio::UnixInputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::UnixInputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::UnixInputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::UnixInputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::UnixInputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::UnixInputStreamClass*).value._g_reserved5
    end
  end

  class UnixInputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixInputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixInputStreamPrivate*)
    end

    def to_unsafe_unixinputstreamprivate
      @pointer.not_nil!.as(LibGio::UnixInputStreamPrivate*)
    end
  end

  class UnixMountEntry
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixMountEntry*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixMountEntry*)
    end

    def to_unsafe_unixmountentry
      @pointer.not_nil!.as(LibGio::UnixMountEntry*)
    end
  end

  class UnixMountMonitor < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::UnixMountMonitor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixMountMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_mount_monitor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixMountMonitor*)
    end

    def to_unsafe_unixmountmonitor
      @pointer.not_nil!.as(LibGio::UnixMountMonitor*)
    end

    def self.new : self
      __var0 = LibGio.unix_mount_monitor_new
      GObject.raise_unexpected_null("g_unix_mount_monitor_new") if __var0.null?
      cast(Gio::UnixMountMonitor.new(__var0))
    end

    def self.get
      __var0 = LibGio.unix_mount_monitor_get
      GObject.raise_unexpected_null("g_unix_mount_monitor_get") if __var0.null?
      Gio::UnixMountMonitor.new(__var0)
    end

    def rate_limit=(limit_msec : ::Int)
      LibGio.unix_mount_monitor_set_rate_limit(@pointer.as(LibGio::UnixMountMonitor*), Int32.new(limit_msec))
      nil
    end

    alias MountpointsChangedSignal = UnixMountMonitor -> Nil

    def on_mountpoints_changed(*, after = false, &block : MountpointsChangedSignal)
      __var0 = ->(arg0 : LibGio::UnixMountMonitor*, box : Void*) {
        ::Box(MountpointsChangedSignal).unbox(box).call(UnixMountMonitor.new(arg0))
      }

      __var1 = ::Box.box(MountpointsChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mountpoints-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mountpoints_changed(&block : MountpointsChangedSignal)
      on_mountpoints_changed(after: true, &block)
    end

    alias MountsChangedSignal = UnixMountMonitor -> Nil

    def on_mounts_changed(*, after = false, &block : MountsChangedSignal)
      __var0 = ->(arg0 : LibGio::UnixMountMonitor*, box : Void*) {
        ::Box(MountsChangedSignal).unbox(box).call(UnixMountMonitor.new(arg0))
      }

      __var1 = ::Box.box(MountsChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "mounts-changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_mounts_changed(&block : MountsChangedSignal)
      on_mounts_changed(after: true, &block)
    end
  end

  class UnixMountMonitorClass
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixMountMonitorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixMountMonitorClass*)
    end

    def to_unsafe_unixmountmonitorclass
      @pointer.not_nil!.as(LibGio::UnixMountMonitorClass*)
    end
  end

  class UnixMountPoint
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixMountPoint*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixMountPoint*)
    end

    def to_unsafe_unixmountpoint
      @pointer.not_nil!.as(LibGio::UnixMountPoint*)
    end

    def compare(mount2 : Gio::UnixMountPoint)
      __var0 = LibGio.unix_mount_point_compare(@pointer.as(LibGio::UnixMountPoint*), mount2.to_unsafe.as(LibGio::UnixMountPoint*))
      __var0
    end

    def copy
      __var0 = LibGio.unix_mount_point_copy(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_copy") if __var0.null?
      Gio::UnixMountPoint.new(__var0)
    end

    def free
      LibGio.unix_mount_point_free(@pointer.as(LibGio::UnixMountPoint*))
      nil
    end

    def device_path
      __var0 = LibGio.unix_mount_point_get_device_path(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_get_device_path") if __var0.null?
      ::String.new(__var0)
    end

    def fs_type
      __var0 = LibGio.unix_mount_point_get_fs_type(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_get_fs_type") if __var0.null?
      ::String.new(__var0)
    end

    def mount_path
      __var0 = LibGio.unix_mount_point_get_mount_path(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_get_mount_path") if __var0.null?
      ::String.new(__var0)
    end

    def options
      __var0 = LibGio.unix_mount_point_get_options(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_get_options") if __var0.null?
      ::String.new(__var0)
    end

    def guess_can_eject
      __var0 = LibGio.unix_mount_point_guess_can_eject(@pointer.as(LibGio::UnixMountPoint*))
      (__var0 == 1)
    end

    def guess_icon
      __var0 = LibGio.unix_mount_point_guess_icon(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_guess_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def guess_name
      __var0 = LibGio.unix_mount_point_guess_name(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_guess_name") if __var0.null?
      ::String.new(__var0)
    end

    def guess_symbolic_icon
      __var0 = LibGio.unix_mount_point_guess_symbolic_icon(@pointer.as(LibGio::UnixMountPoint*))
      GObject.raise_unexpected_null("g_unix_mount_point_guess_symbolic_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def loopback?
      __var0 = LibGio.unix_mount_point_is_loopback(@pointer.as(LibGio::UnixMountPoint*))
      (__var0 == 1)
    end

    def readonly?
      __var0 = LibGio.unix_mount_point_is_readonly(@pointer.as(LibGio::UnixMountPoint*))
      (__var0 == 1)
    end

    def user_mountable?
      __var0 = LibGio.unix_mount_point_is_user_mountable(@pointer.as(LibGio::UnixMountPoint*))
      (__var0 == 1)
    end
  end

  class UnixOutputStream < OutputStream
    include Gio::FileDescriptorBased
    include Gio::PollableOutputStream

    @pointer : Void*

    def initialize(pointer : LibGio::UnixOutputStream*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixOutputStream")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_output_stream_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixOutputStream*)
    end

    def to_unsafe_unixoutputstream
      @pointer.not_nil!.as(LibGio::UnixOutputStream*)
    end

    def initialize(*, close_fd : ::Bool? = nil, fd : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless close_fd.nil?
        __var0 << "close-fd".to_unsafe
        __var1 << close_fd.to_gvalue.to_unsafe.value
      end

      unless fd.nil?
        __var0 << "fd".to_unsafe
        __var1 << fd.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_output_stream_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(fd : ::Int, close_fd : ::Bool) : self
      __var0 = LibGio.unix_output_stream_new(Int32.new(fd), LibC::Int.new(close_fd ? 1 : 0))
      GObject.raise_unexpected_null("g_unix_output_stream_new") if __var0.null?
      cast(Gio::OutputStream.new(__var0))
    end

    def close_fd
      __var0 = LibGio.unix_output_stream_get_close_fd(@pointer.as(LibGio::UnixOutputStream*))
      (__var0 == 1)
    end

    def fd
      __var0 = LibGio.unix_output_stream_get_fd(@pointer.as(LibGio::UnixOutputStream*))
      __var0
    end

    def close_fd=(close_fd : ::Bool)
      LibGio.unix_output_stream_set_close_fd(@pointer.as(LibGio::UnixOutputStream*), LibC::Int.new(close_fd ? 1 : 0))
      nil
    end
  end

  class UnixOutputStreamClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::UnixOutputStreamClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixOutputStreamClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixOutputStreamClass*)
    end

    def to_unsafe_unixoutputstreamclass
      @pointer.not_nil!.as(LibGio::UnixOutputStreamClass*)
    end

    def parent_class
      Gio::OutputStreamClass.new(to_unsafe.as(LibGio::UnixOutputStreamClass*).value.parent_class)
    end

    def _g_reserved1
      to_unsafe.as(LibGio::UnixOutputStreamClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::UnixOutputStreamClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::UnixOutputStreamClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::UnixOutputStreamClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::UnixOutputStreamClass*).value._g_reserved5
    end
  end

  class UnixOutputStreamPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixOutputStreamPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixOutputStreamPrivate*)
    end

    def to_unsafe_unixoutputstreamprivate
      @pointer.not_nil!.as(LibGio::UnixOutputStreamPrivate*)
    end
  end

  class UnixSocketAddress < SocketAddress
    include Gio::SocketConnectable

    @pointer : Void*

    def initialize(pointer : LibGio::UnixSocketAddress*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GUnixSocketAddress")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_unix_socket_address_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixSocketAddress*)
    end

    def to_unsafe_unixsocketaddress
      @pointer.not_nil!.as(LibGio::UnixSocketAddress*)
    end

    def initialize(*, _abstract : ::Bool? = nil, address_type : Gio::UnixSocketAddressType? = nil, path : ::String? = nil, path_as_array : ::Enumerable(UInt8)? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless _abstract.nil?
        __var0 << "abstract".to_unsafe
        __var1 << _abstract.to_gvalue.to_unsafe.value
      end

      unless address_type.nil?
        __var0 << "address-type".to_unsafe
        __var1 << address_type.to_gvalue.to_unsafe.value
      end

      unless path.nil?
        __var0 << "path".to_unsafe
        __var1 << path.to_gvalue.to_unsafe.value
      end

      unless path_as_array.nil?
        __var0 << "path-as-array".to_unsafe
        __var1 << path_as_array.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_unix_socket_address_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(path : ::String) : self
      __var0 = LibGio.unix_socket_address_new(path.to_unsafe)
      GObject.raise_unexpected_null("g_unix_socket_address_new") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def self.new_abstract(path : ::String) : self
      path_len = path.size
      __var0 = LibGio.unix_socket_address_new_abstract((__path_ary = path.map { |__item| Int8.new(__item) }.to_a).to_unsafe, Int32.new(path_len))
      GObject.raise_unexpected_null("g_unix_socket_address_new_abstract") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def self.new_with_type(path : ::String, type : Gio::UnixSocketAddressType) : self
      path_len = path.size
      __var0 = LibGio.unix_socket_address_new_with_type((__path_ary = path.map { |__item| Int8.new(__item) }.to_a).to_unsafe, Int32.new(path_len), type)
      GObject.raise_unexpected_null("g_unix_socket_address_new_with_type") if __var0.null?
      cast(Gio::SocketAddress.new(__var0))
    end

    def self.abstract_names_supported
      __var0 = LibGio.unix_socket_address_abstract_names_supported
      (__var0 == 1)
    end

    def address_type
      __var0 = LibGio.unix_socket_address_get_address_type(@pointer.as(LibGio::UnixSocketAddress*))
      Gio::UnixSocketAddressType.new(__var0)
    end

    def is_abstract
      __var0 = LibGio.unix_socket_address_get_is_abstract(@pointer.as(LibGio::UnixSocketAddress*))
      (__var0 == 1)
    end

    def path
      __var0 = LibGio.unix_socket_address_get_path(@pointer.as(LibGio::UnixSocketAddress*))
      GObject.raise_unexpected_null("g_unix_socket_address_get_path") if __var0.null?
      ::String.new(__var0)
    end

    def path_len
      __var0 = LibGio.unix_socket_address_get_path_len(@pointer.as(LibGio::UnixSocketAddress*))
      __var0
    end

    def abstract : ::Bool
      __var0 = GObject::Value.new(type: GObject::Type::BOOLEAN)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "abstract", __var0)
      __var0.boolean
    end

    def path_as_array : ::Enumerable(UInt8)
      __var0 = GObject::Value.new(type: GObject::Type::ARRAY)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "path-as-array", __var0)
      __var0
    end
  end

  class UnixSocketAddressClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(160u64, 0u8).as(LibGio::UnixSocketAddressClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::UnixSocketAddressClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixSocketAddressClass*)
    end

    def to_unsafe_unixsocketaddressclass
      @pointer.not_nil!.as(LibGio::UnixSocketAddressClass*)
    end

    def parent_class
      Gio::SocketAddressClass.new(to_unsafe.as(LibGio::UnixSocketAddressClass*).value.parent_class)
    end
  end

  class UnixSocketAddressPrivate
    include GObject::WrappedType

    @pointer : Void*

    def initialize(pointer : LibGio::UnixSocketAddressPrivate*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::UnixSocketAddressPrivate*)
    end

    def to_unsafe_unixsocketaddressprivate
      @pointer.not_nil!.as(LibGio::UnixSocketAddressPrivate*)
    end
  end

  enum UnixSocketAddressType : UInt32
    INVALID         = 0
    ANONYMOUS       = 1
    PATH            = 2
    ABSTRACT        = 3
    ABSTRACT_PADDED = 4
  end

  class Vfs < GObject::Object
    @pointer : Void*

    def initialize(pointer : LibGio::Vfs*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GVfs")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_vfs_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::Vfs*)
    end

    def to_unsafe_vfs
      @pointer.not_nil!.as(LibGio::Vfs*)
    end

    def initialize
      @pointer = LibGObject.new_with_properties(LibGio._g_vfs_get_type, 0, nil, nil).as(Void*)
    end

    def self.default
      __var0 = LibGio.vfs_get_default
      GObject.raise_unexpected_null("g_vfs_get_default") if __var0.null?
      Gio::Vfs.new(__var0)
    end

    def self.local
      __var0 = LibGio.vfs_get_local
      GObject.raise_unexpected_null("g_vfs_get_local") if __var0.null?
      Gio::Vfs.new(__var0)
    end

    def file_for_path(path : ::String)
      __var0 = LibGio.vfs_get_file_for_path(@pointer.as(LibGio::Vfs*), path.to_unsafe)
      GObject.raise_unexpected_null("g_vfs_get_file_for_path") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def file_for_uri(uri : ::String)
      __var0 = LibGio.vfs_get_file_for_uri(@pointer.as(LibGio::Vfs*), uri.to_unsafe)
      GObject.raise_unexpected_null("g_vfs_get_file_for_uri") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def supported_uri_schemes
      __var0 = LibGio.vfs_get_supported_uri_schemes(@pointer.as(LibGio::Vfs*))
      GObject.raise_unexpected_null("g_vfs_get_supported_uri_schemes") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def active?
      __var0 = LibGio.vfs_is_active(@pointer.as(LibGio::Vfs*))
      (__var0 == 1)
    end

    def parse_name(parse_name : ::String)
      __var0 = LibGio.vfs_parse_name(@pointer.as(LibGio::Vfs*), parse_name.to_unsafe)
      GObject.raise_unexpected_null("g_vfs_parse_name") if __var0.null?
      Gio::File::Wrapper.new(__var0)
    end

    def register_uri_scheme(scheme : ::String, uri_func : Gio::VfsFileLookupFunc?, uri_data : Void*?, uri_destroy : GLib::DestroyNotify?, parse_name_func : Gio::VfsFileLookupFunc?, parse_name_data : Void*?, parse_name_destroy : GLib::DestroyNotify?)
      __var0 = LibGio.vfs_register_uri_scheme(@pointer.as(LibGio::Vfs*), scheme.to_unsafe, uri_func ? uri_func : nil, uri_data ? uri_data : Pointer(Void).null, uri_destroy ? uri_destroy : nil, parse_name_func ? parse_name_func : nil, parse_name_data ? parse_name_data : Pointer(Void).null, parse_name_destroy ? parse_name_destroy : nil)
      (__var0 == 1)
    end

    def unregister_uri_scheme(scheme : ::String)
      __var0 = LibGio.vfs_unregister_uri_scheme(@pointer.as(LibGio::Vfs*), scheme.to_unsafe)
      (__var0 == 1)
    end
  end

  class VfsClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(272u64, 0u8).as(LibGio::VfsClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::VfsClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::VfsClass*)
    end

    def to_unsafe_vfsclass
      @pointer.not_nil!.as(LibGio::VfsClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::VfsClass*).value.parent_class)
    end

    def is_active
      to_unsafe.as(LibGio::VfsClass*).value.is_active
    end

    def get_file_for_path
      to_unsafe.as(LibGio::VfsClass*).value.get_file_for_path
    end

    def get_file_for_uri
      to_unsafe.as(LibGio::VfsClass*).value.get_file_for_uri
    end

    def get_supported_uri_schemes
      to_unsafe.as(LibGio::VfsClass*).value.get_supported_uri_schemes
    end

    def parse_name
      to_unsafe.as(LibGio::VfsClass*).value.parse_name
    end

    def local_file_add_info
      to_unsafe.as(LibGio::VfsClass*).value.local_file_add_info
    end

    def add_writable_namespaces
      to_unsafe.as(LibGio::VfsClass*).value.add_writable_namespaces
    end

    def local_file_set_attributes
      to_unsafe.as(LibGio::VfsClass*).value.local_file_set_attributes
    end

    def local_file_removed
      to_unsafe.as(LibGio::VfsClass*).value.local_file_removed
    end

    def local_file_moved
      to_unsafe.as(LibGio::VfsClass*).value.local_file_moved
    end

    def deserialize_icon
      to_unsafe.as(LibGio::VfsClass*).value.deserialize_icon
    end

    def _g_reserved1
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::VfsClass*).value._g_reserved6
    end
  end

  alias VfsFileLookupFunc = LibGio::VfsFileLookupFunc

  module Volume
    # :nodoc:
    class Wrapper < GObject::Object
      include GObject::WrappedType
      include Volume
      @pointer : Void*

      def initialize(pointer : LibGio::Volume*)
        @pointer = pointer.as(Void*)
        raise(ArgumentError.new("#{type_name} is not a GVolume")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_volume_get_type)
        LibGObject.object_ref(pointer.as(LibGObject::Object*))
      end

      def finalize
        LibGObject.object_unref(@pointer.as(LibGObject::Object*))
      end

      def to_unsafe
        @pointer.not_nil!.as(LibGio::Volume*)
      end

      def to_unsafe_volume
        @pointer.not_nil!.as(LibGio::Volume*)
      end
    end

    def to_unsafe_volume
      @pointer.not_nil!.as(LibGio::Volume*)
    end

    def can_eject
      __var0 = LibGio.volume_can_eject(@pointer.as(LibGio::Volume*))
      (__var0 == 1)
    end

    def can_mount
      __var0 = LibGio.volume_can_mount(@pointer.as(LibGio::Volume*))
      (__var0 == 1)
    end

    def eject(flags : Gio::MountUnmountFlags, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.volume_eject(@pointer.as(LibGio::Volume*), flags, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.volume_eject_finish(@pointer.as(LibGio::Volume*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def eject_with_operation(flags : Gio::MountUnmountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.volume_eject_with_operation(@pointer.as(LibGio::Volume*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def eject_with_operation_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.volume_eject_with_operation_finish(@pointer.as(LibGio::Volume*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def enumerate_identifiers
      __var0 = LibGio.volume_enumerate_identifiers(@pointer.as(LibGio::Volume*))
      GObject.raise_unexpected_null("g_volume_enumerate_identifiers") if __var0.null?
      GObject::PointerIterator.new(__var0) { |__var1|
        ::String.new(__var1)
      }
    end

    def activation_root
      __var0 = LibGio.volume_get_activation_root(@pointer.as(LibGio::Volume*))
      __var1 = Gio::File::Wrapper.new(__var0) if __var0
      __var1
    end

    def drive
      __var0 = LibGio.volume_get_drive(@pointer.as(LibGio::Volume*))
      __var1 = Gio::Drive::Wrapper.new(__var0) if __var0
      __var1
    end

    def icon
      __var0 = LibGio.volume_get_icon(@pointer.as(LibGio::Volume*))
      GObject.raise_unexpected_null("g_volume_get_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def identifier(kind : ::String)
      __var0 = LibGio.volume_get_identifier(@pointer.as(LibGio::Volume*), kind.to_unsafe)
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def mount
      __var0 = LibGio.volume_get_mount(@pointer.as(LibGio::Volume*))
      __var1 = Gio::Mount::Wrapper.new(__var0) if __var0
      __var1
    end

    def name
      __var0 = LibGio.volume_get_name(@pointer.as(LibGio::Volume*))
      GObject.raise_unexpected_null("g_volume_get_name") if __var0.null?
      ::String.new(__var0)
    end

    def sort_key
      __var0 = LibGio.volume_get_sort_key(@pointer.as(LibGio::Volume*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def symbolic_icon
      __var0 = LibGio.volume_get_symbolic_icon(@pointer.as(LibGio::Volume*))
      GObject.raise_unexpected_null("g_volume_get_symbolic_icon") if __var0.null?
      Gio::Icon::Wrapper.new(__var0)
    end

    def uuid
      __var0 = LibGio.volume_get_uuid(@pointer.as(LibGio::Volume*))
      __var1 = ::String.new(__var0) if __var0
      __var1
    end

    def mount(flags : Gio::MountMountFlags, mount_operation : Gio::MountOperation?, cancellable : Gio::Cancellable?, callback : Gio::AsyncReadyCallback?, user_data : Void*?)
      LibGio.volume_mount(@pointer.as(LibGio::Volume*), flags, mount_operation ? mount_operation.to_unsafe_mountoperation : Pointer(LibGio::MountOperation).null, cancellable ? cancellable.to_unsafe_cancellable : Pointer(LibGio::Cancellable).null, callback ? callback : nil, user_data ? user_data : Pointer(Void).null)
      nil
    end

    def mount_finish(result : Gio::AsyncResult)
      __var0 = Pointer(LibGLib::Error).null
      __var1 = LibGio.volume_mount_finish(@pointer.as(LibGio::Volume*), result.to_unsafe_asyncresult, pointerof(__var0))
      GLib::Error.assert(__var0)
      (__var1 == 1)
    end

    def should_automount
      __var0 = LibGio.volume_should_automount(@pointer.as(LibGio::Volume*))
      (__var0 == 1)
    end

    alias ChangedSignal = Volume -> Nil

    def on_changed(*, after = false, &block : ChangedSignal)
      __var0 = ->(arg0 : LibGio::Volume*, box : Void*) {
        ::Box(ChangedSignal).unbox(box).call(Volume::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(ChangedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "changed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_changed(&block : ChangedSignal)
      on_changed(after: true, &block)
    end

    alias RemovedSignal = Volume -> Nil

    def on_removed(*, after = false, &block : RemovedSignal)
      __var0 = ->(arg0 : LibGio::Volume*, box : Void*) {
        ::Box(RemovedSignal).unbox(box).call(Volume::Wrapper.new(arg0))
      }

      __var1 = ::Box.box(RemovedSignal.new { |arg0|
        block.call(arg0)
      })
      LibGObject.signal_connect_data(@pointer.as(LibGObject::Object*), "removed", LibGObject::Callback.new(__var0.pointer, Pointer(Void).null), GObject::ClosureDataManager.register(__var1), ->GObject::ClosureDataManager.deregister, after ? GObject::ConnectFlags::AFTER : GObject::ConnectFlags::None)
    end

    def after_removed(&block : RemovedSignal)
      on_removed(after: true, &block)
    end
  end

  class VolumeIface
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(184u64, 0u8).as(LibGio::VolumeIface*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::VolumeIface*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::VolumeIface*)
    end

    def to_unsafe_volumeiface
      @pointer.not_nil!.as(LibGio::VolumeIface*)
    end

    def g_iface
      GObject::TypeInterface.new(to_unsafe.as(LibGio::VolumeIface*).value.g_iface)
    end

    def changed
      to_unsafe.as(LibGio::VolumeIface*).value.changed
    end

    def removed
      to_unsafe.as(LibGio::VolumeIface*).value.removed
    end

    def get_name
      to_unsafe.as(LibGio::VolumeIface*).value.get_name
    end

    def get_icon
      to_unsafe.as(LibGio::VolumeIface*).value.get_icon
    end

    def get_uuid
      to_unsafe.as(LibGio::VolumeIface*).value.get_uuid
    end

    def get_drive
      to_unsafe.as(LibGio::VolumeIface*).value.get_drive
    end

    def get_mount
      to_unsafe.as(LibGio::VolumeIface*).value.get_mount
    end

    def can_mount
      to_unsafe.as(LibGio::VolumeIface*).value.can_mount
    end

    def can_eject
      to_unsafe.as(LibGio::VolumeIface*).value.can_eject
    end

    def mount_fn
      to_unsafe.as(LibGio::VolumeIface*).value.mount_fn
    end

    def mount_finish
      to_unsafe.as(LibGio::VolumeIface*).value.mount_finish
    end

    def eject
      to_unsafe.as(LibGio::VolumeIface*).value.eject
    end

    def eject_finish
      to_unsafe.as(LibGio::VolumeIface*).value.eject_finish
    end

    def get_identifier
      to_unsafe.as(LibGio::VolumeIface*).value.get_identifier
    end

    def enumerate_identifiers
      to_unsafe.as(LibGio::VolumeIface*).value.enumerate_identifiers
    end

    def should_automount
      to_unsafe.as(LibGio::VolumeIface*).value.should_automount
    end

    def get_activation_root
      to_unsafe.as(LibGio::VolumeIface*).value.get_activation_root
    end

    def eject_with_operation
      to_unsafe.as(LibGio::VolumeIface*).value.eject_with_operation
    end

    def eject_with_operation_finish
      to_unsafe.as(LibGio::VolumeIface*).value.eject_with_operation_finish
    end

    def get_sort_key
      to_unsafe.as(LibGio::VolumeIface*).value.get_sort_key
    end

    def get_symbolic_icon
      to_unsafe.as(LibGio::VolumeIface*).value.get_symbolic_icon
    end
  end

  class NativeVolumeMonitor < VolumeMonitor
    @pointer : Void*

    def initialize(pointer : LibGio::NativeVolumeMonitor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GNativeVolumeMonitor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_native_volume_monitor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::NativeVolumeMonitor*)
    end

    def to_unsafe_nativevolumemonitor
      @pointer.not_nil!.as(LibGio::NativeVolumeMonitor*)
    end
  end

  class VolumeMonitorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(336u64, 0u8).as(LibGio::VolumeMonitorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::VolumeMonitorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::VolumeMonitorClass*)
    end

    def to_unsafe_volumemonitorclass
      @pointer.not_nil!.as(LibGio::VolumeMonitorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::VolumeMonitorClass*).value.parent_class)
    end

    def volume_added
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.volume_added
    end

    def volume_removed
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.volume_removed
    end

    def volume_changed
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.volume_changed
    end

    def mount_added
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.mount_added
    end

    def mount_removed
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.mount_removed
    end

    def mount_pre_unmount
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.mount_pre_unmount
    end

    def mount_changed
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.mount_changed
    end

    def drive_connected
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.drive_connected
    end

    def drive_disconnected
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.drive_disconnected
    end

    def drive_changed
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.drive_changed
    end

    def is_supported
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.is_supported
    end

    def get_connected_drives
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.get_connected_drives
    end

    def get_volumes
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.get_volumes
    end

    def get_mounts
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.get_mounts
    end

    def get_volume_for_uuid
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.get_volume_for_uuid
    end

    def get_mount_for_uuid
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.get_mount_for_uuid
    end

    def adopt_orphan_mount
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.adopt_orphan_mount
    end

    def drive_eject_button
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.drive_eject_button
    end

    def drive_stop_button
      to_unsafe.as(LibGio::VolumeMonitorClass*).value.drive_stop_button
    end

    def _g_reserved1
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved1
    end

    def _g_reserved2
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved2
    end

    def _g_reserved3
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved3
    end

    def _g_reserved4
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved4
    end

    def _g_reserved5
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved5
    end

    def _g_reserved6
      to_unsafe.as(LibGio::VolumeMonitorClass*).value._g_reserved6
    end
  end

  class ZlibCompressor < GObject::Object
    include Gio::Converter

    @pointer : Void*

    def initialize(pointer : LibGio::ZlibCompressor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GZlibCompressor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_zlib_compressor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ZlibCompressor*)
    end

    def to_unsafe_zlibcompressor
      @pointer.not_nil!.as(LibGio::ZlibCompressor*)
    end

    def initialize(*, file_info : Gio::FileInfo? = nil, format : Gio::ZlibCompressorFormat? = nil, level : Int32? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless file_info.nil?
        __var0 << "file-info".to_unsafe
        __var1 << file_info.to_gvalue.to_unsafe.value
      end

      unless format.nil?
        __var0 << "format".to_unsafe
        __var1 << format.to_gvalue.to_unsafe.value
      end

      unless level.nil?
        __var0 << "level".to_unsafe
        __var1 << level.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_zlib_compressor_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(format : Gio::ZlibCompressorFormat, level : ::Int) : self
      __var0 = LibGio.zlib_compressor_new(format, Int32.new(level))
      GObject.raise_unexpected_null("g_zlib_compressor_new") if __var0.null?
      cast(Gio::ZlibCompressor.new(__var0))
    end

    def file_info
      __var0 = LibGio.zlib_compressor_get_file_info(@pointer.as(LibGio::ZlibCompressor*))
      GObject.raise_unexpected_null("g_zlib_compressor_get_file_info") if __var0.null?
      Gio::FileInfo.new(__var0)
    end

    def file_info=(file_info : Gio::FileInfo?)
      LibGio.zlib_compressor_set_file_info(@pointer.as(LibGio::ZlibCompressor*), file_info ? file_info.to_unsafe_fileinfo : Pointer(LibGio::FileInfo).null)
      nil
    end

    def format : Gio::ZlibCompressorFormat
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "format", __var0)
      Gio::ZlibCompressorFormat.new(UInt32.new(__var0.enum))
    end

    def level : Int32
      __var0 = GObject::Value.new(type: GObject::Type::INT)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "level", __var0)
      __var0.int
    end
  end

  class ZlibCompressorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::ZlibCompressorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ZlibCompressorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ZlibCompressorClass*)
    end

    def to_unsafe_zlibcompressorclass
      @pointer.not_nil!.as(LibGio::ZlibCompressorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ZlibCompressorClass*).value.parent_class)
    end
  end

  enum ZlibCompressorFormat : UInt32
    ZLIB = 0
    GZIP = 1
    RAW  = 2
  end

  class ZlibDecompressor < GObject::Object
    include Gio::Converter

    @pointer : Void*

    def initialize(pointer : LibGio::ZlibDecompressor*)
      @pointer = pointer.as(Void*)
      raise(ArgumentError.new("#{type_name} is not a GZlibDecompressor")) unless LibGObject.type_check_instance_is_a(pointer.as(LibGObject::TypeInstance*), LibGio._g_zlib_decompressor_get_type)
      LibGObject.object_ref(pointer.as(LibGObject::Object*))
    end

    def finalize
      LibGObject.object_unref(@pointer.as(LibGObject::Object*))
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ZlibDecompressor*)
    end

    def to_unsafe_zlibdecompressor
      @pointer.not_nil!.as(LibGio::ZlibDecompressor*)
    end

    def initialize(*, format : Gio::ZlibCompressorFormat? = nil)
      __var0 = [] of UInt8*
      __var1 = [] of LibGObject::Value
      unless format.nil?
        __var0 << "format".to_unsafe
        __var1 << format.to_gvalue.to_unsafe.value
      end

      @pointer = LibGObject.new_with_properties(LibGio._g_zlib_decompressor_get_type, __var0.size, __var0, __var1).as(Void*)
    end

    def self.new(format : Gio::ZlibCompressorFormat) : self
      __var0 = LibGio.zlib_decompressor_new(format)
      GObject.raise_unexpected_null("g_zlib_decompressor_new") if __var0.null?
      cast(Gio::ZlibDecompressor.new(__var0))
    end

    def file_info
      __var0 = LibGio.zlib_decompressor_get_file_info(@pointer.as(LibGio::ZlibDecompressor*))
      GObject.raise_unexpected_null("g_zlib_decompressor_get_file_info") if __var0.null?
      Gio::FileInfo.new(__var0)
    end

    def format : Gio::ZlibCompressorFormat
      __var0 = GObject::Value.new(type: GObject::Type::ENUM)
      LibGObject.object_get_property(@pointer.as(LibGObject::Object*), "format", __var0)
      Gio::ZlibCompressorFormat.new(UInt32.new(__var0.enum))
    end
  end

  class ZlibDecompressorClass
    include GObject::WrappedType

    def self.new : self
      new(Pointer(UInt8).malloc(136u64, 0u8).as(LibGio::ZlibDecompressorClass*))
    end

    @pointer : Void*

    def initialize(pointer : LibGio::ZlibDecompressorClass*)
      @pointer = pointer.as(Void*)
    end

    def to_unsafe
      @pointer.not_nil!.as(LibGio::ZlibDecompressorClass*)
    end

    def to_unsafe_zlibdecompressorclass
      @pointer.not_nil!.as(LibGio::ZlibDecompressorClass*)
    end

    def parent_class
      GObject::ObjectClass.new(to_unsafe.as(LibGio::ZlibDecompressorClass*).value.parent_class)
    end
  end
end
